<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>yinwoods个人博客</title>
    <description>最新文章</description>
    <link></link>
    
      
        <item>
          <title>python中的context manager</title>
          <description>&lt;p&gt;最近在读python进阶类书籍《Intermediate Python》，看到后面有一章讲到&lt;code&gt;context manager&lt;/code&gt;，讲的很浅，我也没看懂。于是自己抽时间搜集了网上的一些资料，整理如下：&lt;/p&gt;

&lt;p&gt;python中的&lt;code&gt;context manager&lt;/code&gt;也叫做上下文管理器，主要功能是确保代码块始终能够得到正确的‘善后’处理。有点像java中的&lt;code&gt;try 	... catch 	... finally 	...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于打开文件读写，我们都知道下面的实现方式更好：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
with open('file') as f:
    for line in f:
    	print(line)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;但这种方式为什么更好呢？原因在于使用&lt;code&gt;with&lt;/code&gt;可以执行&lt;code&gt;context manager&lt;/code&gt;的相应函数，确保被打开的文件始终能够被关闭。如果我们自己手动&lt;code&gt;open()&lt;/code&gt;、&lt;code&gt;close()&lt;/code&gt;则可能会因为中间代码产生的异常导致&lt;code&gt;close()&lt;/code&gt;无法执行。因此使用&lt;code&gt;with&lt;/code&gt;可以让代码既简洁又有效。&lt;/p&gt;

&lt;p&gt;下面接着说一说&lt;code&gt;context manager&lt;/code&gt;的功能与用法。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;管理资源&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;context manager&lt;/code&gt;最常被用于管理资源，事实上，这也是很多时候我们使用它的原因。&lt;/p&gt;

&lt;p&gt;当我们打开一个文件时，程序会占有对应的资源（文件描述符），而资源的管理则由操作系统来完成，也就是说同一时间能够打开的文件或进程是有限的。&lt;/p&gt;

&lt;p&gt;例如，运行下面这份代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
files = []
for x in range(100000):
    files.append(open('foo.txt', 'w'))
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在mac os或linux上运行这份代码很有可能会产生OSError而导致中断，而在windows上运行程序则可能导致系统直接卡死。&lt;/p&gt;

&lt;p&gt;那么问题的原因是什么呢？&lt;/p&gt;

&lt;p&gt;答：是&lt;em&gt;内存泄露！&lt;/em&gt; 这里的泄露原因是指打开文件后但未关闭。&lt;/p&gt;

&lt;p&gt;为了避免对文件操作时产生上述的错误，有两种解决方法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、避免同时打开超过操作系统上限个数个文件；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、每次打开文件后关闭文件；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;毫无疑问，这里2的操作更好，因为能够更好地实现高层抽象并解决内存泄露问题。&lt;/p&gt;

&lt;p&gt;先说1：在unix上&lt;code&gt;ulimit -n&lt;/code&gt;可以查看同时打开文件描述符上限，在写代码时确保同时打开的文件数不超过上限值即可。但是这里并没有解决根本问题：内存泄露！&lt;/p&gt;

&lt;p&gt;再说2：我们当然可以为上面的代码添加close()函数，可是如果打开文件或者对文件内容处理时产生异常，那么后面的&lt;code&gt;close()&lt;/code&gt;就无法被执行，从而导致内存泄露。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;context manager&lt;/code&gt;正是用于处理这种情况的一个接口：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
with something_that_returns_a_context_manager() as my_resource:
    do_something(my_resource)
    ...
    print('done using my_resource')
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;with&lt;/code&gt;，我们可以操作任何一个返回上下文管理器的函数（例如内置函数&lt;code&gt;open()&lt;/code&gt;）；&lt;code&gt;with&lt;/code&gt;能够保证当相应代码块内的代码执行完毕时，始终调用一个包含清理资源的‘善后’函数。这个‘善后’函数就定义在&lt;code&gt;context manager&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;实现一个最简单的context manager只要求包含&lt;code&gt;__enter__()&lt;/code&gt;函数以及&lt;code&gt;__exit__()&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;__enter__()&lt;/code&gt;执行操作并返回被管理的资源；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;__exit__()&lt;/code&gt;则清理资源，无返回。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;例如我们通过以下代码创建一个自己的&lt;code&gt;context manager&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;```python
class File():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def __init__(self, filename, mode):
    self.filename = filename
    self.mode = mode
    
def __enter__(self):
    self.open_file = open(self.filename, self.mode)
    return self.open_file
    
def __exit__(self):
    self.open_file.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;files = []
for _ in range(100000):
    with File(‘foo.txt’, ‘w’) as f:
        files.append(f.write(‘foo’))
```&lt;/p&gt;

&lt;p&gt;这里&lt;code&gt;__enter__()&lt;/code&gt;打开文件，并返回；&lt;code&gt;__exit__()&lt;/code&gt;则关闭文件。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;其他有用的资源管理器&lt;/h3&gt;

&lt;p&gt;很多库中也包含资源管理器，例如&lt;code&gt;zipfile.ZipFile&lt;/code&gt;、&lt;code&gt;subprocess.Popen&lt;/code&gt;、&lt;code&gt;tarfile.TarFile&lt;/code&gt;、&lt;code&gt;telnet.Telnet&lt;/code&gt;、&lt;code&gt;pathlib.Path&lt;/code&gt;等。其实，在使用完资源之后调用&lt;code&gt;close()&lt;/code&gt;方法的都是&lt;code&gt;context manager&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;contextlib&quot;&gt;关于&lt;code&gt;contextlib&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;contextlib&lt;/code&gt;模块包含了许多创建、使用&lt;code&gt;context manager&lt;/code&gt;的工具。&lt;/p&gt;

&lt;p&gt;例如使用&lt;code&gt;@contextmanager&lt;/code&gt;装饰器来创建一个&lt;code&gt;context manager&lt;/code&gt;。具体的创建方法是使用&lt;code&gt;@contextmanager&lt;/code&gt;来装饰只包含一个&lt;code&gt;yield&lt;/code&gt;语句的&lt;code&gt;generator&lt;/code&gt;函数。在&lt;code&gt;yield&lt;/code&gt;之前的部分都被视为&lt;code&gt;__enter__()&lt;/code&gt;函数内容，而之后的部分则是&lt;code&gt;__exit__()&lt;/code&gt;函数内容。下面让我们用这种方法来重写&lt;code&gt;File()&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;```python
from contextlib import contextmanager&lt;/p&gt;

&lt;p&gt;@contextmanager
def open_file(path, mode):
    the_file = open(path, mode)
    yield the_file
    the_file.close()&lt;/p&gt;

&lt;p&gt;files = []&lt;/p&gt;

&lt;p&gt;for x in range(100000):
    with open_file(‘foo.txt’, ‘w’) as f:
        files.append(f)&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;对比后可以发现使用这种方法的代码更加简洁。&lt;/p&gt;

&lt;p&gt;另外有一个很简单的例子可以帮助你理解&lt;code&gt;@contextmanager&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```python
from contextlib import contextmanager&lt;/p&gt;

&lt;p&gt;@contextmanager
def tag(name):
    print(“&amp;lt;%s&amp;gt;” % name)
    yield
    print(“&amp;lt;/%s&amp;gt;” % name)&lt;/p&gt;

&lt;p&gt;with tag(“h1”):
    print(“hello, world!”)
```&lt;/p&gt;

&lt;p&gt;输出：&lt;code&gt;&amp;lt;h1&amp;gt;hello, world!&amp;lt;/h1&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外也可以通过&lt;code&gt;contextlib.ContextDecorator&lt;/code&gt;来实现自己的&lt;code&gt;context manager&lt;/code&gt;装饰器。例如接着使用上面的例子来说明：&lt;/p&gt;

&lt;p&gt;```python
from contextlib import ContextDecorator&lt;/p&gt;

&lt;p&gt;class makeparagraph(ContextDecorator):
    def &lt;strong&gt;enter&lt;/strong&gt;(self):
        print(‘&amp;lt;p&amp;gt;’)
        return self&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def __exit__(self, *exc):
    print('&amp;lt;/p&amp;gt;')
    return False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@makeparagraph
def emit_html():
    print(‘Here is some non-HTML’)
```&lt;/p&gt;

&lt;p&gt;执行&lt;code&gt;emit_html()&lt;/code&gt;
会输出&lt;code&gt;&amp;lt;p&amp;gt;Here is some non-HTML&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;参考文章：&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0343/&quot;&gt;PEP 34&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;https://jeffknupp.com/blog/2016/03/07/python-with-context-managers/&quot;&gt;Python with Context Managers&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;
</description>
          <pubDate>2016-08-08T00:00:00+08:00</pubDate>
          <link>/coding/python%E4%B8%AD%E7%9A%84context-manager.html</link>
          <guid isPermaLink="true">/coding/python%E4%B8%AD%E7%9A%84context-manager.html</guid>
        </item>
      
    
      
        <item>
          <title>python爬虫requests登录解决422错误</title>
          <description>&lt;p&gt;小伙伴&lt;a href=&quot;http://blog.csdn.net/cumtcyf&quot;&gt;崔崔&lt;/a&gt;今天要爬取&lt;a href=&quot;http://ucar.act.buaa.edu.cn/users/sign_in&quot;&gt;北航ACT实验室的车联网&lt;/a&gt;的信息，已有账号密码。模拟登录使用的是python的requests.session().post(),通过chrome的network观察post的表单数据，发现有一个&lt;code&gt;authenticity_token&lt;/code&gt;，这个数据是每次刷网页动态生成的，存放在页面header的meta标签中，问题不大，直接用beautifulsoup获取就可以了。&lt;/p&gt;

&lt;p&gt;问题出现在post之后，总是得到HTTP 422错误。通过查询了解到这里的422错误是指验证错误，可是token是即时获取的，其他信息也是完全按照表单要求填写，并且对提交数据进行了urlencode并使用&lt;code&gt;gbk&lt;/code&gt;encode，实在是想不通原因。然后通过神奇的谷歌居然搜到了相同问题的博客。。。连代码都写得和我的惊人的相似。。。我都开始怀疑是不是和我爬的同一个网站了。。。&lt;/p&gt;

&lt;p&gt;正确的爬取姿势是带着cookie验证，我猜这里的&lt;code&gt;authenticity_token&lt;/code&gt;与cookie是相关联的，因为爬取时没带上cookie，所以无法验证成功。如果想要带上cookie只需使用&lt;code&gt;requests.Session()&lt;/code&gt;来post即可。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.python-requests.org/zh_CN/latest/user/advanced.html#advanced&quot;&gt;requests.Session()简介&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单介绍一下：&lt;/p&gt;

&lt;p&gt;Session作为一个会话对象，会在同一个Session实例发出所有请求之间保存cookie。其实这里可以类比一下：当你登录淘宝后，短时间内访问淘宝的其他页面，不需要重新登录。&lt;/p&gt;

&lt;p&gt;完整的代码如下：&lt;/p&gt;

&lt;p&gt;```python
#author : yinwoods
import urllib
import requests
import urllib.request
from bs4 import BeautifulSoup&lt;/p&gt;

&lt;p&gt;def main():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;url = 'http://ucar.act.buaa.edu.cn/users/sign_in'


headers = {
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Encoding': 'gzip,deflate',
    'Accept-Language': 'zh-CN,zh;q=0.8',
    'Connection': 'keep-alive',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Host': 'ucar.act.buaa.edu.cn',
    'Origin': 'http://ucar.act.buaa.edu.cn',
    'Referer': 'http://ucar.act.buaa.edu.cn/stat',
    'User-Agent': 'Mozilla/5.0(X11;Linux x86_64) AppleWebKit/537.36(KHTML, like Gecko) Ubuntu Chromium/51.0.2704.79 Chrome/51.0.2704.79 Safari / 537.36'
}

#先获取页面源码，提取token
session = requests.Session()
html = session.get(url, headers=headers).text

htmlDoc = BeautifulSoup(html, 'html.parser')
token = htmlDoc.find_all('meta')[-1]['content']

print(token)

datas = urllib.parse.urlencode({
    'utf8': '✓',
    'authenticity_token': token,
    'user[username]': username,
    'user[password]': password,
    'user[remember_me]': '1',
    'commit': '登录'
}).encode('gbk')

requests.session().post()

print(datas)

print(session.post(url=url, params=datas, headers=headers))

res = session.get('http://ucar.act.buaa.edu.cn/users/sign_in').text
print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == ‘&lt;strong&gt;main&lt;/strong&gt;’:
    main()&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;打印页面后可以发现登录成功，状态码返回200。事后反思，意识到&lt;code&gt;token+cookie&lt;/code&gt;可能这是一种比较通用的验证机制，自己不了解一方面是因为经验不足，另一方面可能就是之前爬的网站大都比较简单（是属于开放类门户网站），能够爬取成功并不代表自己的能力很高。&lt;/p&gt;

&lt;p&gt;不过话又说回来自己想学的东西太多了。。。目前在看CSAPP，后面有时间再学习《HTTP权威指南》。&lt;/p&gt;
</description>
          <pubDate>2016-07-27T00:00:00+08:00</pubDate>
          <link>/myshare/python%E7%88%AC%E8%99%ABrequests%E7%99%BB%E5%BD%95%E8%A7%A3%E5%86%B3422%E9%94%99%E8%AF%AF.html</link>
          <guid isPermaLink="true">/myshare/python%E7%88%AC%E8%99%ABrequests%E7%99%BB%E5%BD%95%E8%A7%A3%E5%86%B3422%E9%94%99%E8%AF%AF.html</guid>
        </item>
      
    
      
        <item>
          <title>一点感想</title>
          <description>&lt;p&gt;大学结束都快一个月了，期间也不是没想过写点什么，可又总觉得提笔忘字。其实大学四年对我来说不仅仅是四年的光阴，更多的是期间的经历给我带来的蜕变，如果说大学前我是个孩子，那大学后的我已经变成一名青年了。有时候也会问自己，这样的话少年的我又去了哪里了呢？&lt;/p&gt;

&lt;p&gt;回想起四年的生活，脑海中的画面总是定格在那个夜晚上自习刚结束，独自一人走在回寝室路上的时刻，那个时候的自己是多么充实快乐啊。如果说四年来学会了什么以后能够在社会上安身立命的技能的话，我的答案不会是编程，而是独处。编程归根到底来说只是一项普通的技能，是大多数人通过合理训练能够习得的技能，而独处则不然，它很大程度上依赖于外界环境的“压迫”。可能因为自己性子里的因素吧，对待生活赐予的“压迫”，我接受地很好，以至于现在很多时候能够享受独处，而也正是由于独处时的思考，帮助我理清了自己未来对待生活的想法。可以说我对自己想要的生活以及想要变成的模样，在这个独处的过程中变得愈发清晰。&lt;/p&gt;

&lt;p&gt;最近在读余秋雨的《行者无疆》，书中讲述了作者在欧洲旅游的一些观察和感悟，虽然才读了四分之一，可已然感概良多。也正是在读这本书的过程中，我又多次思考了自己憧憬向往的未来生活。记得初中学过论语的“一箪食，一瓢饮，在陋巷。人不堪其忧，回也不改其乐”，当初的自己怎么也不能理解在这种物质极度匮乏的情况下如何能乐呢？然而现在自己慢慢地能够理解了，开心快乐本就源自内心，一个人内心强大又何需用外界物质来换取内心的愉悦呢？之前思考总是走上一条弯路：安贫乐道是一种高尚的情怀。现在则不这么看了，安贫乐道值得钦佩，更值得赞扬的应该是即使大富大贵仍能够不改其乐。&lt;/p&gt;

&lt;p&gt;由此也引出了我对未来生活的一点小思考，我清楚地认知到未来我的幸福快乐不在于我拿起了多少东西，财富？权利？荣誉？都不是！在于我能够放下多少东西，生命的前半段要扛起路上的包裹，而后半程也需要放下。我所追求的生活应当是熵减的，既然清楚地意识到自己的目标，那么通往目标的路上我只需要避开对我来说过于复杂的人和事就已经成功一大半了（事实上一直以来我也确实是这么做的）。&lt;/p&gt;

&lt;p&gt;对于未来，我想和一群简单的朋友生活在一个简单的圈子里。而这里的简单很大程度上取决于自己的选择。😀&lt;/p&gt;

&lt;p&gt;——写于2016年7月20日夜 大雨&lt;/p&gt;
</description>
          <pubDate>2016-07-21T00:00:00+08:00</pubDate>
          <link>/diary/%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3.html</link>
          <guid isPermaLink="true">/diary/%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3.html</guid>
        </item>
      
    
      
        <item>
          <title>python爬虫统计豆瓣观影记录</title>
          <description>&lt;p&gt;说来大四这一年真的看了好多电影啊。。。因为平时有用豆瓣电影记录自己已看电影的习惯，而且博客上也维护了一个影单，所以趁着这几天有时间就想着干脆写一个统计自己大四这一年观影记录的小程序吧！&lt;/p&gt;

&lt;p&gt;打算最终分三种方式统计信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;统计不同类型的电影数目并绘制柱状图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;统计不同语言的电影数目并绘制饼状图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;统计每个月的观影数目并绘制趋势图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此需要获取的信息电影信息有：电影名、观影时间、电影类型、电影语言；另外后期可能还想统计其他信息，干脆把评分、自己的评论、电影导演和制片国家/地区都爬取下来。&lt;/p&gt;

&lt;p&gt;说干就干，首先设计一下程序的逻辑架构，具体分为以下几步：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 获取博客已看影单上的所有电影名，并存入数据库的movie表中；

2. 利用爬虫爬取豆瓣电影上自己的观影记录，包括（电影名、评分、观影时间、自己的评论、电影类型、电影导演、制片国家/地区 以及 电影语言），获取这些信息后写入数据库的douban_movies表；

3. 利用douban_movies表与movie表left join，并更新movie表出电影名以外的其他信息；

4. 通过相关模块包把数据库中的数据写入excel表中并生成图表；

5. 将生成的图表转换为图片并保存；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个思路是通的，而且看起来操作起来难度也不大。在这里要解释一下为什么我不直接使用douban_movies表来统计，而要基于博客的观影记录来统计，原因在于我是去年十一月份才真正意义上开始使用豆瓣电影标记功能的，因此一些很久以前（like:小时候^_^）看过的电影也在豆瓣上标记下来了，所以这部分数据是要剔除的。&lt;/p&gt;

&lt;p&gt;当然对于很早之前就开始使用豆瓣电影的朋友来说，只需对程序稍加改造即可生成自己的观影记录了，当然后文也会提供改造后的代码链接。这里就展示下我的个人统计数据吧（个人豆瓣id:&lt;a href=&quot;https://www.douban.com/people/yinwoods/&quot;&gt;yinwoods&lt;/a&gt;）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post50-Chart1.jpg&quot; alt=&quot;观影时间统计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里2015年11月份观影指数暴涨是因为我标记了很多很早以前看过的电影。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post50-Chart2.jpg&quot; alt=&quot;观影语言统计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post50-Chart3.jpg&quot; alt=&quot;观影类型统计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面就按照逻辑架构开始编写程序吧！&lt;/p&gt;

&lt;h4 id=&quot;movie&quot;&gt;1. 获取博客上已看影单的所有电影名，并存入数据库中的movie表&lt;/h4&gt;

&lt;p&gt;虽然简单，但是还是要说下思路，以影单页面的url作为入口，爬虫访问后利用beautifulsoup解析文档树，提取所有的电影名并将电影名插入数据表中，为了防止每次运行程序不会插入重复数据，插入之前需要判重操作。代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#获取url 对应 HTML 源码
def get_html(self, url):
    request = urllib.request.Request(url)

    try: #代理：110.81.238.173:8088
        proxy_support = urllib.request.ProxyHandler({'http': '110.81.238.173:8088'})
        opener = urllib.request.build_opener(proxy_support)
        urllib.request.install_opener(opener)

        page = urllib.request.urlopen(request)

        if page.headers.get('Content-Encoding') == 'gzip':
            return zlib.decompress(page.read(), 16+zlib.MAX_WBITS).decode('gbk', 'ignore')
        else:
            return page.read().decode(page.headers.get_content_charset(), 'ignore')
    #异常处理
    except urllib.request.HTTPError as e:
        print('HTTPERROR: ', str(e))
        return urllib.request.HTTPError
    except http.client.HTTPException as e:
        print('http.client.HTTPException: ', str(e))
        return http.client.HTTPException

#获取电影名并写入数据库movie中
def get_movies(self, url_lists):

    for url in url_lists:
        html_doc = BeautifulSoup(self.get_html(url), 'html.parser')
        div_lists = html_doc.select('#content &amp;gt; div &amp;gt; div &amp;gt; a &amp;gt; div')
        for div in div_lists:

            movie_name = div.getText()

            #查重
            query = 'SELECT COUNT(*) FROM movie WHERE movie_name = %s'
            self.cursor.execute(query, (movie_name,))
            self.conn.commit()
            res = self.cursor.fetchall()
            if not res[0][0] == 0:
                continue

            print(movie_name)

            #插入
            query = 'INSERT INTO movie(movie_name) VALUES (%s)'
            self.cursor.execute(query, (movie_name,))
            self.conn.commit()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section&quot;&gt;2. 利用爬虫爬取豆瓣电影上的观影信息&lt;/h4&gt;

&lt;p&gt;依然是同样的套路，首先找到这些信息的入口，找到url:https://movie.douban.com/people/用户名/collect?sort=time&amp;amp;start=0&amp;amp;filter=all&amp;amp;mode=list&amp;amp;tags_sort=count，发现链接中不包含页码，所以考虑每次获取下一页的url加入待爬队列直到队列为空（其实就是广度优先搜索~~~），代码如下：&lt;/p&gt;

&lt;p&gt;```python
#从豆瓣上获取我的观影信息
def get_douban_infos(self, username):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;url_que = queue.Queue()
url_que.put('https://movie.douban.com/people/' + username + '/collect?sort=time&amp;amp;amp;start=0&amp;amp;amp;filter=all&amp;amp;amp;mode=list&amp;amp;amp;tags_sort=count')
while not url_que.empty():
    url = url_que.get()
    #爬取第一页
    html_doc = BeautifulSoup(self.get_html(url), 'html.parser')

    #获取下一页链接
    next_url = html_doc.select('#content &amp;gt; div.grid-16-8.clearfix &amp;gt; div.article &amp;gt; div.paginator &amp;gt; span.next &amp;gt; a')
    
    #如果有下一页则加入待爬队列
    if len(next_url) &amp;gt; 0:
        next_url = next_url[0]['href']
        url_que.put(next_url)

    html_doc = BeautifulSoup(self.get_html(url), 'html.parser')
    li_lists = html_doc.select('#content &amp;gt; div')[1].select('div.article &amp;gt; ul &amp;gt; li')

    for li in li_lists:

        a_label = li.select('div.item-show &amp;gt; div &amp;gt; a')[0]

        movie_name = a_label.getText().strip()
        movie_name = movie_name.split('/')[0].strip()

        #去重
        query = 'SELECT COUNT(*) FROM douban_movie WHERE movie_name = (%s)'
        self.cursor.execute(query, (movie_name,))
        self.conn.commit()
        res = self.cursor.fetchall()
        if not res[0][0] == 0:
            continue
        
        #电影类型等信息到详情页中获取更容易
        movie_detail_url = a_label['href']
        print(movie_detail_url)
        try:
            movie_info = self.get_movie_infos(movie_detail_url)
        except TypeError as e:
            print(str(e))
            print(movie_name)
            continue
        
        #利用正则表达式提取评分，注意有些电影未打评分的情况
        rate = li.select('div.item-show &amp;gt; div')[1].select('span')
        if len(rate) == 0:
            rate = ''
        else:
            rate = str(rate[0]['class'])
            regx = re.compile('(\d)')
            rate = regx.findall(rate)[0]

        watch_time = li.select('div.item-show &amp;gt; div')[1].getText().strip()

        comment = li.select('div.comment')
        #如果有评论
        if len(comment) &amp;gt; 0:
            comment = comment[0].getText().strip()
            if not comment.find('(1 有用)') == -1:
                comment = comment.split(' ')[0].strip()
        else:
            comment = ''

        print(movie_info)

        movie_types = movie_info['类型']
        movie_language = movie_info['语言']
        movie_country = movie_info['制片国家/地区']
        movie_director = movie_info['导演']

        print(comment)
        query = 'INSERT INTO douban_movie(movie_name, rate, watch_time, comment, movie_types, movie_language, movie_country, movie_director) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)'
        self.cursor.execute(query, (movie_name, rate, watch_time, comment, movie_types, movie_language, movie_country, movie_director))
        self.conn.commit()
return ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在从详情页获取信息的过程中，可以采用一些技巧方便我们提取出自己想要的信息（例如代码中把信息以dict的形式返回，方便解析），代码如下：&lt;/p&gt;

&lt;p&gt;```python
#从电影详情页获取电影类型，结果返回一个dict
def get_movie_infos(self, url):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;html_doc = BeautifulSoup(self.get_html(url), 'html.parser')
div_info = html_doc.select('#info')[0].getText().strip().split('\n')
res_info = {}
for div in div_info:
    div = div.split(': ')
    if div[0] == '导演':
        res_info.update({'导演' : ','.join(div[1:])})
    elif div[0] == '制片国家/地区':
        res_info.update({'制片国家/地区' : ','.join(div[1:])})
    elif div[0] == '语言':
        res_info.update({'语言' : ','.join(div[1:])})
    elif div[0] == '类型':
        res_info.update({'类型' : ','.join(div[1:])})
return res_info ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;doubanmoviesmovieleft-joinmovie&quot;&gt;3. 利用douban_movies表与movie表left join，并更新movie表出电影名以外的其他信息；&lt;/h4&gt;

&lt;p&gt;这一步操作就比较简单了，其实就是对数据表的操作，但是因为自己博客上电影命名不规范的原因，因此还要做一个匹配表来处理明明不规范的case；这里就不贴函数了。&lt;/p&gt;

&lt;h4 id=&quot;excel&quot;&gt;4. 通过相关模块包把数据库中的数据写入excel表中并生成图表；&lt;/h4&gt;

&lt;p&gt;现在我们已经获得了自己的观影数据并存入数据库中，后面要做的就是把数据统计信息写入excel表了，这里推荐&lt;a href=&quot;http://xlsxwriter.readthedocs.io/#&quot;&gt;xlsxwriter模块&lt;/a&gt;（PS：其实最开始就是想通过这个程序学习下xlsxwriter模块23333），&lt;a href=&quot;http://xlsxwriter.readthedocs.io/#&quot;&gt;xlsxwriter模块&lt;/a&gt;的主要功能是实现了python对excel表的操作。但是xlsxwriter的一个问题是不能读取excel的数据，往往需要结合pandas模块才能发挥最大作用。当然这里我们只需要写入功能，例如统计不同类型电影数目并制作柱状图的代码如下：&lt;/p&gt;

&lt;p&gt;```python
#将电影类型分类展示在柱状图中并统计数量
def show_types_in_column(self, workbook):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;worksheet = workbook.add_worksheet()

chart = workbook.add_chart({'type' : 'column'})

query = 'SELECT movie_name, movie_types FROM movie'
self.cursor.execute(query)
self.conn.commit()
movies_lists = self.cursor.fetchall()

movie_types_dict = {}

for movie in movies_lists:
    movie_name, movie_types = movie
    types = movie_types.split('/')
    for type in types:
        type = type.strip()
        if type in movie_types_dict:
            movie_types_dict[type] += 1
        else:
            movie_types_dict.update({type : 1})

# Add table data
table_data = [['类型', '片数'],]
for key, val in movie_types_dict.items():
    table_data.append([key, val])

type = '类型'
num = '数目'
worksheet.write_column('A1', type)
worksheet.write_column('B1', num)
worksheet.write_column('A2', movie_types_dict.keys())
worksheet.write_column('B2', movie_types_dict.values())

chart.add_series({'name' : '影片数目',
                  'categories' : ['Sheet1', 1, 0, 1+len(movie_types_dict.keys()), 0],
                  'values' : ['Sheet1', 1, 1, 1+len(movie_types_dict.values()), 1],
                  'color' : 'red',
                  'data_labels' : {'value' : True}})

#设置X轴属性
chart.set_x_axis({
    'name' : '影片类型',
    'name_font' : {'size' : 14, 'bold' : False},
    'num_font' : {'size' : 12},
    'line' : {'none' : True},
    'major_gridlines' : {
        'visible' : True,
        'line' : {'width' : 1.5, 'dash_type' : 'dash'}
    },
    'text_axis' : True
})

#设置长宽
chart.set_size({
    'x_scale' : 2.5,
    'y_scale' : 2
})

#设置标题
chart.set_title({
    'name' : '15/07/01 - 16/06/30 观影类型统计'
})

#设置属性块
chart.set_legend({
    'position' : 'left'
})

#图下方显示表格
chart.set_table({
    'show_keys' : True,
    'font' : {'size' : 12}
})

worksheet.insert_chart('C1', chart) ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-1&quot;&gt;5.将生成的图表转换为图片并保存；&lt;/h4&gt;

&lt;p&gt;这里把excel表中的chart转为图片通过VBA编程可以比较容易地实现，但是我们的目标是通过python来实现，经过搜索了解到可以使用windows的扩展包pywin32模块来实现这个功能，具体的代码源于网上的开源代码，其实难度倒是没有，主要难点在于api的使用。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;最后完整的代码在这里：&lt;a href=&quot;https://github.com/yinwoods/show_movies_info&quot;&gt;观影统计代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;另外，也开发了删减版，只需输入豆瓣用户名即可生成相应的观影统计信息（对这个功能感兴趣的朋友应该更多吧）。&lt;/p&gt;

&lt;p&gt;说说存在的问题，因为是调用了微软的excel中的VBA所以一定要在windows下跑并且确保安装了pywin32模块（安装比较麻烦），如果有朋友对代码功能改进兴趣的话可以email我讨论（yinwoods@163.com）&lt;/p&gt;

&lt;p&gt;按照赋比兴的老套路，我也得放点感想在这里才显得逼格高啊hhhhh。&lt;/p&gt;

&lt;p&gt;想一想豆瓣作为一个典型的文艺青年聚集地曾经社区那么活跃，如今已经衰落到“门前冷落鞍马稀”了，我想在互联网行业日新月异的今天，豆瓣几年来几乎一成不变，呈现出一种拒绝变化的姿态很难说不是衰落的一方面原因，拥有那么多数据为什么不多多服务人民群众，拥抱一下大数据呢？&lt;/p&gt;

&lt;p&gt;最近在YY买台云主机，把博客搭建到服务器上，以后造出来的一些轮子也可以服务大众了，比如把这个做成一个小轮子，方便电影爱好者对自己的观影数据有一个直观的认知。&lt;/p&gt;

</description>
          <pubDate>2016-07-07T00:00:00+08:00</pubDate>
          <link>/coding/python%E7%88%AC%E8%99%AB%E7%BB%9F%E8%AE%A1%E8%B1%86%E7%93%A3%E8%A7%82%E5%BD%B1%E8%AE%B0%E5%BD%95.html</link>
          <guid isPermaLink="true">/coding/python%E7%88%AC%E8%99%AB%E7%BB%9F%E8%AE%A1%E8%B1%86%E7%93%A3%E8%A7%82%E5%BD%B1%E8%AE%B0%E5%BD%95.html</guid>
        </item>
      
    
      
        <item>
          <title>python中的协程</title>
          <description>&lt;p&gt;要了解协程，首先要对子例程有所认知。&lt;/p&gt;

&lt;p&gt;子例程可以类比于程序中的函数调用，调用过程是后入先出的栈式调用；&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B&quot;&gt;协程-维基百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过下面的伪代码可以更好地理解协程：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;var q := new queue

生产者协程

   loop
       while q is not full
           create some new items
           add the items to q
       yield to consume
消费者协程

   loop
       while q is not empty
           remove some items from q
           use the items
       yield to produce&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在python中由于 &lt;em&gt;全局解释器锁（GIL）&lt;/em&gt; 的原因导致多线程难以发挥多核并行计算能力，因为GIL的原因，同一时刻只能有一个线程运行，更多情况下我们选用multiprocessing来实现多进程从而提高执行效率。而对于协程则更擅长处理I/O密集的程序。&lt;/p&gt;

&lt;p&gt;具体到python中协程，是以yield为基础实现的。&lt;/p&gt;

&lt;h4 id=&quot;pythonyield&quot;&gt;首先了解一下python中的yield:&lt;/h4&gt;

&lt;p&gt;可以通过stackoverflow上的一个帖子来了解python中的&lt;a href=&quot;http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python&quot;&gt;yield用法&lt;/a&gt;，简单地来说就是包含yield语句的函数被称为生成器函数，它与普通函数的区别就在于普通函数每次都要从函数入口处重新执行，而生成器函数仅第一次从入口处执行，之后都会从yield语句之后的地方开始执行。&lt;/p&gt;

&lt;p&gt;这么看好像很复杂，下面我们通过一个例子来认识yield。&lt;/p&gt;

&lt;p&gt;比如现在你想要写一个生成前n个斐波那契数，你可能很容易想到类似下面的这种写法：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def fib(n):
    index = 0
    a = 0
    b = 1
    res = []
    while index &amp;lt; n:
        index += 1
        a, b = b, a+b
        res.append(a)
    return res&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可是当n非常大时，上面这个程序把所有结果都保存在res中是很耗内存的，这时候就引出了yield。如果使用yield重写的话，函数是这样的：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def fib(n):
    index = 0
    a = 0
    b = 1
    while index &amp;lt; n:
        index += 1
        a, b = b, a+b
        yield a
        
for i in fib(20):
    print(i)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的fib因为包含了yield语句所以是生成器函数，当运行fib函数时，每次只取当前运算到的数，可以理解为每次运行到yield语句时，fib函数暂停，当下一次运行时，又会从暂停的位置继续运行。&lt;/p&gt;

&lt;p&gt;那么讲到这里，这和协程有什么关系呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;很容易想到如果能够从yield语句进入另一个函数并获取其返回值，不就是协程的实现吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里引入了send的用法，send的作用即是把另一个函数的返回值传递给当前函数（PS：这里说函数返回值是为了帮助理解，其实就是再次进入函数时能够获取外界传递进来的参数），示例代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def stupid_fib(n):
    index = 0
    a = 0
    b = 1
    while index &amp;lt; n:
        
        index += 1
        a, b = b, a+b
        #sleep_cnt 获取外界send的值
        sleep_cnt = yield a
        
        print('let me think {} secs'.format(sleep_cnt))
        time.sleep(sleep_cnt)

sfib = stupid_fib(20)
fib_res = next(sfib)
while True:
    print(fib_res)
    try:
        fib_res = sfib.send(random.uniform(0, 0.5))
    except StopIteration:
        break&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;目前为止，通过 yield 与 send 就实现了类似协程的机制。&lt;/p&gt;

&lt;p&gt;要进一步了解协程可以深入地学习一下asyncio.coroutine和yield from以及python3.5中引入的新机制async和await。&lt;/p&gt;

&lt;p&gt;另外本篇博文主要参考：&lt;a href=&quot;http://blog.guoyb.com/2016/07/03/python-coroutine/&quot;&gt;Python协程：从yield/send到async/await&lt;/a&gt;&lt;/p&gt;
</description>
          <pubDate>2016-07-07T00:00:00+08:00</pubDate>
          <link>/coding/python%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B.html</link>
          <guid isPermaLink="true">/coding/python%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B.html</guid>
        </item>
      
    
      
        <item>
          <title>python challenge前十三关答案</title>
          <description>&lt;p&gt;偶然间发现了一个很有趣的python练习网站&lt;a href=&quot;http://www.pythonchallenge.com/&quot;&gt;Python Challenge&lt;/a&gt;，具体每一关的玩法是根据提供的线索编程得到进入下一关的URL。游戏一共有33关，我玩了一下午，到第十三关发现逻辑性、趣味性已经弱了很多，也就不打算继续玩下去了，所以这里之给出前十三关答案。（PS：就个人来说，前面的一些关卡逻辑性比较强，自己多推理都可以解决，但后面真的是靠脑洞了，可能确实需要查看一些网上的提示才能过关。）&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;第0关&lt;/h3&gt;

&lt;p&gt;线索：&lt;code&gt;网页中间显示一张图片，图片上是一个显示器，显示2的38次方；图片下方是提示：尝试修改URL地址。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因此想到，把url最后的0换为2的38次方。&lt;/p&gt;

&lt;p&gt;具体代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import requests

id = 2**38
url = 'http://www.pythonchallenge.com/pc/def/' + str(id) + '.html'
print(url)

req = requests.get(url)
print(req.text)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;成功进入下一关&lt;a href=&quot;http://www.pythonchallenge.com/pc/def/274877906944.html&quot;&gt;http://www.pythonchallenge.com/pc/def/274877906944.html&lt;/a&gt;！&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;第1关&lt;/h3&gt;

&lt;p&gt;线索：&lt;code&gt;图片是一个笔记本，给出K-&amp;gt;M O-&amp;gt;Q E-&amp;gt;G；发现对应的字母ascii码相差2，图片下方给出一段紫色的完全不知道含义的英文。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以想到，对下面的这段英文解密，解密的关键就是每个字母的ascii循环加2。&lt;/p&gt;

&lt;p&gt;具体实现代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;str = &amp;quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. &amp;quot; \
      &amp;quot;bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. &amp;quot; \
      &amp;quot;sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.&amp;quot;

for char in str:
    if ord(char) &amp;lt;= 122 and ord(char) &amp;gt;= 97:
        asc = ord(char) + 2
        if asc &amp;gt; 122:
            asc -= 26
        print(chr(asc), end='')
    else:
        print(char, end='')
print()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行后得到输出：&lt;code&gt;i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that's why this text is so long. using string.maketrans() is recommended. now apply on the url.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查了下str.maketrans()发现用这个替换更方便，因此直接用如下方法实现：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;str = &amp;quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. &amp;quot; \
      &amp;quot;bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. &amp;quot; \
      &amp;quot;sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.&amp;quot;
print(str.translate(str.maketrans('abcdefghijklmnopqrstuvwxyz', 'cdefghijklmnopqrstuvwxyzab')))
#此时的url被重定向为map.html
print('map'.translate(str.maketrans('abcdefghijklmnopqrstuvwxyz', 'cdefghijklmnopqrstuvwxyzab')))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行后得到下一关入口：&lt;a href=&quot;http://www.pythonchallenge.com/pc/def/ocr.html&quot;&gt;http://www.pythonchallenge.com/pc/def/ocr.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;第2关&lt;/h3&gt;

&lt;p&gt;线索：&lt;code&gt;文字提示识别字符，字符可能在书中也可能在其他地方。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因为我直接用得request获取网页源码，所以看到了一堆注释的乱七八糟的符号，要做的其实就是提取出这些符号中的字符。&lt;/p&gt;

&lt;p&gt;实现代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import requests
req = requests.get('http://www.pythonchallenge.com/pc/def/ocr.html')
left = req.text.rfind('&amp;lt;!--')
right = req.text.rfind('--&amp;gt;')

str = req.text[left+4:right]
for chs in str:
    if chs.isalpha():
        print(chs, end='')&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行后输出eequality， 因此得到下一关入口：&lt;a href=&quot;http://www.pythonchallenge.com/pc/def/equality.html&quot;&gt;http://www.pythonchallenge.com/pc/def/equality.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;第3关&lt;/h3&gt;

&lt;p&gt;线索：&lt;code&gt;提示：每边都有且仅有3个大保镖的小字符。（莫名萌感）&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不得不说这里是个坑（也怪自己英语理解能力功力不够），我开始以为是找到九宫格中仅有中间一格内是小写字符的所有字符，结果找出了一堆乱七八糟的字符。囧&lt;/p&gt;

&lt;p&gt;看了答案才知道，提示里的EXACTLY着重在“3个”，而不是“每条边”，所以真正的含义是找到所有的恰好左侧和右侧都只有3个大写字符的小写字符。&lt;/p&gt;

&lt;p&gt;直到真实含义后自己又实现了下，后来发现用正则表达式一行就够了。。。看来自己的姿势还是不够多，不够pythonic。&lt;/p&gt;

&lt;p&gt;具体实现如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def judgeItem(mat, i, j):
    if i &amp;lt; 0 or j &amp;lt; 0:
        return -1
    if i &amp;gt;= len(mat) or j &amp;gt;= len(mat[i]):
        return -1
    char = mat[i][j]
    if char &amp;gt;= 'A' and char &amp;lt;= 'Z':
        return 1
    if char &amp;gt;= 'a' and char &amp;lt;= 'z':
        return 0
    return -1

def judge(mat, i, j):
    if mat[i][j] &amp;gt;= 'a' and mat[i][j] &amp;lt;= 'z':
        bodyGds = judgeItem(mat, i, j-3) + judgeItem(mat, i, j-2) + judgeItem(mat, i, j-1)
        bodyGds += judgeItem(mat, i, j+1) + judgeItem(mat, i, j+2) + judgeItem(mat, i, j+3)
        if bodyGds == 6 and judgeItem(mat, i, j-4) == 0 and judgeItem(mat, i, j+4) == 0:
            return True

import re
import requests
req = requests.get('http://www.pythonchallenge.com/pc/def/equality.html')
left = req.text.rfind('&amp;lt;!--')
right = req.text.rfind('--&amp;gt;')

str = req.text[left+4:right]

mat = []
for line in str.split('\n'):
    if not line == '':
        mat.append(line)

for i in range(len(mat)):
    for j in range(len(mat[i])):
        if judge(mat, i, j):
            print(mat[i][j], end='')

#以上为我的实现方式。。。。
#简洁的方法
print(''.join(re.findall(&amp;quot;[^A-Z]+[A-Z]{3}([a-z])[A-Z]{3}[^A-Z]&amp;quot;, str)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;anyway，得到了下一关的入口：&lt;a href=&quot;http://www.pythonchallenge.com/pc/def/linkedlist.html&quot;&gt;http://www.pythonchallenge.com/pc/def/linkedlist.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;第4关&lt;/h3&gt;

&lt;p&gt;线索：&lt;code&gt;打开后显示linkedlist.php，因此手动转入，发现页面标题是follow the chain， 另外图片是一个链接&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;感觉好像没什么线索，因为我还是用request获取源码，所以看到了额外的信息…&lt;/p&gt;

&lt;p&gt;’’’
&lt;!-- urllib may help. DON'T TRY ALL NOTHINGS, since it will never 
end. 400 times is more than enough. --&gt;
‘’’&lt;/p&gt;

&lt;p&gt;结合点击图片后进入的页面可以猜想这是一个超过400个节点的链，我们要做的其实就是用爬虫来走这个链，一直走到终点得到答案。&lt;/p&gt;

&lt;p&gt;实现代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import re
import requests

baseUrl = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing='
req = requests.get('http://www.pythonchallenge.com/pc/def/linkedlist.php')
res = re.findall('(\d+)', req.text)

req = requests.get(baseUrl + res[1])
print(baseUrl+res[1], req.text)
res = re.findall('(\d+)', req.text)

#while True:
#    req = requests.get(baseUrl + res[0])
#    print(baseUrl+res[0], req.text)
#    res = re.findall('(\d+)', req.text)
#    if res == '':
#        break
#    print(res)

#运行之后中间会断一次，需要除以2之后再跑
#http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=16044 Yes. Divide by two and keep going.

#后期还会给出两个nothing的例子，这个加一个判断就好，如果出现两个就取第二个

res.clear()
res.append(str(16044/2))
while True:
    if len(res) == 2:
        url = baseUrl + res[1]
    else:
        url = baseUrl + res[0]
    req = requests.get(url)
    print(url, req.text)
    res = re.findall('(\d+)', req.text)
    if len(res) == 0:
        break&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终得到peak.html&lt;/p&gt;

&lt;p&gt;因此得到下一关入口：&lt;a href=&quot;http://www.pythonchallenge.com/pc/def/peak.html&quot;&gt;http://www.pythonchallenge.com/pc/def/peak.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;第5关&lt;/h3&gt;

&lt;p&gt;这一关就是阅读理解了。。。&lt;/p&gt;

&lt;p&gt;线索：&lt;code&gt;进入后发现有张图片，命名为peakhell.jpg，下面提示pronounce it，另外页面源码可以发现一个peakhell标签，指向banner.p链接，并提示peak hell听起来熟悉吗？&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这道题我是没想出来，google之后发现是进入banner.p链接后，根据python的pickle模块来处理。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import pickle
import  requests
import urllib.request
req = requests.get('http://www.pythonchallenge.com/pc/def/peak.html')
print(req.text) #得到banner.p
req = urllib.request.urlopen('http://www.pythonchallenge.com/pc/def/banner.p')
req = pickle.loads(req.read())
for line in req:
    print(''.join(elmt[0] * elmt[1] for elmt in line))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得到下一关的入口：&lt;a href=&quot;http://www.pythonchallenge.com/pc/def/channel.html&quot;&gt;http://www.pythonchallenge.com/pc/def/channel.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;第6关&lt;/h3&gt;

&lt;p&gt;线索：&lt;code&gt;页面内可用信息极其少，下方的捐款信息毫无疑问不能算是线索，只有一个注释zip&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;根据zip可知这关可能需要解压模块zip，可是解压什么呢？尝试进入zip.html会得到一条信息：yes. find the zip。那么说明这个思路是对的，从而想到把channel.html换成channel.zip会下载到这个文件。解压后发现里面有个README文件，又是nothing…下面就是和第4关类似的操作了，不同的是第4关是网页，这次是文件。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import re
import zipfile
import requests

req = requests.get('http://www.pythonchallenge.com/pc/def/channel.html')
print(req.text)#http://www.pythonchallenge.com/pc/def/channel.zip 下载
zpfile = zipfile.ZipFile(&amp;quot;channel.zip&amp;quot;)

id = 90052#源自README
res = []

while True:
    try:
        id = re.search('(\d+)', str(zpfile.read(str(id) + '.txt'))).group(1)
    except:
        print(zpfile.read(str(id) + '.txt'))
        break
    print(id)
    res.append(zpfile.getinfo(str(id) + '.txt').comment.decode('utf-8'))

print(''.join(res))#HOCKEY

req = requests.get('http://www.pythonchallenge.com/pc/def/hockey.html')

#提示结果是空气的成分，观察HOCKEY的组成，发现是oxygen
print(req.text)#OXYGEY&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得到下一关的入口：&lt;a href=&quot;http://www.pythonchallenge.com/pc/def/oxygen.html&quot;&gt;http://www.pythonchallenge.com/pc/def/oxygen.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;第7关&lt;/h3&gt;

&lt;p&gt;线索：&lt;code&gt;页面仅有一张打码的图片&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;自己想不出来，在网上看到说是对图片的打码部分按ascii解码。。。不明觉厉。（PS：从这里开始，感觉逻辑性就弱了很多）&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import PIL.Image
import urllib.request
#req = requests.get('http://www.pythonchallenge.com/pc/def/oxygen.html')
#print(req.text)
img = PIL.Image.open(urllib.request.urlopen('http://www.pythonchallenge.com/pc/def/oxygen.png'))
row = [chr(img.getpixel((x, 45))[0]) for x in range(0, 609, 7)]
print(''.join(row))
row = [chr(x) for x in [105, 110, 116, 101, 103, 114, 105, 116, 121]]
print(''.join(row))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得到单词integrity，从而得到下一关入口：&lt;a href=&quot;http://www.pythonchallenge.com/pc/def/integrity.html&quot;&gt;http://www.pythonchallenge.com/pc/def/integrity.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;第8关&lt;/h3&gt;

&lt;p&gt;线索：&lt;code&gt;进入后发现图片中的蜜蜂是一个链接，另外页面源码中包含un和pw两个字符串&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;点击链接后提示输入用户名、密码，结合un、pw可以猜想这二者对应username,password。&lt;/p&gt;

&lt;p&gt;看答案知道是用bz2解密。。。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import bz2
import requests
req = requests.get('http://www.pythonchallenge.com/pc/def/integrity.html')
print(req.text)
print(bz2.decompress(b'BZh91AY&amp;amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&amp;lt;]\xc9\x14\xe1BA\x06\xbe\x084'))
print(bz2.decompress(b'BZh91AY&amp;amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&amp;lt;]\xc9\x14\xe1BBP\x91\xf08'))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得到用户名：huge 密码：file&lt;/p&gt;

&lt;p&gt;点击链接输入后得到下一关入口：&lt;a href=&quot;http://www.pythonchallenge.com/pc/return/good.html&quot;&gt;http://www.pythonchallenge.com/pc/return/good.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;第9关&lt;/h3&gt;

&lt;p&gt;线索：&lt;code&gt;标题为connect the dots， 页面图片中也包含了很多黑点；另外源码中给出first second， 并问first + second = ?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;结合first second中数值特点可以猜想是坐标集，下面索要做的就是分别把first和second中的坐标连接起来。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;from PIL import Image
from PIL import ImageDraw

img = Image.open('good.jpg')
draw = ImageDraw.Draw(img)

first = [ 146,399,163,403,170,393,169,391,166,386,170,381,170,371,170,355,169,346,167,335,170,329,170,320,170,
310,171,301,173,290,178,289,182,287,188,286,190,286,192,291,194,296,195,305,194,307,191,312,190,316,
190,321,192,331,193,338,196,341,197,346,199,352,198,360,197,366,197,373,196,380,197,383,196,387,192,
389,191,392,190,396,189,400,194,401,201,402,208,403,213,402,216,401,219,397,219,393,216,390,215,385,
215,379,213,373,213,365,212,360,210,353,210,347,212,338,213,329,214,319,215,311,215,306,216,296,218,
290,221,283,225,282,233,284,238,287,243,290,250,291,255,294,261,293,265,291,271,291,273,289,278,287,
279,285,281,280,284,278,284,276,287,277,289,283,291,286,294,291,296,295,299,300,301,304,304,320,305,
327,306,332,307,341,306,349,303,354,301,364,301,371,297,375,292,384,291,386,302,393,324,391,333,387,
328,375,329,367,329,353,330,341,331,328,336,319,338,310,341,304,341,285,341,278,343,269,344,262,346,
259,346,251,349,259,349,264,349,273,349,280,349,288,349,295,349,298,354,293,356,286,354,279,352,268,
352,257,351,249,350,234,351,211,352,197,354,185,353,171,351,154,348,147,342,137,339,132,330,122,327,
120,314,116,304,117,293,118,284,118,281,122,275,128,265,129,257,131,244,133,239,134,228,136,221,137,
214,138,209,135,201,132,192,130,184,131,175,129,170,131,159,134,157,134,160,130,170,125,176,114,176,
102,173,103,172,108,171,111,163,115,156,116,149,117,142,116,136,115,129,115,124,115,120,115,115,117,
113,120,109,122,102,122,100,121,95,121,89,115,87,110,82,109,84,118,89,123,93,129,100,130,108,132,110,
133,110,136,107,138,105,140,95,138,86,141,79,149,77,155,81,162,90,165,97,167,99,171,109,171,107,161,
111,156,113,170,115,185,118,208,117,223,121,239,128,251,133,259,136,266,139,276,143,290,148,310,151,
332,155,348,156,353,153,366,149,379,147,394,146,399]
second = [156,141,165,135,169,131,176,130,187,134,191,140,191,146,186,150,179,155,175,157,168,157,163,157,159,
157,158,164,159,175,159,181,157,191,154,197,153,205,153,210,152,212,147,215,146,218,143,220,132,220,
125,217,119,209,116,196,115,185,114,172,114,167,112,161,109,165,107,170,99,171,97,167,89,164,81,162,
77,155,81,148,87,140,96,138,105,141,110,136,111,126,113,129,118,117,128,114,137,115,146,114,155,115,
158,121,157,128,156,134,157,136,156,136]

draw.line(first, fill='#0000FF')
draw.line(second, fill='#FF0000')
img.show()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;连线的结果是一头牛，我想到的关键词是cow，输入后404，看答案说是bull(公牛)。。。&lt;/p&gt;

&lt;p&gt;anyway，下一关的入口是：&lt;a href=&quot;http://www.pythonchallenge.com/pc/return/bull.html&quot;&gt;http://www.pythonchallenge.com/pc/return/bull.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;第10关&lt;/h3&gt;

&lt;p&gt;线索：&lt;code&gt;图片中牛是一条链接，点击后显示a = [1, 11, 21, 1211, 111221, 另外网页中图片下方提问len(a[30])=?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以想到是根据线索推算出a[30]，并计算a[30]的长度；可能是以前接触过，所以我一下就看出a的规律了，1-&amp;gt;11是一个1的意思，…，1211-&amp;gt;111221是一个1，一个2，两个1的意思。&lt;/p&gt;

&lt;p&gt;因此写出以下代码推算a[30]：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def compute(num):
    res = []
    pre = str(num)[0]
    cnt = 1
    for val in str(num)[1:]:
        if val == pre:
            cnt += 1
        else:
            res.append(str(cnt))
            res.append(str(pre))
            cnt = 1
        pre = val
    res.append(str(cnt))
    res.append(str(pre))
    #print(''.join(res))
    return ''.join(res)

a = []
a.append(1)
while len(a) &amp;lt; 32:
    a.append(compute(a[-1]))
print(len(a[30]))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得到结果5808，从而得到下一关入口：&lt;a href=&quot;http://www.pythonchallenge.com/pc/return/5808.html&quot;&gt;http://www.pythonchallenge.com/pc/return/5808.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;第11关&lt;/h3&gt;

&lt;p&gt;线索：&lt;code&gt;一张模糊的图片，标题提示odd or even&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;完全没有思路，看了别人答案说是根据奇偶坐标生成一个新图…orz&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;from PIL import Image
img = Image.open('cave.jpg')
img_value = img.load()
width, height = img.size
new_img = Image.new('RGB', (int(width/2), int(height/2)))

new_img_value = new_img.load()
for i in range(int(width/2)):
    for j in range(int(height/2)):
    	#下面两条语句执行效果是一样的
        new_img_value[i, j] = img_value[2*i, 2*j]
        #new_img_value[i, j] = img_value[2*i+1, 2*j+1]

new_img.show()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;隐约可以看到图片上显示evil,所以得到下一关入口：&lt;a href=&quot;http://www.pythonchallenge.com/pc/return/evil.html&quot;&gt;http://www.pythonchallenge.com/pc/return/evil.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;第12关&lt;/h3&gt;

&lt;p&gt;线索：&lt;code&gt;只有一张图片&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;没有任何线索，玩到这里感觉逻辑性已经很弱了，答案解释的理由也很牵强，直接给出参考的答案链接把&lt;a href=&quot;http://www.cnblogs.com/dukeleo/p/3467947.html&quot;&gt;Python Challenge 第十二关 From 博客园&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;照例贴一下代码：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;img = open('evil2.gfx', 'rb')
content = img.read()
img.close()

for i in range(5):
    img = open('%d.jpg' % i, 'wb')
    img.write(content[i::5])
    img.close()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据5张图片上的字符组合成一个单词disproportional，得到下一关入口：&lt;a href=&quot;http://www.pythonchallenge.com/pc/return/disproportional.html&quot;&gt;http://www.pythonchallenge.com/pc/return/disproportional.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;结语&lt;/h3&gt;

&lt;p&gt;我就玩到这里了，因为到这里已经没有什么趣味性可言了，更多的是一种任务性在驱动，感觉无趣，就没有再玩下去了，如果有兴趣的朋友可以尝试继续挑战！&lt;/p&gt;
</description>
          <pubDate>2016-05-31T00:00:00+08:00</pubDate>
          <link>/coding/python-challenge%E5%89%8D%E5%8D%81%E4%B8%89%E5%85%B3%E7%AD%94%E6%A1%88.html</link>
          <guid isPermaLink="true">/coding/python-challenge%E5%89%8D%E5%8D%81%E4%B8%89%E5%85%B3%E7%AD%94%E6%A1%88.html</guid>
        </item>
      
    
      
        <item>
          <title>python实现中英文字幕合并</title>
          <description>&lt;h3 id=&quot;section&quot;&gt;背景&lt;/h3&gt;

&lt;p&gt;看了看上一篇文章是4月5号写的，离开学校了产能下降好多…&lt;/p&gt;

&lt;p&gt;说来中英文字幕合并是我上上周就想干的事了，说下写这个程序的动机：本人比较喜欢看电影，一般电影从&lt;a href=&quot;http://www.bttiantang.com/&quot;&gt;BT天堂&lt;/a&gt;下载，很多时候电影没有内嵌字幕，就去&lt;a href=&quot;http://assrt.net/&quot;&gt;伪射手&lt;/a&gt;下载，但对于有的电影伪射手上没有同时包含中英文的字幕，这个时候当然可以再去别的网站找字幕，或者通过播放器同时添加字幕、次字幕来满足需求。但我要用平板看电影，是用的nplayer播放器不支持添加两个字幕，而且觉得这种实际需求驱动的程序写起来也比较有意思，就借这个周六下午来实现了相应的代码。、&lt;/p&gt;

&lt;p&gt;下午想看的电影是&lt;a href=&quot;https://movie.douban.com/subject/1397546/&quot;&gt;追随&lt;/a&gt;，去伪射手上搜，搜到的都是杀手信徒。。。囧，之后以豆瓣 + 追随的关键字才找到了相应的中文和英文字幕，根据下面截图中两个字幕的命名规则可以猜出应该是出自同一个字幕组，真想问问为什么不做个中英文合并版？（来自一个强迫症晚期患者的内心独白）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post46-001.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;正文&lt;/h3&gt;

&lt;p&gt;废话少叙，先说下处理的思路，打开两个字幕文件可以发现每一段字幕组成具有如下规则：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;行号（注意中英文序号不完全对应）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;时间段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;字幕内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此要做的其实就是匹配中文字幕和英文字母中对应时间下的字幕内容，出于算法高效上的考虑，不考虑两层循环暴力，因为完全可以靠O(max(m, n))的算法实现，下面附第一版的合并代码：&lt;/p&gt;

&lt;h4 id=&quot;version-01&quot;&gt;Version 0.1&lt;/h4&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def first():
    feng = open('eng.srt', 'r', encoding='utf-8')
    fchs = open('chs.srt', 'r', encoding='gbk')
    fmeg = open('merge.srt', 'a', encoding='utf-8')

    engline = feng.readline()
    chsline = fchs.readline()

    engCurRow = chsCurRow = 0

    #一行一行地读取字幕内容
    while not engline == '' and not chsline == '':
    	#获取相应的时间片
        if not engline.find('--&amp;gt;') == -1:
            engCurRow = engline.strip()
        if not chsline.find('--&amp;gt;') == -1:
            chsCurRow = chsline.strip()

        #如果当前英文字母时间片早，说明还需要接着读英文字幕内容，反之读取中文字幕内容
        if engCurRow &amp;lt; chsCurRow:
            engline = feng.readline()
        if engCurRow &amp;gt; chsCurRow:
            chsline = fchs.readline()

        #如果中文字幕、英文字母时间片匹配
        if engCurRow == chsCurRow:
        	#如果当前行是时间片或者相同的行号，只输出一个
            if engline == chsline:
                fmeg.write(engline.strip(), end='\n')
            else:
            	#如果二者均为行号，取较大者
                if engline.strip().isdigit() and chsline.strip().isdigit():
                    fmeg.write(str(max(int(engline.strip()), int(chsline.strip()))))
                else:
                    fmeg.write(engline.strip() + chsline.strip() + '\n' + '\n')
            engline = feng.readline()
            chsline = fchs.readline()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的这份代码能够简单实现字幕合并，但是有一些特例无法处理，例如两行英文可能对应一行中文，一个时间片下展示的是对话字幕（包含多行），这就驱动了第二版的产生&lt;/p&gt;

&lt;h4 id=&quot;version-02&quot;&gt;Version 0.2&lt;/h4&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def second():
	#提取字幕文件特征，以'\n\n'分割字幕内容，获取每个时间片
	with open('eng.srt', 'r', encoding='utf-8') as feng:
        fengList = feng.read().split('\n\n')
    with open('chs.srt', 'r', encoding='gbk') as fchs:
        fchsList = fchs.read().split('\n\n')

    #可以设置自己喜欢的字幕字体、颜色等等
    fontStyle = '&amp;lt;font color=#FFFFFF&amp;gt;{\fn微软雅黑}'

    #保存合并后的字幕文件
    merge = open('merge.srt', 'a', encoding='utf-8')

    #英文和中文字幕时间片下标
    fengIdx = fchsIdx = 0

    while not fengList[fengIdx] == '' and not fchsList[fchsIdx] == '':
        engList = fengList[fengIdx].split('\n')
        chsList = fchsList[fchsIdx].split('\n')

        #提取行号，时间片以及字幕内容
        #自我觉得这里的join用得比较巧妙
        (engline, engtime, engval) = (int(engList[0]), engList[1].strip(), ' '.join(engList[2:]))
        (chsline, chstime, chsval) = (int(chsList[0]), chsList[1].strip(), ' '.join(chsList[2:]))

        #如果时间片相等
        if engtime == chstime:
        	#写入较大者的行号
            merge.write(str(max(engline, chsline)))
            merge.write('\n')

            #val保存一个时间片下合并后的字幕内容
            val = ''

            #处理对话情况，对话字符串都以'- '开始
            if chsval.startswith('-'):
                engval = '\n-'.join(engval.split('- '))
                chsval = '\n-'.join(chsval.split('- '))

                #按行合并中英文字幕
                for line in range(len(engval.split('\n'))):
                    val += engval.split('\n')[line]
                    val += '\n'
                    val += chsval.split('\n')[line]
                    val += '\n'
            else:
                val = engval + '\n' + chsval + '\n'

            merge.write(engtime + '\n')
            merge.write(fontStyle + val + '\n')

            fengIdx += 1
            fchsIdx += 1

        #处理包含多余内容的情况
        if engtime &amp;lt; chstime:
            merge.write(str(max(engline, chsline)))
            merge.write('\n')
            merge.write(engtime + '\n')
            merge.write(fontStyle + engval + '\n')
            fengIdx += 1
        if engtime &amp;gt; chstime:
            merge.write(str(max(engline, chsline)))
            merge.write('\n')
            merge.write(chstime + '\n')
            merge.write(fontStyle + chsval + '\n')
            fchsIdx += 1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就实现了中英文字幕合并的需求，当然这里处理的情况不能推广到所有情况，但是合并思路是一样的，对于其他需求合并的文件可以参考这个思路来实现。&lt;/p&gt;

&lt;p&gt;PS：马上就要回学校答辩了，想在回去的时候利用闲暇的时间多写一些有趣的脚本，争取高质量高产出。。。&lt;/p&gt;
</description>
          <pubDate>2016-05-21T00:00:00+08:00</pubDate>
          <link>/coding/python%E5%AE%9E%E7%8E%B0%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AD%97%E5%B9%95%E5%90%88%E5%B9%B6.html</link>
          <guid isPermaLink="true">/coding/python%E5%AE%9E%E7%8E%B0%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AD%97%E5%B9%95%E5%90%88%E5%B9%B6.html</guid>
        </item>
      
    
      
        <item>
          <title>python爬虫小技巧总结</title>
          <description>&lt;p&gt;之前在&lt;a href=&quot;http://www.codeceo.com/article/python-spider-skills.html&quot;&gt;码农网&lt;/a&gt;看过python的爬虫小技巧，但是我认为总结地不够全面，而且在这段编写爬虫的过程中，也形成了自己的套路～&lt;/p&gt;

&lt;p&gt;特意在这里分享给大家，当然一方面也是以后忘记了留作参考。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;1、基本网页抓取&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;包含伪装浏览器访问（解决403错误）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;使用代理，避免长时间爬取被封本机IP&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;处理网页gzip压缩&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;HTTPError异常处理&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#获取url 对应 HTML 源码
def getHtml(url):
	#伪装浏览器
    header = dict({ 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/48.0.2564.116 Chrome/48.0.2564.116 Safari/537.36',
                    'Accept-encoding': 'gzip',
                    })
    request = urllib.request.Request(url, headers=header)

    
    try: 
    	#使用代理：117.135.252.227:80
        proxy_support = urllib.request.ProxyHandler({'http': '117.135.252.227:80'})
        opener = urllib.request.build_opener(proxy_support)
        urllib.request.install_opener(opener)

        page = urllib.request.urlopen(request)

        #print(page.headers.get('Content-Encoding')) 'gzip'
        #print(page.headers.get_content_charset()) 'utf8'

        #如果使用了gzip压缩
        if page.headers.get('Content-Encoding') == 'gzip':
            return zlib.decompress(page.read(), 16+zlib.MAX_WBITS).decode('utf8')
        else: 
            return page.read().decode(page.headers.get_content_charset())

    except urllib.request.HTTPError as e:
        print('HTTPERROR: ', str(e))
    return urllib.request.HTTPError&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;mysql&quot;&gt;2、Mysql数据库操作&lt;/h3&gt;

&lt;p&gt;一般在类的构造函数__init__中完成数据库的连接，在析构函数中断开连接。&lt;/p&gt;

&lt;p&gt;示例如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import mysql.connector

class Example():
	#构造函数
	def __init__(self):
		self.conn = mysql.connector.connect(user='root', password='root', host='localhost', database='test')
		self.cursor = self.conn.cursor(buffered=True)

	#析构函数
	def __del__(self):
		self.cursor.close()
		self.conn.close()

	#数据库操作
	#查询table表中id=1的数据个数
	def doSomething(self):
		query = 'SELECT COUNT(*) FROM table WHERE id = %s'
		data = (1, )

		#执行查询
		self.cursor.excute(query, data)
		#确保查询提交
		self.conn.commit()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;json&quot;&gt;3、把json格式数据插入表中&lt;/h3&gt;

&lt;p&gt;首先使用toJson()函数把我们要插入的数据项转为json格式，再使用jsonINTOMysql()函数将json格式数据插入mysql中。&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def toJson(**kwargs):
	return kwargs

#把json格式的rowdict插入table中
def jsonINToMysql(table, rowdict):
    self.cursor.execute('DESCRIBE %s' % table)
    allowedKeys = set(row[0] for row in self.cursor.fetchall())

    keys = allowedKeys.intersection(rowdict)

    if len(rowdict) &amp;gt; len(keys):
        unknownKeys = set(rowdict)-allowedKeys
        print(sys.stderr, &amp;quot;skipping keys&amp;quot;, &amp;quot;,&amp;quot;.join(unknownKeys))

    columns = &amp;quot;,&amp;quot;.join(keys)
    values_template = &amp;quot;, &amp;quot;.join([&amp;quot;%s&amp;quot;]*len(keys))

    sql = &amp;quot;INSERT INTO %s(%s) VALUES (%s)&amp;quot; % (table, columns, values_template)

    values = tuple(rowdict[key] for key in keys)
    self.cursor.execute(sql, values)
    self.conn.commit()

def example():
	#假设数据表table中有id、name、sex三项
	json = toJson(id=id, name=name, sex=sex)
	jsonINTOMysql('table', json)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;4、对爬取数据的乱码进行解析&lt;/h3&gt;

&lt;p&gt;有时我们需要爬取的是单独的json格式数据(请参考&lt;a href=&quot;http://blog.yinwoods.com/coding/%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96js%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE.html&quot;&gt;利用爬虫爬取js生成数据&lt;/a&gt;)，可能会发现json中的数据是经过编码的，例如我爬取汽车之家车辆的详细参数配置时，会发现json中的数据为：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
{&quot;SIP_C_119&quot;:&quot;2645&quot;,&quot;SIP_C_250&quot;:&quot;%2d&quot;,&quot;SIP_C_306&quot;:&quot;%2d&quot;,&quot;SIP_T_LOGO&quot;:&quot;http://i1.itc.cn/20130624/83e_01580269_5a5f_1526_74cc_c6bf0064c28e_1.jpg&quot;,&quot;SIP_C_114&quot;:&quot;%2d%2d%2d&quot;,&quot;SIP_C_117&quot;:&quot;7005&quot;,&quot;SIP_C_305&quot;:&quot;%2d&quot;,&quot;SIP_C_304&quot;:&quot;%2d%2d%2d&quot;,&quot;SIP_C_118&quot;:&quot;2040&quot;,&quot;SIP_C_303&quot;:&quot;%u67f4%u6cb9%u673a&quot;,&quot;SIP_C_115&quot;:&quot;%u6574%u8f663%u5e74%2f6%u4e07%u516c%u91cc&quot;,&quot;SIP_C_116&quot;:&quot;%2d%2d%2d&quot;,&quot;model_engine_type&quot;:2,&quot;SIP_C_120&quot;:&quot;3935&quot;,&quot;overseas&quot;:false,&quot;SIP_T_PRICE&quot;:32.0,&quot;SIP_C_261&quot;:&quot;%u25cf&quot;,&quot;SIP_T_ID&quot;:127870,&quot;SIP_T_GEAR&quot;:&quot;M&quot;,&quot;SIP_C_124&quot;:&quot;%u5ba2%u8f66&quot;,&quot;SIP_C_125&quot;:&quot;2&quot;,&quot;SIP_C_126&quot;:&quot;10%2d23&quot;,&quot;SIP_C_127&quot;:&quot;90&quot;,&quot;SIP_C_170&quot;:&quot;%2d&quot;,&quot;SIP_C_329&quot;:&quot;120&quot;,&quot;SIP_C_171&quot;:&quot;%u673a%u68b0%u6db2%u538b%u52a9%u529b%u8f6c%u5411&quot;,&quot;SIP_C_322&quot;:&quot;%2d&quot;,&quot;SIP_T_MODELNAME&quot;:&quot;%u5b89%u51ef%u5ba2%u8f66%20%u5b9d%u65af%u901a&quot;,&quot;SIP_C_321&quot;:&quot;%2d&quot;,&quot;SIP_C_320&quot;:&quot;%u624b%u52a8&quot;,&quot;SIP_C_185&quot;:&quot;%u25cf&quot;,&quot;SIP_C_283&quot;:&quot;%u25cf&quot;,&quot;SIP_C_318&quot;:&quot;%u5364%u7d20&quot;,&quot;SIP_C_108&quot;:&quot;5%u6863%u624b%u52a8&quot;,&quot;SIP_C_317&quot;:&quot;%2d&quot;,&quot;SIP_C_285&quot;:&quot;%u25cf&quot;,&quot;SIP_C_314&quot;:&quot;%2d&quot;,&quot;SIP_C_104&quot;:&quot;%u6c5f%u6dee%u6c7d%u8f66&quot;,&quot;SIP_C_313&quot;:&quot;%2d&quot;,&quot;SIP_C_105&quot;:&quot;%u5176%u4ed6%u8f66%u578b&quot;,&quot;SIP_C_316&quot;:&quot;%2d&quot;,&quot;SIP_C_106&quot;:&quot;2%u95e810%2d23%u5ea7%u5ba2%u8f66&quot;,&quot;SIP_C_315&quot;:&quot;%2d&quot;,&quot;SIP_C_107&quot;:&quot;3%2e0T%20163%u9a6c%u529bL4&quot;,&quot;SIP_C_310&quot;:&quot;%2d&quot;,&quot;SIP_C_312&quot;:&quot;%2d&quot;,&quot;SIP_C_102&quot;:&quot;32%2e0%u4e07%u5143&quot;,&quot;SIP_C_103&quot;:&quot;32%2e0%7e32%2e0%u4e07%u5143&quot;,&quot;SIP_C_150&quot;:&quot;%u7f38%u5185%u76f4%u55b7&quot;,&quot;SIP_C_294&quot;:&quot;%2d%2d%2f%2d%2d%2f%2d%2d&quot;,&quot;SIP_C_297&quot;:&quot;163&quot;,&quot;SIP_C_291&quot;:&quot;%2d%2d%2d&quot;,&quot;SIP_C_151&quot;:&quot;%u94dd%u5408%u91d1&quot;,&quot;SIP_C_293&quot;:&quot;7005x2040x2645&quot;,&quot;SIP_C_152&quot;:&quot;%u94f8%u94c1&quot;,&quot;SIP_C_292&quot;:&quot;%2d%2d%2d&quot;,&quot;SIP_T_DISPL&quot;:3.0,&quot;SIP_C_158&quot;:&quot;%u624b%u52a8&quot;,&quot;SIP_C_157&quot;:&quot;5&quot;,&quot;SIP_C_156&quot;:&quot;5%u6863%u624b%u52a8&quot;,&quot;SIP_C_155&quot;:&quot;%u56fdIV&quot;,&quot;SIP_C_298&quot;:&quot;120%2f3800&quot;,&quot;SIP_C_299&quot;:&quot;362%2f1600%2d2200&quot;,&quot;SIP_C_159&quot;:&quot;%u4e2d%u7f6e%u540e%u9a71&quot;,&quot;SIP_C_224&quot;:&quot;%u771f%u76ae&quot;,&quot;SIP_C_160&quot;:&quot;%u9ea6%u5f17%u900a%u5f0f%u72ec%u7acb%u60ac%u6302&quot;,&quot;SIP_C_161&quot;:&quot;%u94a2%u677f%u5f39%u7c27%u7ed3%u6784&quot;,&quot;SIP_C_162&quot;:&quot;%u627f%u8f7d%u5f0f%u8f66%u8eab&quot;,&quot;SIP_C_163&quot;:&quot;7%2e00%20R16&quot;,&quot;SIP_C_164&quot;:&quot;7%2e00%20R16&quot;,&quot;SIP_C_165&quot;:&quot;%u94a2%u5236&quot;,&quot;nameDomain&quot;:&quot;4094&quot;,&quot;SIP_C_167&quot;:&quot;%u901a%u98ce%u76d8%u5f0f&quot;,&quot;SIP_C_166&quot;:&quot;%u5168%u5c3a%u5bf8%u5907%u80ce&quot;,&quot;SIP_C_169&quot;:&quot;%u624b%u5239%u5f0f%u5236%u52a8&quot;,&quot;SIP_C_168&quot;:&quot;%u9f13%u5f0f&quot;,&quot;SIP_T_MODELID&quot;:4094,&quot;SIP_T_STA&quot;:1,&quot;SIP_C_335&quot;:&quot;6%u4e07&quot;,&quot;SIP_C_333&quot;:&quot;1600&quot;,&quot;SIP_C_334&quot;:&quot;2200&quot;,&quot;SIP_C_332&quot;:&quot;362&quot;,&quot;SIP_T_YEAR&quot;:2014,&quot;SIP_C_330&quot;:&quot;3800&quot;,&quot;SIP_C_139&quot;:&quot;4&quot;,&quot;SIP_C_138&quot;:&quot;%u6da1%u8f6e%u589e%u538b&quot;,&quot;SIP_C_137&quot;:&quot;2968&quot;,&quot;SIP_C_136&quot;:&quot;3%2e0&quot;,&quot;SIP_C_135&quot;:&quot;NGD3%2e0%2dC3HA&quot;,&quot;SIP_C_134&quot;:&quot;3%2e0T%20163%u9a6c%u529bL4&quot;,&quot;SIP_C_249&quot;:&quot;0&quot;,&quot;SIP_C_140&quot;:&quot;%u76f4%u5217&quot;,&quot;SIP_C_141&quot;:&quot;4&quot;,&quot;SIP_C_347&quot;:&quot;%u5364%u7d20&quot;,&quot;SIP_C_142&quot;:&quot;%u53cc%u9876%u7f6e&quot;,&quot;brandNameDomain&quot;:&quot;ak-2171&quot;,&quot;SIP_C_149&quot;:&quot;%u67f4%u6cb9&quot;,&quot;SIP_C_148&quot;:&quot;40%2e0&quot;,&quot;SIP_T_NAME&quot;:&quot;3%2e0T%20VIP%u7248&quot;,&quot;SIP_C_241&quot;:&quot;%u25cf&quot;}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这种编码相信大家看着很熟悉，就像我们把包含中文的url地址复制粘贴下来的结果，那么我们该怎么对这种数据进行解码呢？&lt;/p&gt;

&lt;p&gt;使用这种方式：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#对str先进行unquote url解码，再进行eval unicode解码
#处理数据时只需要我们把key-value对中的value依次作为参数传给deUnicode即可
def deUnicode(str):
    try:
        ans = eval('&amp;quot;%s&amp;quot;' % unquote(str).replace('%', '\\'))
        return ans
    except SyntaxError as e:
        return str&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;requestspost&quot;&gt;5、requests通过post提交表单数据（一般用于模拟登录）&lt;/h3&gt;

&lt;p&gt;requests的post实现依赖于维持一个session，也就是说在session存在期间，我们可以以登录的身份来获取其他需要登录后才能获取的页面源码。&lt;/p&gt;

&lt;p&gt;简单使用如下：&lt;/p&gt;

&lt;p&gt;```python&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;url = ''
datas = urllib.parse.urlencode({
   'data-key' : 'data-value'
})

headers = dict({
    'header-key' : 'header-value'
})

session = requests.session()
session.post(url, datas, headers=headers)

res = session.get(other url).text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;
</description>
          <pubDate>2016-04-05T00:00:00+08:00</pubDate>
          <link>/coding/python%E7%88%AC%E8%99%AB%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93.html</link>
          <guid isPermaLink="true">/coding/python%E7%88%AC%E8%99%AB%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93.html</guid>
        </item>
      
    
      
        <item>
          <title>利用爬虫爬取js生成数据</title>
          <description>&lt;p&gt;最近实习任务就是各种爬东西，先后爬取了&lt;a href=&quot;http://www.carking001.com/ershouche/&quot;&gt;车王二手车&lt;/a&gt;、&lt;a href=&quot;http://www.che300.com/&quot;&gt;车300网站&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基本都是用python的&lt;code&gt;urllib.request&lt;/code&gt; + &lt;code&gt;BeautifulSoup&lt;/code&gt;完成，其中因为车300的数据规格不统一，采取了先把所有数据爬下来保存为json格式再整理的方法。而且车300的汽车属性值太多，爬取过慢，采用了多线程的方式爬取（其实是同时运行多个程序。。。囧）。车王的爬取就要简单多了，不再一一赘述。&lt;/p&gt;

&lt;p&gt;昨天BOSS给我布置的任务是爬取&lt;a href=&quot;http://chinaafc.miit.gov.cn/n2257/n2263/index.html?searchId=yhcx&quot;&gt;工信部中国汽车燃料消耗量网站&lt;/a&gt;，本来以为把之前的代码随便改改就可以用了，没想到这个网站的数据是js生成的，也就是说我直接获取html页面源码的话是得不到想要的数据的。&lt;/p&gt;

&lt;p&gt;参考了下网上的资料，发现这个比较有用：&lt;a href=&quot;https://www.zhihu.com/question/21471960#answer-27853222&quot;&gt;Python 爬虫如何获取 JS 生成的 URL 和网页内容？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;但我刚读的时候没读懂，因为说的不够详细，我是在自己摸索出来后才发现我所做的就是答案所描述的内容。&lt;/p&gt;

&lt;p&gt;下面以图示的方法详细说一下怎么爬取想要的内容：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、在&lt;a href=&quot;http://chinaafc.miit.gov.cn/n2257/n2263/index.html?searchId=yhcx&quot;&gt;工信部中国汽车燃料消耗量网站&lt;/a&gt;界面按下F12，选择NetWork选项，并按下F5按键。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post44-step1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、刷新后观察NetWork变化，找到相应发送请求的文件，在这里是一个名为&lt;code&gt;searchIndex.jsp&lt;/code&gt;的文件，鼠标左键单击查看请求详细信息，可以观察到这个GET请求发送了一个param参数，从而我们可以猜想正是由于浏览器向服务器发送了param参数我们得以获得该页的数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post44-step2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、要想证实我们的猜想，我们先来看一下访问Request URL，访问的结果如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post44-step3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以发现恰好是我们当前页面数据的json格式，那之后的工作很容易想到就是获取每一页数据的json格式，我们再对数据进行整理即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4、现在我们来尝试对param进行解析，在这里使用&lt;a href=&quot;http://tool.chinaz.com/Tools/URLEncode.aspx&quot;&gt;UrlEncode编码/UrlDecode解码 - 站长工具&lt;/a&gt;进行解析，解析后的结果如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;param值为&lt;code&gt;%7B%22goPage%22%3A1%2C%22orderBy%22%3A%5B%7B%22orderBy%22%3A%22pl%22%2C%22reverse%22%3Afalse%7D%5D%2C%22pageSize%22%3A10%2C%22queryParam%22%3A%5B%7B%22type%22%3A%22number%22%2C%22shortName%22%3A%22sqgk%22%2C%22min%22%3A0%2C%22max%22%3A1000000%7D%2C%7B%22type%22%3A%22number%22%2C%22shortName%22%3A%22sjgk%22%2C%22min%22%3A0%2C%22max%22%3A1000000%7D%2C%7B%22type%22%3A%22number%22%2C%22shortName%22%3A%22zhgk%22%2C%22min%22%3A0%2C%22max%22%3A1000000%7D%5D%7D&lt;/code&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;解析后为&lt;code&gt;{&quot;goPage&quot;:1,&quot;orderBy&quot;:[{&quot;orderBy&quot;:&quot;pl&quot;,&quot;reverse&quot;:false}],&quot;pageSize&quot;:10,&quot;queryParam&quot;:[{&quot;type&quot;:&quot;number&quot;,&quot;shortName&quot;:&quot;sqgk&quot;,&quot;min&quot;:0,&quot;max&quot;:1000000},{&quot;type&quot;:&quot;number&quot;,&quot;shortName&quot;:&quot;sjgk&quot;,&quot;min&quot;:0,&quot;max&quot;:1000000},{&quot;type&quot;:&quot;number&quot;,&quot;shortName&quot;:&quot;zhgk&quot;,&quot;min&quot;:0,&quot;max&quot;:1000000}]}&lt;/code&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以注意到一个goPage的属性，可以猜想其后面的值即为对应的页码。再比较第二页的param值可以很容易定位到页码的位置是&lt;code&gt;%7B%22goPage%22%3A&lt;/code&gt; + page + &lt;code&gt;...&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;到这里我们就完成了基本的分析工作，后面要做的就是coding啦。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;最后附上我的代码：&lt;/h3&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import urllib
import urllib.request
import json
import mysql.connector

#工信部燃油爬虫类
class chinaafcCrawler:

    #建立数据库连接
    def __init__(self):
        self.id = 0
        self.conn = mysql.connector.connect(user='root', password='root', host='localhost', database='chinaafc')
        self.cursor = self.conn.cursor(buffered=True)
    
    #释放数据库连接
    def __del__(self):
        self.cursor.close()
        self.conn.close()

    #获取url对应的HTML源码
    def getHtml(self, url):
        headers = {
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/48.0.2564.116 Chrome/48.0.2564.116 Safari/537.36',
            'Host': 'chaxun.miit.gov.cn',
            'Request Method': 'GET',
        }
        headers = dict(headers)
        request = urllib.request.Request(url, headers=headers)

        #使用代理，避免被封IP
        try:
            proxy_support = urllib.request.ProxyHandler({'http' : '120.198.231.22:82'})
            opener = urllib.request.build_opener(proxy_support)
            urllib.request.install_opener(opener)

            page = urllib.request.urlopen(request)
            return page.read().decode('utf8')

        except urllib.request.HTTPError as e:
            print(&amp;quot;HTTPERROR: &amp;quot; + str(e))

        return

    #在获取的json中取出所有页面数目和所有条目数目，这里借用了json操作
    def getPageAndContentNum(self, url):
        str = self.getHtml(url).rstrip()
        str = &amp;quot;{&amp;quot; + str[str.find('totalContentNum')-1:-2]
        dataJson = json.loads(str)
        return (dataJson['totalContentNum'], dataJson['totalPageNum'])

    #截取我们想要的内容保存为json并进行解析，插入数据库
    def getHtmlDocSoup(self, html):
        total = html.rstrip()
        left = total.find('[')
        right = total.rfind(']')
        item = total[left:right+1]

        total = total[left:right+1]

        while True:
            left = total.find('{')
            if left == -1:
                break
            right = total.find('}')
            item = total[left:right+1]

            total = total[right+1:]

            dataJson = json.loads(item)

            keyLists = ['scqy', 'clzl', 'clxh', 'tymc', 'fdjxh', 'rllx', 'pl', 'tgrq',
                        'edgl', 'bsqlx', 'qdxs', 'zczbzl', 'zdsjzzl', 'sqgk', 'zhgk',
                        'sjgk', 'baID', 'sygjbz', 'sjlrsj', 'bz']

            for key in keyLists:
                if key not in dataJson.keys():
                    dataJson[key] = ''

            self.id += 1;
            query = &amp;quot;SELECT COUNT(*) FROM ryxhl WHERE id = %s&amp;quot;
            self.cursor.execute(query, (self.id,))
            res = self.cursor.fetchall()

            #去重
            if res[0][0] == 1:
                continue


            query = &amp;quot;INSERT INTO ryxhl(id, scqy, clzl, clxh, tymc, fdjxh, rllx, pl, tgrq, edgl, &amp;quot; \
                    &amp;quot;bsqlx, qdxs, zczbzl, zdsjzzl, sqgk, zhgk, sjgk, baID, sygjbz, sjlrsj, bz&amp;quot; \
                    &amp;quot;) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)&amp;quot;

            print(self.id)
            data = (self.id, dataJson['scqy'], dataJson['clzl'], dataJson['clxh'], dataJson['tymc'], dataJson['fdjxh'],
                    dataJson['rllx'], dataJson['pl'], dataJson['tgrq'], dataJson['edgl'], dataJson['bsqlx'],
                    dataJson['qdxs'], dataJson['zczbzl'], dataJson['zdsjzzl'], dataJson['sqgk'], dataJson['zhgk'],
                    dataJson['sjgk'], dataJson['baID'], dataJson['sygjbz'], dataJson['sjlrsj'], dataJson['bz'], )

            self.cursor.execute(query, data)
            self.conn.commit()

            '''
            print(&amp;quot;\n\n\n生产企业：&amp;quot; + dataJson['scqy'] +
                  &amp;quot;\n车辆种类：&amp;quot; + dataJson['clzl'] +
                  &amp;quot;\n车辆型号：&amp;quot; + dataJson['clxh'] +
                  &amp;quot;\n通用名称：&amp;quot; + dataJson['tymc'] +
                  &amp;quot;\n发动机型号：&amp;quot; + dataJson['fdjxh'] +
                  &amp;quot;\n燃料类型：&amp;quot; + dataJson['rllx'] +
                  &amp;quot;\n排量：&amp;quot; + dataJson['pl'] +
                  &amp;quot;\n通告日期：&amp;quot; + dataJson['tgrq'] +
                  &amp;quot;\n额定功率：&amp;quot; + dataJson['edgl'] +
                  &amp;quot;\n变速器类型：&amp;quot; + dataJson['bsqlx'] +
                  &amp;quot;\n驱动型式：&amp;quot; + dataJson['qdxs'] +
                  &amp;quot;\n整车整备质量：&amp;quot; + dataJson['zczbzl'] +
                  &amp;quot;\n最大设计总质量：&amp;quot; + dataJson['zdsjzzl'] +
                  &amp;quot;\n市区工况：&amp;quot; + dataJson['sqgk'] +
                  &amp;quot;\n综合工况：&amp;quot; + dataJson['zhgk'] +
                  &amp;quot;\n市郊工况：&amp;quot; + dataJson['sjgk'] +
                  &amp;quot;\n备案号：&amp;quot; + dataJson['baID'] +
                  &amp;quot;\nXX国际标准：&amp;quot; + dataJson['sygjbz'] +
                  &amp;quot;\nXXXX时间：&amp;quot; + dataJson['sjlrsj'] +
                  &amp;quot;\n备注：&amp;quot; + dataJson['bz']
                  )
            '''

def main():

    crawler = chinaafcCrawler()

    url = &amp;quot;http://chaxun.miit.gov.cn/asopCmsSearch/searchIndex.jsp?params=%257B%2522goPage%2522%253A1%252C%2522orderBy%2522%253A%255B%257B%2522orderBy%2522%253A%2522pl%2522%252C%2522reverse%2522%253Afalse%257D%255D%252C%2522pageSize%2522%253A10%252C%2522queryParam%2522%253A%255B%257B%2522shortName%2522%253A%2522allRecord%2522%252C%2522value%2522%253A%25221%2522%257D%255D%257D&amp;amp;callback=jsonp1457489227664&amp;amp;_=1457489227689&amp;quot;
    (totalContentNum, totalPageNum) = crawler.getPageAndContentNum(url)
    print(&amp;quot;共有&amp;quot;, totalPageNum, &amp;quot;页,&amp;quot;, totalContentNum, &amp;quot;条信息&amp;quot;)
    for page in range(1, totalPageNum+1):
        url = &amp;quot;http://chaxun.miit.gov.cn/asopCmsSearch/searchIndex.jsp?params=%257B%2522goPage%2522%253A&amp;quot; + str(page) + &amp;quot;%252C%2522orderBy%2522%253A%255B%257B%2522orderBy%2522%253A%2522pl%2522%252C%2522reverse%2522%253Afalse%257D%255D%252C%2522pageSize%2522%253A10%252C%2522queryParam%2522%253A%255B%257B%2522shortName%2522%253A%2522allRecord%2522%252C%2522value%2522%253A%25221%2522%257D%255D%257D&amp;amp;callback=jsonp1457489227664&amp;amp;_=1457489227689&amp;quot;
        crawler.getHtmlDocSoup(crawler.getHtml(url))

if __name__  == &amp;quot;__main__&amp;quot;:
    main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
          <pubDate>2016-03-09T00:00:00+08:00</pubDate>
          <link>/coding/%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96js%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE.html</link>
          <guid isPermaLink="true">/coding/%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96js%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE.html</guid>
        </item>
      
    
      
        <item>
          <title>基础排序算法总结</title>
          <description>&lt;p&gt;该篇博客介绍的经典算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序&lt;/p&gt;

&lt;h3 id=&quot;bubble-sort&quot;&gt;冒泡排序 Bubble Sort&lt;/h3&gt;

&lt;p&gt;概念：依次比较相邻两个元素的大小，这样一轮比较下来就可以得出当前轮的最值。&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、比较相邻的两个元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、若左侧元素值较大，则交换位置&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、第i轮比较范围为[0,n-i]，得到第i大元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4、到没有交换时即说明排序完成&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;void bubble_sort(int a[], int n) {
    for(int i=0; i&amp;lt;n; ++i) {
    	for(int j=1; j&amp;lt;n-i; ++j) {
    		if(a[j] &amp;lt; a[j-1]) {
    			swap(a[j], a[j-1]);
    		}
    	}
    }
    return;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复杂度：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;最差时间复杂度：O(n^2)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;最佳时间复杂度：O(n)[需在原代码基础上加标志位优化，见下文]&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;平均时间复杂度：O(n^2)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;优化：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、添加标志位，当序列有序时，停止冒泡；时间复杂度提升至O(n)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、减少遍历次数，对已经有序的部分不再遍历&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;拓展：&lt;/p&gt;

&lt;p&gt;鸡尾酒排序：对冒泡排序进行改进，每次先从低到高遍历，再从高到低遍历，即来回遍历。性能上要比冒泡排序好一些。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;代码：
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;void cocktail_sort(int arr[], int len) {
    int left = 0;
    int right = len-1;
    bool swapped = true;//标志是否已经还需要排序
    while(swapped) {
        swapped = false;
    	for(i=left; i&amp;lt;right; ++i) {
    		if(arr[i] &amp;gt; arr[i+1]) {
    			swap(arr[i], arr[i+1]);
    			swapped = true;
    		}
    	}
    	
    	--right;
    	
    	for(i=right; i&amp;gt;left; --i) {
    		if(arr[i] &amp;lt; arr[i-1]) {
    			swap(arr[i], arr[i-1]);
    			swapped = true;
    		}
    	}
    	
    	++left;
    }
    return;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;选择排序&lt;/h3&gt;

&lt;p&gt;概念：每次从未排序部分中找出最小值，放在已排序部分后面。&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、在未排序部分找出最小值，放在已排序部分后面&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、重复1的操作直到全部排好序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;源代码：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;void select_sort(int a[], int n) {
    for(int i=0; i&amp;lt;n; ++i) {
        int min = i;
        for(int j=i+1; j&amp;lt;n; ++j) {
            if(a[min] &amp;gt; a[j])
                min = j;
        }
        swap(a[i], a[min]);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复杂度：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;最差时间复杂度：O(n^2)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;最佳时间复杂度：O(n^2)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;平均时间复杂度：O(n^2)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;插入排序&lt;/h3&gt;

&lt;p&gt;概念：对于每个未排序数据，扫描已排序数组，并插入到合适的位置。&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、第一个元素认为已排序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、之后每取出一个元素，插入到已排序数组的合适位置&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;源代码：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;void insert_sort(int a[], int n) {
    int j;
	for(int i=1; i&amp;lt;n; ++i) {//待排序部分
	    int tmp = a[i];
	    for(j=i-1; j&amp;gt;=0&amp;amp;&amp;amp;a[j]&amp;gt;tmp; --j) {//已排序部分
	        a[j+1] = a[j];
	    }
	    a[j+1] = tmp;
	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复杂度：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;最差时间复杂度：O(n^2)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;最佳时间复杂度：O(n)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;平均时间复杂度：O(n^2)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;优化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、如果数组范围较大，可采用二分查找，找到第一个比a[i]大的位置再insert即可
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;希尔排序&lt;/h3&gt;

&lt;p&gt;概念：是对插入排序的高效改进，将序列每次按不同步长划分，再对每列进行插入排序，是非稳定算法&lt;/p&gt;

&lt;p&gt;步骤：每次按不同的步长对数组进行划分行，再对每列进行插入排序，改变步长重复上面的操作，直到步长为1，即得到完全有序的数组&lt;/p&gt;

&lt;p&gt;源代码：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;void shell_sort(int a[], int n) {
    int j;
    for(int gap = n&amp;gt;&amp;gt;1; gap &amp;gt; 0; gap &amp;gt;&amp;gt;= 1) {
        for(int i=gap; i&amp;lt;n; ++i) {//未排序部分
            int tmp = a[i];
            for(j = i-gap; j&amp;gt;0&amp;amp;&amp;amp;a[j]&amp;gt;tmp; j-=gap) {//已排序部分
                a[j+gap] = a[j];  
            }
            a[j+gap] = tmp;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复杂度：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;复杂度取决于步长的选择。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;归并排序&lt;/h3&gt;

&lt;p&gt;概念：采用分治法实现，将数组先分解再合并的过程中做到排序&lt;/p&gt;

&lt;p&gt;步骤：将数组递归地分为left、right两部分，当left、right分别有序后再合并left、right即可得到排序后的数组。&lt;/p&gt;

&lt;p&gt;源代码：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;void merge_sort(int arr[], int n) {
    int *a = arr;
    int *b = (int*)malloc(n*sizeof(int*));
    int seg, start;
    for(seg = 1; seg &amp;lt; n; seg += seg) {
        for(start = 0; start &amp;lt; n; start += seg + seg) {
            int low = start;
            int mid = min(start+seg, n);
            int high = min(start+seg+seg, n);
            int start1 = low;
            int end1 = mid;
            int start2 = mid;
            int end2 = high;
            int k = low;
            while(start1 &amp;lt; end1 &amp;amp;&amp;amp; start2 &amp;lt; end2) {
                b[k++] = a[start1] &amp;lt; a[start2] ? a[start1++] : a[start2++];
            }
            while(start1 &amp;lt; end1) {
                b[k++] = a[start1++];
            }
            while(start2 &amp;lt; end2) {
                b[k++] = a[start2++];
            }
        }
        int *tmp = a;
        a = b;
        b = tmp;
    }
    if(a != arr) {
        int i;
        for(i = 0; i &amp;lt; n; ++i) {
            b[i] = a[i];
        }
        b = a;
    }
    free(b);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复杂度：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;最差时间复杂度：O(nlogn)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;最佳时间复杂度：O(n)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;平均时间复杂度：O(nlogn)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;快速排序&lt;/h3&gt;

&lt;p&gt;概念：每次把序列以基准划分为左右两部分，重新排列使左侧部分小于基准，右侧部分大于基准。再对基准左右两侧分别进行排序。&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、挑出一个元素作为基准&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、重新排序，使得比基准小的元素都放在基准左侧，比基准大的元素都放在基准右侧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、递归地对基准左右两侧数据进行排序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;源代码：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;void quick_sort(int a[], int start, int end) {
	if(start &amp;gt;= end)
		return ;
	int mid = a[end];
	int left = start;
	int right = end - 1;
	while(left &amp;lt; right) {
		while(a[left] &amp;lt; mid &amp;amp;&amp;amp; left &amp;lt; right)
			++left;
		while(a[right] &amp;gt;= mid &amp;amp;&amp;amp; left &amp;lt; right)
			--right;
		swap(&amp;amp;a[left], &amp;amp;a[right]);
	}
	if(a[left] &amp;gt;= a[end]) {
		swap(&amp;amp;a[left], &amp;amp;a[end]);
	} else ++left;
	quick_sort(a, start, left-1);
	quick_sort(a, left+1, end);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复杂度：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;最差时间复杂度：O(n^2)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;最佳时间复杂度：O(nlogn)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;平均时间复杂度：O(nlogn)&lt;/p&gt;
&lt;/blockquote&gt;
</description>
          <pubDate>2016-01-30T00:00:00+08:00</pubDate>
          <link>/coding/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html</link>
          <guid isPermaLink="true">/coding/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html</guid>
        </item>
      
    
      
        <item>
          <title>Linux内核模块编程入门</title>
          <description>&lt;p&gt;首先我们要明确linux下内核编程与平时我们在linux下写的C程序之间的区别，在这里我们把在linux下写一般C程序的过程称之为用户层编程，与之相对的就是我们要学习的内核编程。&lt;/p&gt;

&lt;p&gt;首先介绍linux内核，&lt;strong&gt;内核&lt;/strong&gt;指的是一个提供硬件抽象层、磁盘、文件系统控制及多任务等功能的系统软件。我们可以把内核理解为操作系统的核心部分（&lt;strong&gt;注意：内核不等于操作系统&lt;/strong&gt;）。而linux内核就是linux操作系统的内核。&lt;/p&gt;

&lt;p&gt;内核由负责不同功能的内核模块组成，内核模块可以被单独编译，但是不能单独运行，它必须要链接到内核作为内核的一部分在内核空间中运行。内核之所以采用这种结构方式是因为这体现了模块化的思想，在保证内核不会太大的同时，又可以做到模块一旦被加载就和内核中的其他部分一样使用。&lt;/p&gt;

&lt;p&gt;用户层编程和内核模块编程的区别：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post42-difference.jpg&quot; alt=&quot;用户层编程与内核模块编程区别&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面编写一个内核模块中的hello world程序:&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;//filename: hello.c

#include &amp;lt;linux/init.h&amp;gt;

#include &amp;lt;linux/module.h&amp;gt;

#include &amp;lt;linux/kernel.h&amp;gt;

//这里的三个头文件是编写内核模块程序所必须的

MODULE_LICENSE(&amp;quot;Dual BSD/GPL&amp;quot;);

/*可选

MODULE_AUTHOR(&amp;quot;yinwoods&amp;quot;);

MODULE_DESCRIPTION(&amp;quot;This is a simple example!\n&amp;quot;);

MODULE_ALIAS(&amp;quot;A simplest example&amp;quot;);

*/

static int hello_init(void) {
    printk(KERN_ALERT &amp;quot;hello, I am yinwoods&amp;quot;);
    //printk是内核态信息打印函数，功能上与printf类似。不同的是printk具有消息打印机别，这里的KERN_ALERT即为一个消息级别。
    return 0;
}

static void hello_exit(void) {
    printk(KERN_ALERT &amp;quot;good bye, kernel\n&amp;quot;);
}

module_init(hello_init);
module_exit(hello_exit);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;moduleinitmoduleexit&quot;&gt;module_init()函数和module_exit()函数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;module_init(hello_init)&lt;/code&gt;是指模块程序从&lt;code&gt;hello_init&lt;/code&gt;开始执行，函数参数就是注册函数的函数名。&lt;/p&gt;

&lt;p&gt;同理，&lt;code&gt;module_exit(hello_exit)&lt;/code&gt;是指模块程序从&lt;code&gt;hello_exit&lt;/code&gt;离开，函数参数就是卸载函数的函数名。&lt;/p&gt;

&lt;p&gt;这里可以类比C++类中的构造函数与析构函数；也就是说我们一般在&lt;code&gt;module_init()&lt;/code&gt;中动态申请内存、中断等资源；而在模块卸载函数&lt;code&gt;module_exit()&lt;/code&gt;中回收这些资源。&lt;/p&gt;

&lt;p&gt;程序写好了，那么怎么编译运行呢？&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;内核编写程序的编译运行&lt;/h3&gt;

&lt;p&gt;在linux下对内核程序进行编译运行与普通程序是不同的，不是通过g++的命令实现,而是需要我们编写makefile脚本并使用make命令来实现多文件的编译。&lt;/p&gt;

&lt;p&gt;makefile是一种脚本，这种脚本主要是用于多文件的编译。它定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译等等。&lt;/p&gt;

&lt;p&gt;make是一个解释makefile中指令的命令工具，可以维护具有相互依赖性的源文件，当某些文件发生改变时，它能自动识别出，并只对改动后的文件进行编译。&lt;/p&gt;

&lt;h3 id=&quot;makefile&quot;&gt;简单介绍一下如何编写makefile：&lt;/h3&gt;

&lt;p&gt;makefile的规则大体上就是以下格式：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;target:dependency-file
    command&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;target是一个目标文件，可以是Object File（linux下的.o文件），也可以是最终的执行文件。
而dependency-file是生成相应target所需要依赖的文件或者其它的target。
command就是最终由make执行的命令。&lt;/p&gt;

&lt;p&gt;也就是说我们告诉了make程序需要生成的文件target和它所依赖的dependency-file文件还有执行命令command，那么make程序只需要按照这种方式解析makefile即可。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;内核程序的编译运行&lt;/h3&gt;

&lt;p&gt;1、编写好makefile文件&lt;/p&gt;

&lt;p&gt;2、使用make进行编译&lt;/p&gt;

&lt;p&gt;3、编译后使用sudo insmod *.ko 加载模块&lt;/p&gt;

&lt;p&gt;4、使用dmesg查看运行结果&lt;/p&gt;

&lt;p&gt;5、使用rmmod tiger卸载模块&lt;/p&gt;

&lt;p&gt;6、使用make clean删除中间生成的文件&lt;/p&gt;

&lt;p&gt;在这里贴出示例程序对应的makefile文件：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;KERNEL_DIR = /usr/src/linux-headers-$(shell uname -r)/
#KERNAL_DIR表示内核源代码的位置。在这里是链接到包含着正在使用内核对应源代码的目录树位置。
PWD := $(shell pwd)
#PWD指示了当前工作目录并且是我们自己内核模块的源代码位置。

obj-m := hello.o

#需要编译连接多个文件时，只需要在添加。再添加相应的语句即可，如下：
#obj-m += device1.o
#obj-m += device2.o

all:
	$(MAKE) -C $(KERNEL_DIR) M=$(PWD) modules
#这里是指在包含源代码位置的地方进行make，然后编译$(PWD)目录下的modules。这里允许我们使用所有定义在内核源代码树下的所有规则来编译我们的内核模块。

clean:
	$(MAKE) -C $(KERNEL_DIR) M=$(PWD) clean
	$(RM) Module.markers modules.order&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;按照上述的编译运行步骤，make, insmod hello.ko, dmesg即可看到&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
hello, I am yinwoods
good bye, kernel
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最后通过rmmod hello 卸载该模块。&lt;/p&gt;

&lt;p&gt;因为导师布置的毕设题目是platform虚拟总线下的进程调度，所以这段时间要好好补一补linux内核设备驱动方面知识了。&lt;/p&gt;

&lt;p&gt;下一步是实现platform下简单的线程通信。加油！&lt;/p&gt;
</description>
          <pubDate>2016-01-14T00:00:00+08:00</pubDate>
          <link>/coding/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8.html</link>
          <guid isPermaLink="true">/coding/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8.html</guid>
        </item>
      
    
      
        <item>
          <title>windows进程通信方式&amp;消息处理机制</title>
          <description>&lt;h3 id=&quot;section&quot;&gt;窗口消息&lt;/h3&gt;

&lt;p&gt;一个GUI程序必须对用户以及操作系统产生的事件有所响应。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用户发出的事件包括所有能够与程序交互的所有方式，例如：点击鼠标、敲击键盘、触摸手写屏等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;操作系统发出的事件指除了用户发出事件外所有能影响程序的事件，例如：用户插入一个u盘等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这些事件可以在程序运行期间的任意时刻以任意顺序发生，那么怎样去创建一个这样运行顺序不能被提前预测的应用程序呢？&lt;/p&gt;

&lt;p&gt;为了解决这个问题，windows使用一个消息传递模型。操作系统通过向应用程序窗口发送消息来与应用程序互动。每个消息都是一个代表指定事件的数字代码。例如用户按下鼠标左键，应用程序窗口将会收到下面这则消息代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#define WM_LBUTTONDOWN 0x0201&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有些消息与窗口有数据关联。比如：&lt;code&gt;WM_LBUTTONDOWN&lt;/code&gt;消息包含了光标所在位置的x、y坐标。&lt;/p&gt;

&lt;p&gt;为了把消息传递给窗口，操作系统会调用注册在这个窗口上专门处理消息的窗口过程。&lt;/p&gt;

&lt;h5 id=&quot;section-1&quot;&gt;消息循环&lt;/h5&gt;

&lt;p&gt;一个应用程序在运行时会收到上千条消息。一个程序可以有多个窗口，每个窗口有着自己的窗口过程。那么应用程序怎样正确接收消息又怎样将消息正确地传递给窗口过程呢？应用程序需要一个循环来正确地获取消息和派发消息到正确的窗口。&lt;/p&gt;

&lt;p&gt;对创建窗口的每一个线程来说，操作系统为窗口消息创建了一个队列。这个队列保存了该线程创建的所有窗口的消息。队列对于程序来说是不可见的。你不能直接操作队列，但是你可以通过调用&lt;code&gt;GetMessage()&lt;/code&gt;函数来从队列中获取一条消息。&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;MSG msg;
GetMessage(&amp;amp;msg, NULL, 0, 0);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个函数从队首移除消息。如果队列为空，这个函数阻塞直到另一个消息进入队列。&lt;code&gt;GetMessage&lt;/code&gt;阻塞并不会导致应用程序失去响应。如果没有消息，应用程序不会做任何事情。如果需要在后台运行程序，可以在&lt;code&gt;GetMessage&lt;/code&gt;等待其它消息时创建额外的线程来继续运行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GetMessage&lt;/code&gt;函数的第一个参数是MSG结构体地址，如果函数成功运行，它将会利用消息相关信息补齐MSG结构体，包括目标窗口以及消息代码；其它三个参数则可以让你过滤掉从队列中获取的其它消息。大多数情况下你会令这些参数为0。&lt;/p&gt;

&lt;p&gt;虽然MSG结构体包含了消息的相关信息，你几乎不可能直接检测这个构造函数，而是将它传递给另外两个函数。&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;TranslateMessage(&amp;amp;msg);
DispatchMessage(&amp;amp;msg);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;TranslateMessage&lt;/code&gt;函数与键盘输入相联系，它把敲击键盘的行为解释为字符串。你并不需要知道这个函数如何运转；只需要记住在&lt;code&gt;DispatchMessage&lt;/code&gt;前调用这个函数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DispatchMessage&lt;/code&gt;函数告诉操作系统调用目标消息的窗口的窗口过程。换句话说，操作系统在窗口表中查找窗口句柄，找到与窗口相关的函数指针，然后调用这个函数。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;当用户点击鼠标左键后，会引发一连串事件：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、操作系统将&lt;code&gt;WM_LBUTTONDOWN&lt;/code&gt;消息加入消息队列中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、应用程序调用&lt;code&gt;GetMessage&lt;/code&gt;函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、GetMessage从队列中获取&lt;code&gt;WM_LBUTTONDOWN&lt;/code&gt;消息，并填入MSG结构体中&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4、应用程序调用&lt;code&gt;TranslateMessage&lt;/code&gt;函数和&lt;code&gt;DispatchMessage&lt;/code&gt;函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5、在&lt;code&gt;DispatchMessage&lt;/code&gt;函数中，操作系统调用窗口过程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;6、窗口过程可以选择响应或者忽略它&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当窗口过程返回时，返回给&lt;code&gt;DispatchMessage&lt;/code&gt;，&lt;code&gt;DispatchMessage&lt;/code&gt;返回下一条消息到消息循环中。只要你的程序还在运行，消息会持续到达队列中，因此需要一个循环持续地从队列中提取信息并派发它们。你可以认为循环像下面这个工作：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;while (1)      
{
    GetMessage(&amp;amp;msg, NULL, 0,  0);
    TranslateMessage(&amp;amp;msg); 
    DispatchMessage(&amp;amp;msg);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就像上述代码一样，这个循环是一个死循环。一般来说，&lt;code&gt;GetMessage&lt;/code&gt;返回一个非零值，当你想退出应用、离开消息循环时，只需要调用&lt;code&gt;PostQuitMessage&lt;/code&gt;函数即可。&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;PostQuitMessage(0);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;PostQuitMessage&lt;/code&gt;函数将&lt;code&gt;WM_QUIT&lt;/code&gt;消息加入消息队列中。&lt;code&gt;WM_QUIT&lt;/code&gt;是一个特殊的消息，它会导致&lt;code&gt;GetMessage&lt;/code&gt;返回0，也就是消息循环终结，下面是修改后的消息循环：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;MSG msg = {};
while(GetMessage(&amp;amp;msg, NULL, 0, 0)) {
	TranslateMessage(&amp;amp;msg);
	DispatchMessage(&amp;amp;msg);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只要&lt;code&gt;GetMessage&lt;/code&gt;返回一个非零值，while循环中的表达式便会始终为真。当你调用&lt;code&gt;PostQuitMessge&lt;/code&gt;时，表达式变为假，程序退出循环。一个有趣的现象是窗口过程永远不会收到&lt;code&gt;WM_QUIT&lt;/code&gt;消息，所以不需要在窗口过程中考虑这种情况。&lt;/p&gt;

&lt;p&gt;一些情况下，操作系统会绕过队列，直接调用窗口过程。&lt;/p&gt;

&lt;p&gt;区别在于术语&lt;code&gt;Posting&lt;/code&gt;和&lt;code&gt;Sending&lt;/code&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;Posting&lt;/code&gt;意味着消息加入消息队列中，通过消息循环派发&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;Sending&lt;/code&gt;意味着消息跳过队列，操作系统直接调用窗口过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;暂时来说，这两者的区别并不重要，窗口过程处理所有的消息，但一些消息绕过队列，直接进入窗口过程。
然而如果你的应用程序在窗口间交互，这两者的区别就很大。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;将消息写入窗口过程&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;DispatchMessage&lt;/code&gt;函数调用目标消息窗口的窗口过程。窗口过程有如下声明：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里有四个参数：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;hwnd&lt;/code&gt;是一个窗口句柄&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;uMsg&lt;/code&gt;是消息代码；比如&lt;code&gt;WM_SIZE&lt;/code&gt;表示窗口大小改变。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;wParam&lt;/code&gt;和&lt;code&gt;lParam&lt;/code&gt;包含这个消息的其他信息；所指示的意义取决于消息代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;LRESULT&lt;/code&gt;是一个程序返回给windows的整数值，它包含了程序对于特定消息的响应，这个整数值所代表的意义取决于消息代码。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CALLBACK&lt;/code&gt;是函数的调用协定。&lt;/p&gt;

&lt;p&gt;一个典型的窗口过程是一个检测消息代码的switch语句，形式如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;switch(uMSg) {
	case WM_SIZE: //Handle window resizing
	//etc
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;消息所包含的多余信息保存在&lt;code&gt;lParam&lt;/code&gt;和&lt;code&gt;wParam&lt;/code&gt;中。这两个参数值的具体含义取决于&lt;code&gt;uMsg&lt;/code&gt;，需要在MSDN上查找消息代码并作正确的数据类型转换。通常这个值要么是一个数值，要么是一个指向结构体的指针。当然，有些消息不包含任何多余的数据。&lt;/p&gt;

&lt;p&gt;举个栗子,&lt;code&gt;WM_SIZE&lt;/code&gt;的文档表述为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;wParam&lt;/code&gt;指示窗口是最小化、最大化、还是重新设置大小。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;lParam&lt;/code&gt;包含了用16位值表示的窗口新宽度、新高度。而16位值被存储为32位或64位形式，需要做一些位的转换操作才能得到原来的值。幸运的是，&lt;code&gt;WinDef.h&lt;/code&gt;头文件包含了处理这些任务的宏命令。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个窗口过程可能会处理很多消息，这就导致它的switch代码很长。一种使代码模块化的方法是把处理不同逻辑的语句放在不同的函数中。在窗口过程中，会把&lt;code&gt;wParam&lt;/code&gt;和&lt;code&gt;lParam&lt;/code&gt;转换为正确的数据类型，并将对应的值传递给函数。例如，为了处理&lt;code&gt;WM_SIZE&lt;/code&gt;消息，窗口过程会这么做：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_SIZE: 
        {
            int width = LOWORD(lParam);  // Macro to get the low-order word.
            int height = HIWORD(lParam); // Macro to get the high-order word.

            // Respond to the message:
            OnSize(hwnd, (UINT)wParam, width, height);
        }
        break;
        
    }
}

void OnSize(HWND hwnd, UINT flag, int width, int height);
{
    // Handle resizing
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;LOWORD&lt;/code&gt;和&lt;code&gt;HIWORD&lt;/code&gt;宏从&lt;code&gt;lParam&lt;/code&gt;中获取16位的宽度和高度。窗口过程提取宽度、高度，然后把值传递给&lt;code&gt;OnSize&lt;/code&gt;函数。&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;默认的消息处理&lt;/h5&gt;

&lt;p&gt;如果不在窗口过程中处理一条特定的消息，把消息参数直接传递给&lt;code&gt;DefWindowProc&lt;/code&gt;函数，这个函数会根据消息类型表现不同的默认消息处理行为。&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;return DefWindowProc(hwnd, uMsg, wParam, lParam);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-4&quot;&gt;在窗口过程中避免瓶颈&lt;/h5&gt;

&lt;p&gt;当窗口过程执行时，它会屏蔽掉该线程创建的其他窗口的所有消息。因此要避免在窗口过程中长时间处理一条消息。举个栗子，程序打开了一个TCP连接，然后无限等待服务器的响应，在这段等待的时间中，窗口将不能处理点击鼠标、敲击键盘、甚至是关闭的事件。&lt;/p&gt;

&lt;p&gt;遇到这种瓶颈时需要做的就是把任务交由其他线程来完成，可以用以下几种方式之一来完成：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;创建一个新线程&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;使用一个线程池&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;使用一个异步的I/O调用&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;使用异步程序调用&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;
</description>
          <pubDate>2015-12-24T00:00:00+08:00</pubDate>
          <link>/coding/windows%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.html</link>
          <guid isPermaLink="true">/coding/windows%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.html</guid>
        </item>
      
    
      
        <item>
          <title>实习面试总结以及近期规划</title>
          <description>&lt;p&gt;由于大四上快结束了，即将面临毕设的开题，学校与郑州这边的一些IT公司达成定向派遣学生到企业实习+毕设的协议，班上的同学还挺积极的，我没参加因为想着要在北京找实习。&lt;/p&gt;

&lt;p&gt;趁着周六考完六级，周日坐上火车前往北京，提前投简历确定了参加两个公司的实习面试：薪人薪事和福昕。&lt;/p&gt;

&lt;p&gt;周一前往薪人薪事面试研发实习生，提前一个半小时去的，公司在来广营地铁口附近，地理位置不太好。公司内部就是一层开阔的楼层摆放着一些办公桌，大家都在一起集体办公。到公司后，先让我做了一份笔试题，共两题，第一题是用数据结构实现栈，并支持getMax()与getMin()分别取得栈中的最大值与最小值，因为题目比较简单，就写了一个简单的类来实现栈的功能，但不得不说自己的粗心大意。。。忘了实现getMax()和getMin()了，后来面试官面试过程中问到了，我的答案是在类中维持两个变量分别记录当前栈中的最大值与最小值，每当push操作时，要比较新元素与当前的最大值、最小值，并根据大小关系选择是否更新，而pop时如果pop的恰是最大值或最小值，则需要遍历栈中（用数组实现）元素更新最大值、最小值。后来看答案说是借用辅助栈来保存每次进栈时的最值！时间复杂度可以做到O(1)。第二道题是剔除一个字符串中的重复字符，遍历两次即可。&lt;/p&gt;

&lt;p&gt;面试过程中先让我谈了自己的毕设计划，我说是做一个爬虫用来爬取微博数据并对数据进行多维的分析，面试官未置可否。之后对着我的简历问了一些问题，问的问题很杂，比如对python中lambda表达式的理解，我的答案是用非函数形式的表达式实现函数的功能。也问到了我的博客实现、git的使用方法等。之后又问了操作系统中进程间的通信方式、SQL语句、数据结构等。因为没有提前准备，之前学过的东西都忘的差不多了，因此答得很不好，这个时候我感觉到面试官好像对我的简历有所怀疑，问了我北航研究生有几个学年，之后问了一道算法题，感觉以为这道题没有答好直接导致我悲剧了。。。题目是已知一个递增的序列，截取序列前一部分放到序列后，现在已知更改后的序列，问怎么确定序列中最小元素的位置。答得很不好，想到了二分，但没有想清楚怎么用二分实现，最后想到用序列最后一个元素在序列中二分查找答案。但这时时间已经过去很久了。面试结束后hr进来说另一名技术人员正在开会，不方便面试，让我回去等通知，我就知道悲剧了。。。&lt;/p&gt;

&lt;p&gt;第二天早上去了福昕面试C++开发实习生，值得一说的是福昕就在北航旁边。。。同样是提前去的，等了一个小时后，给我拿了一套笔试题，不得不说题目太多了。。。记得答案一共写了5页，问的主要是C++的内容，也涉及到了操作系统相关知识，同样有进程间通信方式的题目-_-#;感觉总体上答得还不错，但是也有一部分题目没答好，比如C++中定义指向函数的指针、指向函数的指针数组；判断一个点是否在椭圆内（忘记椭圆方程了…）；虚函数的实现方式等，一个半小时做完笔试题，之后hr说是技术人员正在开会（大家都好喜欢开会），和我谈了薪资的问题就让我回去等通知了。&lt;/p&gt;

&lt;p&gt;下午临时去面了海豚浏览器的后台研发实习生，先让做了一个小时的笔试题，包含25道数据库、java、操作系统、计算机网络、数据结构不定项选择题，以及两道编程题（表达式计算和二分实现）。选择题就不说了因为没准备，所以做的很不好，编程题比较坑的是提供的编译环境很差，而且函数的接口设计的很奇怪。。。于是一道题都没写出来，做完笔试相关人员告诉我悲剧了，就走了。&lt;/p&gt;

&lt;p&gt;晚上就坐上回郑州的火车了。。。&lt;/p&gt;

&lt;p&gt;总结一下面试的教训：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;投简历要定向投！！！投简历要定向投！！！投简历要定向投！！！这次虽然面了三个公司，但是只有福昕算是对胃口的，其他两家要求的知识储备太多。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;一定要提前准备！&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;面试中公司在本心上是不相信你的简历的，所以会花相当一部分时间试图来验证你的简历是否作假。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;尽量多投几家公司，既可以增长面试经验，又可以意识到自己的不足。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;正是由于这次面试的失败，让我意识到了自己的不足，这样才可以让自己更好地与社会工作岗位接轨。&lt;/p&gt;

&lt;p&gt;近期规划：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;认真攻克C++上的难点，学习多线程编程、窗口消息机制&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;看看数据库、操作系统相关内容、面试题&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;复习并学习面试中常考算法、数据结构&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;FIghting！&lt;/p&gt;
</description>
          <pubDate>2015-12-23T00:00:00+08:00</pubDate>
          <link>/diary/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E8%BF%91%E6%9C%9F%E8%A7%84%E5%88%92.html</link>
          <guid isPermaLink="true">/diary/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E8%BF%91%E6%9C%9F%E8%A7%84%E5%88%92.html</guid>
        </item>
      
    
      
        <item>
          <title>《辩护人》观后感</title>
          <description>&lt;p&gt;记得小学语文课有段时间学习读/观后感的写作方式，对于语文本来就不好、课外书只看机器猫、电影只看周星驰的我，每次面对这种比普通作文更需要真情实感的作文只能选择瞎编乱造+东搬西凑。后来随着年龄、学历的增长好像就再没有接触过这种类型的作文了。今晚看过《辩护人》这部电影，确实触动了心中的某个角落，不吐不快。&lt;/p&gt;

&lt;p&gt;毫无疑问这部电影是一部精品，但之所以能够触动我不只是因为剧本剧情出众、演员演技到位，更多的是那种小市民为国家、为正义而奋斗的“义”；&lt;/p&gt;

&lt;p&gt;刚看到20分钟的时候已经意识到这是一部难得的佳作了，主人公宋佑硕在工地上劳累奔波的时候对自己许下了永不放弃的承诺，作为一个而立之年的男人，去小餐馆吃饭因为想要用身上仅有的钱赎回自己的司法考试书籍而不得不趁着店家不注意时逃单，那一刻的耻辱对于一个男人来说足以付出一切努力来改变了吧！电影中很感人的一点就是人与人之间的尊重、友好，这在宋佑硕生活大大改善后返回当年出逃的小店体现的淋漓尽致，甚至有一刻我想到这不正是孔子所说的大同社会以及陶潜所说的桃花源中的生活吗？！&lt;/p&gt;

&lt;p&gt;后面看到宋佑硕在生活小康之后想着靠帆船竞赛为国家尽自己的一份义务，不由得心生感慨：是啊！即使是为生活、为家人奔波忙碌的小市民，在他生活趋于稳定之后也会想着回报国家，如果是在自己尚且难以温饱果腹的情况下为国尽心尽力，纵然感人却让人觉得不真实。最后宋佑硕是走上了为国家民主而拼搏奋斗的路上，但明显区别于很多国产爱国电影的一个地方就是他并不是生来政治觉悟就很高地想着靠自己的双手来改变民生国计，因为他只是一个小市民，是在周遭环境的剧变下被历史的大潮流推上了为民主、名族而奋斗的这个大舞台。&lt;/p&gt;

&lt;p&gt;小时候看一些民族英雄的英勇事迹总是会想那些人为什么会杀身成仁、舍身取义呢？这个问题对于年幼的我来说是无解的。记得第一次对这个问题有些感悟的时候是在大一、大二的时候吧，那段时间总是失眠，正是由于那段时间深受失眠折磨，再加上思绪的天马行空，意识到死亡并不是一件很可怕的事，既然如此那么一些人为仁义而做出舍身的选择也就可以稍稍理解了吧。观看这部电影的过程中则让我彻底想清楚了这个问题，皮之不存毛将焉附？就像生活中小孩子尚且会在妈妈、朋友被别人欺负时而挺身站出一样，纵然自己很弱小也要守护住自己珍惜心爱的人与事物吧！对于一个热爱国家、热爱美好生活的人来说，当生活变得难以温饱、国家变得残缺不整的时候尽己所能为国家、为民族、为大义而拼搏、而奋斗不是人的本能吗？！&lt;/p&gt;

&lt;p&gt;因为这部电影联想到了看到的一些墙外新闻，中国也有大量的宋佑硕存在，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B710%E3%80%8C%E7%B6%AD%E6%AC%8A%E5%BE%8B%E5%B8%AB%E3%80%8D%E5%A4%A7%E6%8A%93%E6%8D%95%E4%BA%8B%E4%BB%B6&quot;&gt;710事件&lt;/a&gt;就是这些律师的荣誉勋章，我想这些仁人志士们终将成为被镶在历史教科书中的民族英雄！&lt;/p&gt;

&lt;p&gt;想到中国的民主，我相信在中国走向世界舞台中心的过程中那一天总会到来的！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post38-民主.jpg&quot; alt=&quot;民主&quot; /&gt;&lt;/p&gt;
</description>
          <pubDate>2015-11-21T00:00:00+08:00</pubDate>
          <link>/diary/%E8%BE%A9%E6%8A%A4%E4%BA%BA%E8%A7%82%E5%90%8E%E6%84%9F.html</link>
          <guid isPermaLink="true">/diary/%E8%BE%A9%E6%8A%A4%E4%BA%BA%E8%A7%82%E5%90%8E%E6%84%9F.html</guid>
        </item>
      
    
      
        <item>
          <title>C++中两个类相互引用的问题</title>
          <description>&lt;p&gt;今天在编写C++小程序的过程中遇到一个问题，假如说我们现在要实现一个邮件消息Message类和消息存放目录Folder类；&lt;/p&gt;

&lt;p&gt;一个消息可以属于多个目录，而一个目录也可以包含多个消息。&lt;/p&gt;

&lt;p&gt;实现的基本方法是Message类中有一个指向Folder类的指针集合，message对象属于集合中的每个folder，而Folder类中又有一个指向Message类的指针集合，该集合包含了这个目录下的所有message。这么说好像有点晕。。。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;//Message.h
#include &amp;quot;Folder.h&amp;quot;
class Message {
public:
    ...
private:
    set&amp;lt;Folder*&amp;gt; folders;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;//Folder.h
#include &amp;quot;Message.h&amp;quot;
class Folder {
public:
    ...
private:
    set&amp;lt;Message*&amp;gt; messages;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码中的Message类声明和Folder类声明相互引用，如果我们在两个类中分别&lt;code&gt;#include&lt;/code&gt;另一个类，那么就会带来一个问题，编译器会发现头文件引用没有尽头，也就是说陷入了无限循环从而导致编译错误！&lt;/p&gt;

&lt;p&gt;在网上查找相关资料后发现了一个比较好的解决方法，就是在Message或Folder类中声明另一个类，然后在类的定义中&lt;code&gt;#include&lt;/code&gt;相应的类声明头文件。&lt;/p&gt;

&lt;p&gt;可能有些不太好理解，代码实现如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;//Message.h

class Folder;

class Message {
public:
    ...
private:
    set&amp;lt;Folder*&amp;gt; folders;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;//Message.cpp

#include &amp;quot;Folder.h&amp;quot;
//注意在定义文件中一定要引入相应的声明文件，否则会导致编译器报错无法引用一个不完整类型
...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;//Folder.h
#include &amp;quot;Message.h&amp;quot;
class Folder {
public:
    ...
private:
    set&amp;lt;Message*&amp;gt; messages;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样问题就完美解决了！&lt;/p&gt;
</description>
          <pubDate>2015-11-09T00:00:00+08:00</pubDate>
          <link>/coding/c%E4%B8%AD%E4%B8%A4%E4%B8%AA%E7%B1%BB%E7%9B%B8%E4%BA%92%E5%BC%95%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98.html</link>
          <guid isPermaLink="true">/coding/c%E4%B8%AD%E4%B8%A4%E4%B8%AA%E7%B1%BB%E7%9B%B8%E4%BA%92%E5%BC%95%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98.html</guid>
        </item>
      
    
      
        <item>
          <title>C++【OOP】模板篇</title>
          <description>&lt;h3 id=&quot;section&quot;&gt;友元函数与友元类&lt;/h3&gt;

&lt;p&gt;友元函数可以很方便地处理类的私有数据成员，但是也存在更改私有数据成员值的风险。&lt;/p&gt;

&lt;p&gt;举个栗子：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Coordinate {
    friend void printXY(Coordinate &amp;amp;c);
    //friend void Circle::printXY(Coordinate &amp;amp;c);
public:
    Coordinate(int x, int y);
private:
    int m_iX;
    int m_iY;
};

class Circle {
public:
    void printXY(Coordinate &amp;amp;c) {
        cout &amp;lt;&amp;lt; c.m_iX &amp;lt;&amp;lt; c.m_iY &amp;lt;&amp;lt; endl;
    }
};

void printXY(Coordinate &amp;amp;c) {//直接访问私有成员
    cout &amp;lt;&amp;lt; c.m_iX &amp;lt;&amp;lt; c.m_iY &amp;lt;&amp;lt; endl;
}

int main(void) {
    Coordinate coor(3, 5);
    printXY(coor);
    return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;友元类：使用方法与友元函数类似&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Circle;
class Coordinate {
    friend Circle;
public:
    Coordinate(int x, int y);
private:
    int m_iX;
    int m_iY;
};

class Circle {
public:
    void printXY() {
        cout &amp;lt;&amp;lt; m_coor.m_iX &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; m_coor.m_iY &amp;lt;&amp;lt; endl;
    }
private:
    Coordinate coor;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;友元注意事项：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;友元关系不可传递&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;友元关系的单向性&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;友元声明的形式及数量不受限制&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;友元是作为封装的补充，破坏了封装性。&lt;/strong&gt;在程序架构阶段设计合理是可以避免使用友元的。&lt;/p&gt;

&lt;p&gt;类模板中的友元声明：&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;类模板&lt;/strong&gt;中可以出现三种友元声明，每一种都声明了与一个或多个实体的友元关系：&lt;/p&gt;

&lt;p&gt;1、普通非模板类或函数的友元声明。也即一般的友元声明&lt;/p&gt;

&lt;p&gt;2、类模板或函数模块的友元声明。形式如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;template&amp;lt;typename T&amp;gt; class Foo1;
template&amp;lt;typename Type&amp;gt; class Bar {
	template&amp;lt;typename T&amp;gt; friend class Foo1;
	template&amp;lt;typename T&amp;gt; friend void func();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、只授予对类模板或函数模板的特定实例的访问权的友元声明。形式如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;template&amp;lt;typename T&amp;gt; class Foo1;
template&amp;lt;typename Type&amp;gt; class Bar {
	//只有当Foo1和func()使用与Bar实例同一模板实参时才是友元，当然也可以为Foo1和func()指定特定的形参类型，比如char*
	template&amp;lt;typename Type&amp;gt; friend class Foo1;
	template&amp;lt;typename Type&amp;gt; friend void func();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;static&quot;&gt;静态成员static&lt;/h3&gt;

&lt;p&gt;静态数据成员依赖于类，因此即使没有实例化一个类，也可以使用静态数据成员，使用&lt;code&gt;Class::mem&lt;/code&gt;形式使用。&lt;/p&gt;

&lt;p&gt;不能在静态成员函数中使用非静态数据成员（&lt;strong&gt;因为静态成员函数的参数中不默认包含this指针&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;注意事项：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;静态数据成员必须单独初始化&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;静态成员函数不能调用非静态成员函数和非静态数据成员&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;静态数据成员只有一份，且不依赖对象而存在（例如sizeof(对象)的值不包含静态数据成员）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;运算符重载&lt;/h3&gt;

&lt;p&gt;可以通过友元函数重载、成员函数重载两种方法完成。二者的区别在于成员函数比友元函数少了操作符操作对象本身这个参数。&lt;/p&gt;

&lt;p&gt;但对于«、»操作符只能用友元函数重载，原因是此时的操作符操作对象不可省略。&lt;/p&gt;

&lt;p&gt;[]操作符只能用成员函数重载，原因是参数中必须有this指针。&lt;/p&gt;

&lt;p&gt;形式为&lt;code&gt;Class &amp;amp;operator运算符(){};&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于类Coordinate：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Coordinate {
public:
    Coordinate(int x, int y) {
        m_iX = x;
        m_iY = y;
    }
private:
    int m_iX, m_iY;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如对于+运算符(两种形式)：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;friend Coordinate &amp;amp;operator+(const Coordinate &amp;amp;coor1, const Coordinate &amp;amp;coor2) {
    Coordinate tmp(0, 0);
    tmp.m_iX = coor1.m_iX + coor2.m_iX;
    tmp.m_iY = coor1.m_iY + coor2.m_iY;
    return tmp;
}
Coordinate &amp;amp;operator+(const Coordinate &amp;amp;coor) {
    Coordinate tmp(0, 0);
    tmp.m_iX = this-&amp;gt;m_iX + coor.m_iX;
    tmp.m_iY = this-&amp;gt;m_iY + coor.m_iY;
    return tmp;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于«操作符：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;friend ostream &amp;amp;operator(ostream out, const Coordinate &amp;amp;coor) {
    out &amp;lt;&amp;lt; coor.m_iX &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; coor.m_iY &amp;lt;&amp;lt; endl;
    return out;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于[]操作符：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;int &amp;amp;operator[](int index) {
    if(index == 0) {
        return m_iX;
    }
    if(index == 1) {
        return m_iY;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种形式会引发一个问题，自操作运算符的重载，比如自增运算符++，这里C++规定&lt;code&gt;返回值 &amp;amp;operator++(){}&lt;/code&gt;为前置、
&lt;code&gt;返回值 &amp;amp;operator++(int){}&lt;/code&gt;为后置两种形式来区分&lt;/p&gt;

&lt;p&gt;前置++：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;Coordinate &amp;amp;operator++() {
    ++m_iX;
    ++m_iY;
    return *this;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;后置++：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;Coordinate &amp;amp;operator++(int) {
    Coordinate tmp(*this);
    ++m_iX;
    ++m_iY;
    return tmp;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;函数模板&lt;/h3&gt;

&lt;p&gt;函数模板用来简化下面的操作，提取函数的共同点。&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;int max(int a, int b) { return a &amp;gt; b ? a : b; }
float max(float a, float b) { return a &amp;gt; b ? a : b; }
char max(char a, char b) { return a &amp;gt; b ? a : b; }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关键字：&lt;code&gt;template &amp;lt;typename | class&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;class&lt;/code&gt;与&lt;code&gt;typename&lt;/code&gt;是等效的&lt;/p&gt;

&lt;p&gt;使用class&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;template &amp;lt;class T&amp;gt;
T max(T a, T b) {//函数模板
    return a &amp;gt; b ? a : b;
}

//模板函数
int ival = max(100, 99);//可自动识别参数类型
char cval = max&amp;lt;char&amp;gt;('A', 'B');//也可指定参数类型&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用typename&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;template &amp;lt;typename T&amp;gt;
void swap(T&amp;amp; a, T&amp;amp; b) {
    T tmp = a;
    a = b;
    b = tmp;
}

int x = 20, y = 30;
swap&amp;lt;int&amp;gt;(x, y);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;模板使用参数&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;template &amp;lt;int size&amp;gt;
void display() {
    cout &amp;lt;&amp;lt; size &amp;lt;&amp;lt; endl;
}

display&amp;lt;10&amp;gt;();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;多参数函数模板&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;template &amp;lt;typename T, typename C&amp;gt;
void display(T a, C b) {
    cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl;
}

int a = 1024;
string str = &amp;quot;hello world&amp;quot;;
display&amp;lt;int, string&amp;gt;(a, str);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;typename 和 class作用相同，可以混用&lt;/p&gt;

&lt;p&gt;即：&lt;code&gt;template &amp;lt;typename T, class C&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;函数模板与重载：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;template &amp;lt;typename T&amp;gt;
void display(T a);
display&amp;lt;int&amp;gt;(10);

template &amp;lt;typename T&amp;gt;
void display(T a, T b);
display&amp;lt;int&amp;gt;(10, 20);

template &amp;lt;typename T, int size&amp;gt;
void display(T a);
display&amp;lt;int, 5&amp;gt;(10);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;类模板&lt;/h3&gt;

&lt;p&gt;类模板同函数模板使用方法类似&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;template &amp;lt;class T&amp;gt;
class MyArray {
public:
    void display() {...}
private:
    T *m_pArr;
}

int main(void) {
    MyArray&amp;lt;int&amp;gt; arr;
    arr.display();
    
    return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一般来说类模板的声明与定义需要写在一起，即一个头文件中，之所以不能分离是因为链接的时候，需要实例化类模板，而在main函数中只能找到头文件中的声明，没有定义（定义在.cpp文件中，但是因为类模板是在被使用的时候才会实例化，因此.cpp文件中是未实例化的定义），这样的话就会导致连接错误。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;成员模板&lt;/h3&gt;

&lt;p&gt;任意类（模板类或非模板类）都可以拥有本身为类模板或函数模板的成员，这种成员称为&lt;strong&gt;成员模板&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;template&amp;lt;typename Type&amp;gt; class Queue {
public:
	//成员模板
	template&amp;lt;typename It&amp;gt; Queue(It beg, It end) : head(0), end(0) {
		copy_elems(beg, end);
	}	
	template&amp;lt;typename Iter&amp;gt; void assign(Iter, Iter);
private:
	template&amp;lt;typename Iter&amp;gt; void copy_elems(Iter, Iter);
};

//类外定义形式
template&amp;lt;typename T&amp;gt; template&amp;lt;typename Iter&amp;gt;
void Queue&amp;lt;T&amp;gt;::assign(Iter beg, Iter end) {
	destory();
	copy_elems(beg, end);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-5&quot;&gt;函数模板的特化&lt;/h3&gt;

&lt;p&gt;对于下面这个compare模板函数，如果我们尝试给它传递两个char*的实参，函数将会比较两个指针的大小，而不是我们希望的字符串的大小&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;template&amp;lt;typename T&amp;gt; int compare(const T &amp;amp;v1, const T &amp;amp;v2) {
	if(v1 &amp;lt; v2) return -1;
	if(v2 &amp;lt; v1) return 1;
	return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了方便地解决这种问题，C++引入了&lt;strong&gt;模板特化&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;模板特化：该定义中有一个或多个模板形参的实际类型或实际值是指定的。定义形式如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;关键字template后面接一对空的尖括号&amp;lt;&amp;gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;再接模板名和一对尖括号，尖括号中指定这个特化定义的模板形参&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;例如我们可以将compare函数特化为：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;template&amp;lt;&amp;gt; 
int compare(const char*)(const char* const &amp;amp;v1, const char* const &amp;amp;v2) {
	return strcmp(v1, v2);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样当我们调用compare(“hello”, “world”)时就不会再出错了！当然如果使用其他类型的实参仍会调用compare的通用版本。&lt;/p&gt;

&lt;p&gt;注意&lt;code&gt;template&amp;lt;&amp;gt;&lt;/code&gt;不可省略，否则声明定义的是该函数的重载非模板版本。&lt;/p&gt;

&lt;p&gt;模板类的特化以及模板类的模板成员函数特化与模板函数特化形式上类似。&lt;/p&gt;

&lt;p&gt;上面讲述的是模板的完全特化，对于有多个模板参数的模板类或模板函数我们还可以做到模板的部分特化，比如有类&lt;code&gt;template&amp;lt;typename T, typename U&amp;gt; class EXP&lt;/code&gt;，则我们可以使用&lt;code&gt;template&amp;lt;typename T, string&amp;gt; class EXP&lt;/code&gt;的形式完成模板的部分特化。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;重载与函数模板&lt;/h3&gt;

&lt;p&gt;函数模板可以重载，可以定义有相同名字但形参数目不同或类型不同的多个函数模板，也可以定义与函数模板有相同名字的普通非模板函数。&lt;/p&gt;

&lt;p&gt;C++ OOP特性还可参考本站其他相关博文：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/c%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81.html&quot;&gt;C++ 【oop】封装篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/c-oop%E7%BB%A7%E6%89%BF%E7%AF%87.html&quot;&gt;C++ 【oop】继承篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/coop%E5%A4%9A%E6%80%81%E7%AF%87.html&quot;&gt;C++ 【oop】多态篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
          <pubDate>2015-10-11T00:00:00+08:00</pubDate>
          <link>/coding/coop%E6%A8%A1%E6%9D%BF%E7%AF%87.html</link>
          <guid isPermaLink="true">/coding/coop%E6%A8%A1%E6%9D%BF%E7%AF%87.html</guid>
        </item>
      
    
      
        <item>
          <title>C++【OOP】多态篇</title>
          <description>&lt;h3 id=&quot;section&quot;&gt;多态概念&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;多态：相同对象收到不同消息或不同对象收到相同消息时产生不同的动作（不同对象对相同命令执行不同操作）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;多态可分为静态多态、动态多态。&lt;/p&gt;

&lt;p&gt;静态多态又称为早绑定，编译时已确定，比如函数的重载。&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Rect {
	int calcArea(int width);
	int calcArea(int width, int height);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;动态绑定又称为晚绑定，以封装、继承为基础。可借用虚函数实现。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;虚函数&lt;/h3&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Shape {
public:
    virtual double calcArea() {//虚函数定义需前加关键字virtual
        cout &amp;lt;&amp;lt; &amp;quot;calcArea&amp;quot; &amp;lt;&amp;lt; endl;
        return 0;
    }
};

class Circle: public Shape {
public:
	Circle(double r) {
    		m_dR = r;
    		m_pCenter = new Coordinate(1, 2);
    	}
	[virtual] double calcArea();//继承后virtual关键字可加可不加，但为了易读性，建议加上
private:
	double m_dR;
	Coordinate *m_pCenter;
}

class Rect: public Shape {
public:
	Rect(double width, double height);
	[virtual] double calcArea();
private:
	double m_dWidth;
	double m_dHeight;
}

int main(void) {
	Shape *shape1 = new Circle(4.0);
	Shape *shape2 = new Rect(3.0, 5.0);
	shape1-&amp;gt;calcArea();
	shape2-&amp;gt;calcArea();
	//如果没有virtual，那么调用的都是父类的calcArea()成员函数
	delete shape1;
	delete shape2;
	return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是使用虚函数需要&lt;strong&gt;注意：动态多态可能导致内存泄露&lt;/strong&gt;，这种情况发生在父类指针操作子类虚函数后释放指针销毁子类对象时，只会执行父类的析构函数，从而导致子类中内存泄露。（例如上例中Circle构造函数实例化m_pCenter，m_pCenter为泄露内存）&lt;/p&gt;

&lt;p&gt;为了解决上述问题，可以引进&lt;strong&gt;虚析构函数&lt;/strong&gt;，用&lt;code&gt;virtual&lt;/code&gt;修饰父类析构函数，这样在执行父类的虚析构函数时会先自动调用子类的析构函数。&lt;/p&gt;

&lt;p&gt;对于virtual关键字有以下限制：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;1、不能修饰普通函数（全局函数）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;2、不能修饰静态成员函数&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;3、修饰内联函数时，会使&lt;code&gt;inline&lt;/code&gt;失去作用&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;4、不能修饰构造函数&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于对象的大小，只计算数据成员所占大小，不考虑成员函数。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;虚函数实现原理&lt;/h3&gt;

&lt;p&gt;首先我们需要知道一个概念，当指针指向函数时，实际指向的是函数的入口地址。&lt;/p&gt;

&lt;p&gt;因此虚函数原理：实例化对象时，有一个虚函数表指针成员，指向虚函数表，从而找到虚函数。（&lt;strong&gt;虚函数表指针占用对象开始处的四个字节&lt;/strong&gt;）&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;纯虚函数与抽象类&lt;/h3&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Shape {//抽象类
public:
    	virtual double calcArea() = 0;//纯虚函数
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;纯虚函数的定义即在虚函数的基础上后加&lt;code&gt;= 0&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;抽象类：含有纯虚函数的类。&lt;/p&gt;

&lt;p&gt;抽象类不能实例化对象，抽象类的子类也可以是抽象类。只有当抽象类子类实现了所有的纯虚函数，才可以实例化。&lt;/p&gt;

&lt;p&gt;抽象类、纯虚函数的作用：确保基类不能实例化对象。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;接口类&lt;/h3&gt;

&lt;p&gt;接口类：仅含有纯虚函数的类（成员函数都是纯虚函数）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;接口类更多表达一种能力或协议。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例子如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Flyable {
public:
    virtual void takeoff() = 0;
    virtual void land() = 0;
};

---

class Bird: public Flyable {
public:
    ....
    virtual void takeoff() {...}
    virtual void land() {...}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;rtti-run-time-type-identification&quot;&gt;RTTI（运行时类型识别-&lt;code&gt;Run Time Type Identification&lt;/code&gt;）&lt;/h3&gt;

&lt;p&gt;使用typeid()、dynamic_cast&lt;class&gt;来完成。见下例：&lt;/class&gt;&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Flyable {
public:
    virtual void takeoff() = 0;
    virtual void land() = 0;
};

class Bird: public Flyable {
public:
    void foraging() {...}
    virtual void takeoff() {...}
    virtual void land() {...}
private:
    ... ...
};


class Plane : public Flyable {
public:
    void carry() {...}
    virtual void takeoff() {...}
    virtual void land() {...}
};

void doSomething(Flyable *obj) {
    obj-&amp;gt;takeoff();
    使用RTTI来完成下面的任务：
    cout &amp;lt;&amp;lt; typeid(*obj).name() &amp;lt;&amp;lt; endl;//打印对象类型
    if(typeid(*obj) == typeid(Bird)) {
        Bird *bird = dynamic_cast&amp;lt;Bird *&amp;gt;(obj);//转为Bird指针
        bird-&amp;gt;foraging();
    }
    /*
    if(Bird) obj-&amp;gt;foraging();
    if(Plane) obj-&amp;gt;carry();
    */
    obj-&amp;gt;land();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;dynamic_cast注意事项：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;只能用于指针和引用转换&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;要转换的类型中必须包含虚函数&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;转换成功返回子类地址，失败返回NULL&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;typeid注意事项：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;type_id返回一个type_info对象的引用&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;如果想要通过基类指针指向派生类的数据类型，基类必须带有虚函数&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;只能获取对象的实际类型&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-5&quot;&gt;异常处理&lt;/h3&gt;

&lt;p&gt;异常：程序运行期出现的错误。&lt;/p&gt;

&lt;p&gt;异常处理：对可能发生异常的地方做出预见性的安排。&lt;/p&gt;

&lt;p&gt;C++ OOP特性还可参考本站其他相关博文：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/c%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81.html&quot;&gt;C++ 【oop】封装篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/c-oop%E7%BB%A7%E6%89%BF%E7%AF%87.html&quot;&gt;C++ 【oop】继承篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/coop%E6%A8%A1%E6%9D%BF%E7%AF%87.html&quot;&gt;C++ 【oop】模板篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
          <pubDate>2015-10-06T00:00:00+08:00</pubDate>
          <link>/coding/coop%E5%A4%9A%E6%80%81%E7%AF%87.html</link>
          <guid isPermaLink="true">/coding/coop%E5%A4%9A%E6%80%81%E7%AF%87.html</guid>
        </item>
      
    
      
        <item>
          <title>C++ 【OOP】继承篇</title>
          <description>&lt;h3 id=&quot;oop&quot;&gt;OOP之继承篇&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;继承：&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、公有继承：&lt;code&gt;class A: public B&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、保护继承：&lt;code&gt;class A: protected B&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、私有继承：&lt;code&gt;class A: private B&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;protected在没有继承的情况下含义与private相同&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;公有继承：&lt;/h4&gt;

&lt;p&gt;子类public只能继承父类public部分&lt;/p&gt;

&lt;p&gt;子类protected只能继承父类protected部分&lt;/p&gt;

&lt;p&gt;子类可通过public函数访问protected属性&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于公有继承：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;父类&lt;code&gt;private&lt;/code&gt;成员——————————【子类不可访问】&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;父类&lt;code&gt;protected&lt;/code&gt;成员—————————【继承为子类protected成员】&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;父类&lt;code&gt;public&lt;/code&gt;成员——————————-【继承为子类public成员】&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-2&quot;&gt;保护继承&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于保护继承：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;父类&lt;code&gt;private&lt;/code&gt;成员 ——————————-【子类不可访问】&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;父类&lt;code&gt;protected&lt;/code&gt;成员—————————-【继承为子类protected成员】&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;父类&lt;code&gt;public&lt;/code&gt;成员———————————【继承为子类protected成员】&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-3&quot;&gt;私有继承&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于私有继承：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;父类&lt;code&gt;private&lt;/code&gt;成员 ——————————-【子类不可访问】&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;父类&lt;code&gt;protected&lt;/code&gt;成员—————————-【继承为子类private成员】&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;父类&lt;code&gt;public&lt;/code&gt;成员———————————【继承为子类private成员】&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;protected继承：子类只能访问到自己public下的数据成员、成员函数，而不能访问基类public下的数据成员、成员函数。&lt;/p&gt;

&lt;p&gt;但是可以通过自己的成员函数访问到基类的数据成员及成员函数，也就是说不能直接访问。（因为这些数据成员及成员函数为private）&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;隐藏&lt;/h4&gt;

&lt;p&gt;子类覆盖父类同名成员函数，此时仍然可以访问父类的该函数&lt;/p&gt;

&lt;p&gt;父子关系+成员函数同名，参数不同=隐藏&lt;/p&gt;

&lt;p&gt;父子关系+成员函数同名，参数相同=覆盖&lt;/p&gt;

&lt;p&gt;访问父类成员函数方法：&lt;code&gt;child.Person::func();&lt;/code&gt;(child表示对象，Person表示类，func为父子类同名的成员函数)&lt;/p&gt;

&lt;h4 id=&quot;is-a&quot;&gt;IS A关系&lt;/h4&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;MAN - BOY

BOY b1;
MAN m1 = b1;
MAN *m2 = &amp;amp;b1;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为BOY是MAN的子集&lt;/p&gt;

&lt;p&gt;子类对象赋值给父类对象时，父类对象只能获得二者共有的成员；对于父类指针指向子类对象的情况，指针只能访问共有的成员。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;虚继承&lt;/h4&gt;

&lt;p&gt;菱形继承（含多继承、多重继承）-&amp;gt;数据冗余-&amp;gt;用虚继承解决数据冗余&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%99%9A%E7%BB%A7%E6%89%BF&quot;&gt;维基百科虚继承&lt;/a&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;举例来说：假如类A和类B各自从类X派生（非虚继承且假设类X包含一些数据成员），且类C同时多继承自类A和B，那么C的对象就会拥有两套X的实例数据（可分别独立访问，一般要用适当的消歧义限定符）。但是如果类A与B各自虚继承了类X，那么C的对象就只包含一套类X的实例数据。&lt;/p&gt;

&lt;p&gt;宏定义解决菱形重复引入定义的问题&lt;/p&gt;

&lt;p&gt;在C++中，基类可以通过使用关键字&lt;code&gt;virtual来&lt;/code&gt;声明虚继承关系。&lt;/p&gt;

&lt;h4 id=&quot;chttpwwwcnblogscombeyondanytimearchive201206052537451html&quot;&gt;下文源自：&lt;a href=&quot;http://www.cnblogs.com/BeyondAnyTime/archive/2012/06/05/2537451.html&quot;&gt;关于C++中的虚拟继承的一些总结&lt;/a&gt;&lt;/h4&gt;

&lt;h5 id=&quot;section-6&quot;&gt;1.为什么要引入虚拟继承&lt;/h5&gt;

&lt;p&gt;虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如:类D继承自类B1、B2，而类B1、B2都继承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类。实现的代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class A

class B1:public virtual A;

class B2:public virtual A;

class D:public B1,public B2;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。&lt;/p&gt;

&lt;h5 id=&quot;section-7&quot;&gt;2.引入虚继承和直接继承会有什么区别呢&lt;/h5&gt;

&lt;p&gt;由于有了间接性和共享性两个特征，所以决定了虚继承体系下的对象在访问时必然会在时间和空间上与一般情况有较大不同。&lt;/p&gt;

&lt;p&gt;2.1时间：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在通过继承类对象访问虚基类对象中的成员（包括数据成员和函数成员）时，都必须通过某种间接引用来完成，这样会增加引用寻址时间（就和虚函数一样），其实就是调整this指针以指向虚基类对象，只不过这个调整是运行时间接完成的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.2空间：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于共享所以不必要在对象内存中保存多份虚基类子对象的拷贝，这样较之多继承节省空间。虚拟继承与普通继承不同的是，虚拟继承可以防止出现diamond继承时，一个派生类中同时出现了两个基类的子对象。也就是说，为了保证这一点，在虚拟继承情况下，基类子对象的布局是不同于普通继承的。因此，它需要多出一个指向基类子对象的指针。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C++ OOP特性还可参考本站其他相关博文：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/c%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81.html&quot;&gt;C++ 【oop】封装篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/coop%E5%A4%9A%E6%80%81%E7%AF%87.html&quot;&gt;C++ 【oop】多态篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/coop%E6%A8%A1%E6%9D%BF%E7%AF%87.html&quot;&gt;C++ 【oop】模板篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
          <pubDate>2015-10-06T00:00:00+08:00</pubDate>
          <link>/coding/c-oop%E7%BB%A7%E6%89%BF%E7%AF%87.html</link>
          <guid isPermaLink="true">/coding/c-oop%E7%BB%A7%E6%89%BF%E7%AF%87.html</guid>
        </item>
      
    
      
        <item>
          <title>C++ 【OOP】 封装篇</title>
          <description>&lt;p&gt;最近留校闲暇无事，又看了一些关于C++的教程，感觉收获颇丰。&lt;/p&gt;

&lt;p&gt;主要是关于C++中OOP机制，其实对于其他OOP语言也是适用的。&lt;/p&gt;

&lt;p&gt;先给大家推荐相应的教程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.imooc.com/course/list?c=C+puls+puls&quot;&gt;C++教程-慕课网&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;oop&quot;&gt;OOP之封装&lt;/h2&gt;

&lt;h4 id=&quot;section&quot;&gt;对象在内存中的存储&lt;/h4&gt;

&lt;p&gt;这一块真的很重要啊！！！一直想了解不同代码在内存中的存储，现在终于把它搞清楚了。（多说一句：北航夏令营面试的时候问的都是多态的知识。。。）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;内存中按照用途划分的五个区域：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;1、栈区：变量存储的位置；内存由系统分类、回收。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;2、堆区：当我们new、delete一个对象时，就是在堆区进行操作。堆区的内存有程序员来申请创建、回收&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;3、全局区：存储全局变量、静态变量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;4、常量区：存储常量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;5、代码区：存储逻辑二进制代码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-1&quot;&gt;带有初始化列表的构造函数&lt;/h4&gt;

&lt;p&gt;因为有了封装，因此我们需要一个相对简单的方法来实现构造函数对类变量的初始化。而&lt;code&gt;带有初始化列表的构造函数&lt;/code&gt;与普通构造函数的区别在于：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;code&gt;带有初始化列表的构造函数&lt;/code&gt;可以用来对&lt;code&gt;const&lt;/code&gt;类型变量进行初始化&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;code&gt;带有初始化列表的构造函数&lt;/code&gt;相对于一般构造函数速度上要快一些&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-2&quot;&gt;拷贝构造函数&lt;/h4&gt;

&lt;p&gt;拷贝构造函数作为使用拷贝赋值方式产生新对象的构造函数&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;假设我们有类Student;则如下代码使用默认构造函数对stu1进行初始化，而使用拷贝构造函数对stu2初始化。&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;Student stu1;
Student stu2(stu1);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当采用直接初始化或复制初始化时，系统自动调用拷贝构造函数。&lt;/p&gt;

&lt;p&gt;如果程序员没有定义拷贝构造函数，则当需要适用拷贝构造函数时，由系统自动生成。&lt;/p&gt;

&lt;p&gt;拷贝构造函数定义形式与一般构造函数很相似，形式如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Student(const Student&amp;amp; stu);&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;析构函数&lt;/h4&gt;

&lt;p&gt;既然提到了构造函数，那么同new与delete运算符的关系一样，我们还有析构函数以供对象调用完毕后的善后工作。&lt;/p&gt;

&lt;p&gt;对于以下这个类：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;CPP&quot;&gt;class Student {
public:
        Student() { m_pName = new char[20]; }
private:
         char *m_pName;
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;析构函数的作用就在于处理对象使用结束后的善后工作，比如这里回收&lt;code&gt;m_pName&lt;/code&gt;开辟的空间。&lt;/p&gt;

&lt;p&gt;如果没有自定义的析构函数，则由系统自动生成。&lt;/p&gt;

&lt;p&gt;析构函数在对象销毁时自动调用。&lt;/p&gt;

&lt;p&gt;析构函数没有返回值、没有参数，因此也不可以重载。&lt;/p&gt;

&lt;p&gt;对象的生命历程：
&lt;code&gt;申请内存-&amp;gt;初始化列表-&amp;gt;执行构造函数-&amp;gt;对象参与运算-&amp;gt;执行析构函数-&amp;gt;释放内存&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;类&lt;/h4&gt;

&lt;p&gt;类由成员函数、数据成员组成，可限定命名空间，确保其唯一性。&lt;/p&gt;

&lt;p&gt;类的成员函数中除析构函数外都可以重载&lt;/p&gt;

&lt;p&gt;对象的实例化可分为栈中实例化与堆中实例化&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;前面提到过，栈中实例化即直接定义对象，而堆中实例化则是使用new操作符申请空间创建的对象实例化过程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;变量初始化可分为复制初始化与直接初始化，其中直接初始化是C++在C的基础上的改进&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;复制初始化形如：&lt;code&gt;int x = 12;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;直接初始化形如：&lt;code&gt;int x(12)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-5&quot;&gt;引用&lt;/h4&gt;

&lt;p&gt;引用可以直接理解为别名&lt;/p&gt;

&lt;p&gt;指针类型的引用，举个栗子：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;int a = 10;
int *p = &amp;amp;a;
int *&amp;amp;q = p;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;引用作为函数参数，举个栗子交换两int变量值的函数：&lt;/p&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;void fun(int *a, int *b) {
       int c = 0;
       c = *a;
       *a = *b;
       *b = c;
}

int x = 10, y = 20;
fun(&amp;amp;x, &amp;amp;y);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;void fun(int &amp;amp;a, int &amp;amp;b) {
       int c = 0;
       c = a;
       a = b;
       b = c;
}

int x = 10, y = 20;
fun(x, y);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;c-&quot;&gt;C++ 中的内存管理&lt;/h4&gt;

&lt;p&gt;使用&lt;code&gt;new&lt;/code&gt;运算符来申请内存，使用&lt;code&gt;delete&lt;/code&gt;运算符来释放一段内存。&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;申请释放&lt;strong&gt;一段内存&lt;/strong&gt;形式如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;int *arr = new int[10];
delete []arr;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一般我们申请内存后需要判断是否申请成功，而释放内存后也需要把指针设为空指针&lt;/p&gt;

&lt;h4 id=&quot;const&quot;&gt;对象成员、深拷贝、浅拷贝与const&lt;/h4&gt;

&lt;p&gt;对象成员是指一个类中有其他类成员。&lt;/p&gt;

&lt;p&gt;比如我们定义了一个线段Line类，那么这个线段可以包含两个点Point类。&lt;/p&gt;

&lt;p&gt;当我们实例化对象A时，如果对象A有对象成员B，那么先执行对象B的构造函数，再执行A的构造函数。&lt;/p&gt;

&lt;p&gt;类似与FILO原则，当我们销毁对象A时，先执行对象A的析构函数，再执行B的析构函数&lt;/p&gt;

&lt;p&gt;如果对象A中有对象成员B，对象B没有默认构造函数，那么对象A必须在初始化列表中初始化对象B&lt;/p&gt;

&lt;h5 id=&quot;section-6&quot;&gt;深拷贝与浅拷贝&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于如下例子：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Array {
public:
    Array() { m_iCount = 5; m_pArr = new int[m_iCount]; }
    Array(const Array&amp;amp; arr) { m_iCount = arr.m_iCount; m_pArr = arr.m_pArr; }
private:
    int m_iCount;
    int *m_pArr;
};
int main() {
    Array arr1;
    Array arr2 = arr1;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是一个浅拷贝的例子，执行代码后，对象arr1、arr2的m_pArr指向同一块内存，这就不适用于我们想要实现真正意义上的复制的情况。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;而深拷贝其实很简单，就是我们在拷贝函数中实现深度拷贝，栗子如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Array {
public:
    Array() {m_iCount = 5;}
    Array(const Array&amp;amp; arr) { 
        m_iCount = arr.m_iCount; 
        m_pArr = new int[m_iCount];
        for(int i=0; i&amp;lt;m_iCount; ++i) {
            m_pArr[i] = arr.m_pArr[i];
        }
    }
private:
    int m_iCount;
    int *m_pArr;
};
int main() {
    Array arr1;
    Array arr2 = arr1;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;C++ OOP特性还可参考本站其他相关博文：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/c-oop%E7%BB%A7%E6%89%BF%E7%AF%87.html&quot;&gt;C++ 【oop】继承篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/coop%E5%A4%9A%E6%80%81%E7%AF%87.html&quot;&gt;C++ 【oop】多态篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/coop%E6%A8%A1%E6%9D%BF%E7%AF%87.html&quot;&gt;C++ 【oop】模板篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
          <pubDate>2015-09-23T00:00:00+08:00</pubDate>
          <link>/coding/c%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81.html</link>
          <guid isPermaLink="true">/coding/c%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81.html</guid>
        </item>
      
    
      
        <item>
          <title>python练习册之【0005-改变图片分辨率】</title>
          <description>&lt;p&gt;题目要求：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先我们需要获取图片，可以通过我之前写的&lt;a href=&quot;http://blog.yinwoods.com/coding/python%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0.html&quot;&gt;python实战之爬取网站图片到本地&lt;/a&gt;来获取图片，当然你也可以选择在自己的图片上做实验（&lt;strong&gt;但要记住修改后的图片不要覆盖已有图片&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;谷歌到的iphone5分辨率是1136×640&lt;/p&gt;

&lt;p&gt;这里我用到了PIL库，采取的方法是：&lt;/p&gt;

&lt;p&gt;维持宽和高比例不变的情况下，比较宽、高哪个更接近目标，并调整&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;from PIL import Image
import os

def change_image_size(picpath, bakpath):
    iphone5_size = (640, 1136)
    for cnt in range(0, 59):
        image = Image.open(picpath + &amp;quot;/%s&amp;quot; % cnt + &amp;quot;.jpg&amp;quot;)
        curr_size = image.size
        print(curr_size)
        if(iphone5_size[0]/curr_size[0] &amp;lt; iphone5_size[1]/curr_size[1]):#根据比例进行调整
            if int(curr_size[1]/curr_size[0]*640) &amp;gt; 1136:
                curr_size = iphone5_size
            else:
                curr_size = (640, int(curr_size[1]/curr_size[0]*640))
        else:
            if int(curr_size[0]/curr_size[1]*1136) &amp;gt; 640:
                curr_size = iphone5_size
            else:
                curr_size = (int(curr_size[0]/curr_size[1]*1136), 1136)
        newimg = image.resize(curr_size)
        newimg.save(bakpath + &amp;quot;/%s&amp;quot; % cnt + &amp;quot;.jpg&amp;quot;)

picpath = &amp;quot;D:/imgs_from_yinwoods&amp;quot;#图片所在路径
bakpath = &amp;quot;backup&amp;quot;#目标保存路径
change_image_size(picpath, bakpath)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行代码后可以发现要求是达到了，但是总感觉哪里不对，就像我们在手机中查看图片并不会出现图片拉伸变形的情况。&lt;/p&gt;

&lt;p&gt;因此我在网上搜了下，发现了这篇文章：&lt;a href=&quot;http://www.cnblogs.com/fatway/archive/2010/09/07/resize-pic-by-pil.html&quot;&gt;使用PIL调整图片分辨率&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文章写的很好，代码实现也值得参考，特别是搜索路径内存在的所有图片方法的实现。&lt;/p&gt;

&lt;p&gt;看了下，主要的做法是从图片中截取部分来显示；有兴趣的朋友可以学习下。&lt;/p&gt;
</description>
          <pubDate>2015-09-10T00:00:00+08:00</pubDate>
          <link>/coding/python%E7%BB%83%E4%B9%A0%E5%86%8C%E4%B9%8B0005-%E6%94%B9%E5%8F%98%E5%9B%BE%E7%89%87%E5%88%86%E8%BE%A8%E7%8E%87.html</link>
          <guid isPermaLink="true">/coding/python%E7%BB%83%E4%B9%A0%E5%86%8C%E4%B9%8B0005-%E6%94%B9%E5%8F%98%E5%9B%BE%E7%89%87%E5%88%86%E8%BE%A8%E7%8E%87.html</guid>
        </item>
      
    
      
        <item>
          <title>python练习册之【0004，0006-单词统计】</title>
          <description>&lt;p&gt;题意是统计一个文本中单词出现个数。可以肯定的是涉及到文件操作以及正则匹配。&lt;/p&gt;

&lt;p&gt;这里只是单纯地匹配单词，还是很简单的。我们只要提取出单词的特征就好了（&lt;strong&gt;当然我们默认给定的都是合法的单词&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;另外对正则表达式不太熟悉的朋友可以参考：&lt;a href=&quot;http://blog.yinwoods.com/coding/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0.html&quot;&gt;正则表达式学习&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面上代码，7行代码就可以解决了：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import re

f = open(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;)
regx = re.compile(r&amp;quot;\b[\w']*[^ ]\b&amp;quot;)
regx = regx.findall(f.read())
print(&amp;quot;单词总数为：&amp;quot;, len(regx))
print(regx)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们把单词文本放在in.txt目录下，正则表达式&lt;code&gt;\b[\w']*[^ ]\b&lt;/code&gt;用来匹配所有的单词，这里我们提取的单词特征为：&lt;code&gt;字母、数字、下划线或'出现多次，且不含空格&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;f.read()&lt;/code&gt;读取文本所有内容，&lt;code&gt;findall&lt;/code&gt;进行正则匹配。&lt;/p&gt;

&lt;p&gt;测试内容如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;To ease these woes, public transport app Citymapper has released a new feature that offers advice on which part of the train to get on to shave time off your journey. The Boarding Strategy feature advises users whether they are better to get on the front, middle or back of their train in preparation for the next leg of their journey.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The new feature could also make journeys easier for visitors in unfamiliar cities by helping them make transfers between trains quickly and efficiently.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;According to a post on Citymapper’s blog: ‘In peak hours this will knock minutes off your journey time. We have collected this data as much as we’ve been able to in all our cities.’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The service works when a user searches for a journey and also when using the Citymapper Go mode. A logo appears in the journey advice menu, suggesting which part of the train is best to get on. It also gives Citymapper a new edge when facing competition from search giant Google and Apple Maps.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;However, some users have pointed out that it may lead to already packed carriages becoming even fuller if they are close to exits at popular stations. Plus, the app has still to provide advice that many commuters will be wanting, namely which carriage to get on to increase the chances of getting a seat.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Citymapper is available in 29 cities providing journey advice on trains, trams, buses, underground services and metro lines.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;放到word中可以发现以上共&lt;strong&gt;244&lt;/strong&gt;个单词，下面我们运行python程序&lt;code&gt;python 0004.py &amp;gt; out.txt&lt;/code&gt;，比较结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post31-截图.png&quot; alt=&quot;截图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发现结果匹配成功！&lt;/p&gt;

&lt;p&gt;0006题和0004题比较像，要求是统计每个文件中出现次数最多的单词&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import re

def get_word(diary):
    regx = re.compile(r&amp;quot;\b[\w']*[^ ]\b&amp;quot;)
    content = open(diary, &amp;quot;r&amp;quot;).read()
    regx = regx.findall(content)
    mp = {}
    for cnt in range(0, len(regx)):
        if mp.get(regx[cnt]) != None:
            mp[regx[cnt]] = mp[regx[cnt]] + 1
        else:
            mp[regx[cnt]] = 1
    ls = sorted(mp.items(), key=lambda d:d[1], reverse=True)#按值从大到小对map排序
    print(&amp;quot;The most important word in&amp;quot;, diary, &amp;quot;is \&amp;quot;&amp;quot; + ls[0][0] + &amp;quot;\&amp;quot; and it shows&amp;quot;, ls[0][1], &amp;quot;times.&amp;quot;)

path = (&amp;quot;in1.txt&amp;quot;, &amp;quot;in2.txt&amp;quot;)
for diary in path:
    get_word(diary)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
          <pubDate>2015-09-10T00:00:00+08:00</pubDate>
          <link>/coding/python%E7%BB%83%E4%B9%A0%E5%86%8C%E4%B9%8B0004-%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E4%B8%AA%E6%95%B0.html</link>
          <guid isPermaLink="true">/coding/python%E7%BB%83%E4%B9%A0%E5%86%8C%E4%B9%8B0004-%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E4%B8%AA%E6%95%B0.html</guid>
        </item>
      
    
      
        <item>
          <title>python练习册之【0001，0002-添加数据到mysql】</title>
          <description>&lt;p&gt;第二题的描述为：
&amp;gt; 做为 Apple Store App 独立开发者，你要搞限时促销，为你的应用生成激活码（或者优惠券），使用 Python 如何生成 200 个激活码（或者优惠券）？&lt;/p&gt;

&lt;p&gt;这个题相对上一题就要简单多了（可能是我想简单了），我们控制前五位码不同，再随机生成后面15位码即可。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#0001 - 生成200个激活码
import random

def get_activate_code(num):
    string = &amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot;

    string += string.upper()
    string += &amp;quot;0123456789&amp;quot;#生成字符范围

    for cnt in range(num):
        code = &amp;quot;%05d&amp;quot; % cnt#生成5位数字
        repeat = 15
        while(repeat &amp;gt; 0):
            if(repeat % 5 == 0):#每五位后面加‘-’
                code += '-'
            code += random.choice(string)
            repeat -= 1
        print(code)

get_activate_code(200)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第三题的描述为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;将 0001 题生成的 200 个激活码（或者优惠券）保存到 MySQL 关系型数据库中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先我们要解决包的问题，看到网上很多人用的是MySQLdb包，但我没找到python3版本的，因此去mysql官网&lt;a href=&quot;http://dev.mysql.com/doc/index-connectors.html&quot;&gt;mysql Connector主页&lt;/a&gt;选择Connector/python下载安装就好了&lt;/p&gt;

&lt;p&gt;使用过程当然要借助官方文档了，详见&lt;a href=&quot;http://dev.mysql.com/doc/connector-python/en/connector-python-example-cursor-transaction.html&quot;&gt;python插入mysql数据库示例代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面附上我的代码：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#0002 - 生成200个激活码
import random
import mysql.connector

def get_activate_code(num):
    string = &amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot;

    string += string.upper()
    string += &amp;quot;0123456789&amp;quot;#生成字符范围

    ans = []
    for cnt in range(num):
        code = &amp;quot;%05d&amp;quot; % cnt#生成5位数字
        repeat = 15
        while(repeat &amp;gt; 0):
            if(repeat % 5 == 0):#每五位后面加‘-’
                code += '-'
            code += random.choice(string)
            repeat -= 1
        ans.append(code)
    return ans

def insert_code(query, code):
    conn = mysql.connector.connect(user='root', password='root', host='localhost', database='python')
    cursor = conn.cursor(buffered=True)
    cnt = 0
    cursor.execute(&amp;quot;delete from python&amp;quot;) #删除表python中的所有内容
    for line in code:
        cursor.execute(query, (cnt, line))#插入所有激活码
        cnt += 1
    cursor.execute(&amp;quot;select * from python&amp;quot;)#查看插入结果
    res = cursor.fetchall()
    for line in res:
        print(line)
    conn.commit()
    cursor.close()
    conn.close()

gen_code = get_activate_code(200)
query = (&amp;quot;insert into python&amp;quot;
        &amp;quot;(uid, gen_code)&amp;quot;
        &amp;quot;values (%s, %s)&amp;quot;)
insert_code(query, gen_code)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行&lt;code&gt;python 0001.py &amp;gt; out.txt&lt;/code&gt;，比较打印出的内容与数据库中内容可以发现二者相同，因此程序完成&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post30-截图1.png&quot; alt=&quot;截图&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post30-截图2.png&quot; alt=&quot;截图&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;0003题就跳过去了，因为非关系型数据库没有接触过，这里并不是因为不愿意学习新知识，而是因为如果接触一个新知识，想要系统地学习，而不是走马观花似学习。而且个人觉得mysql能实现，这个难度也不大。&lt;/p&gt;
</description>
          <pubDate>2015-09-09T00:00:00+08:00</pubDate>
          <link>/coding/python%E7%BB%83%E4%B9%A0%E5%86%8C%E4%B9%8B0001-%E7%94%9F%E6%88%90%E6%BF%80%E6%B4%BB%E7%A0%81.html</link>
          <guid isPermaLink="true">/coding/python%E7%BB%83%E4%B9%A0%E5%86%8C%E4%B9%8B0001-%E7%94%9F%E6%88%90%E6%BF%80%E6%B4%BB%E7%A0%81.html</guid>
        </item>
      
    
      
        <item>
          <title>python练习册之【0000-为图片添加文字】</title>
          <description>&lt;p&gt;这几天看了些python的基础教程，感觉好多都是重复的内容，而且本着&lt;code&gt;实践是验证真理的唯一标准&lt;/code&gt;的想法，就找了一套python练习题来做。&lt;/p&gt;

&lt;p&gt;在开始之前想为大家推荐一些我感觉还不错的python教程，希望对大家有所帮助：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、&lt;a href=&quot;http://www.pythondoc.com/pythontutorial3/index.html&quot;&gt;python3.4教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、&lt;a href=&quot;http://www.pythondoc.com/pythontutorial27/index.html&quot;&gt;python2.7教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、&lt;a href=&quot;http://www.imooc.com/view/177&quot;&gt;慕课网python入门教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4、&lt;a href=&quot;https://www.codecademy.com/en/tracks/python&quot;&gt;Codecademy python教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5、&lt;a href=&quot;&quot;&gt;知乎收藏夹-知乎那些事&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;6、还有我正在做的&lt;a href=&quot;https://github.com/Yixiaohan/show-me-the-code&quot;&gt;python练习册&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;言归正传，python练习册的第一道题内容如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。 类似于图中效果&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post29-头像.png&quot; alt=&quot;头像&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实这道题不难，主要是了解PIL(Python Imaging Library)库的使用方法就好了，但问题是这个库官方版只支持python2.+版本，让我这种使用python3.+的感到很头疼。&lt;/p&gt;

&lt;p&gt;所有已经有人解决这个问题了，为python3.+定制了pillow库，其实还是PIL，只是适配了python3.+&lt;/p&gt;

&lt;p&gt;下载地址&lt;a href=&quot;https://pypi.python.org/pypi/Pillow/2.9.0&quot;&gt;轻戳我&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;也可以使用&lt;code&gt;pip install pillow&lt;/code&gt; 或 &lt;code&gt;easy_install pillow&lt;/code&gt;来在线安装&lt;/p&gt;

&lt;p&gt;附官方安装教程&lt;a href=&quot;http://pillow.readthedocs.org/en/latest/installation.html#windows-installation&quot;&gt;pillow installation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载后得到&lt;code&gt;.egg&lt;/code&gt;文件，解压后放到python安装目录下的&lt;code&gt;lib&lt;/code&gt;文件夹下即可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;写博客的时候惊讶地发现linux下自带PIL、pillow包。。。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;下面开始正式解决这个问题吧！&lt;/p&gt;

&lt;p&gt;可能很多人看到题目要求后会想到直接在图片上添加文字，这种想法是很正确的。&lt;/p&gt;

&lt;p&gt;我在这里用了两种方法来做：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、直接在图片右上角添加文字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、先把文字生成一张图片，再合并两张图片&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先上第一份代码：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#0000-为图片添加水印
from PIL import Image, ImageFilter, ImageFont, ImageDraw

def draw_str(img_pos, font_pos, text):#传入待绘画图片位置，
    #img_pos 为待绘画图片位置，font_pos为想要使用的字体路劲，text为想要添加的文字
    image = Image.open(img_pos)#打开图片
    dr = ImageDraw.Draw(image)
    font = ImageFont.truetype(font_pos, 40)#设置加载字体位置，以及字体大小
    dr.text((image.size[0]-50, 0), text, font=font, fill=&amp;quot;#FF0000&amp;quot;)#设置添加位置、添加内容、以及颜色
    image.save(&amp;quot;复件&amp;quot; + img_pos)#另存为
    #image.show()

draw_str(&amp;quot;1.png&amp;quot;, &amp;quot;/usr/share/fonts/truetype/ubuntu-font-family/Ubuntu-R.ttf&amp;quot;, &amp;quot;1&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注释地比较详细了，其实就是函数的调用而已。&lt;/p&gt;

&lt;p&gt;再来第二份代码：&lt;/p&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#0000-为图片添加水印
from PIL import Image, ImageFilter, ImageFont, ImageDraw

def draw_str(img_pos, font_pos, text):#同上
    backimg = Image.open(img_pos)
    foreimg = Image.new(&amp;quot;RGB&amp;quot;, (35, 35), (255, 255, 255))#生成一个新图片，设置大小，背景色

    dr = ImageDraw.Draw(foreimg)
    font = ImageFont.truetype(font_pos, 40)
    dr.text((10, 5), text, font=font, fill=&amp;quot;#FF0000&amp;quot;)#先把文字添加在这张新建图片上
    foreimg.save('2.png')
    foreimg = Image.open('2.png')
    backimg.paste(foreimg, (backimg.size[0]-50, 0))#合并图片
    backimg.show()
    backimg.save(&amp;quot;复件&amp;quot;+img_pos)


draw_str('1.png', '/usr/share/fonts/truetype/ubuntu-font-family/Ubuntu-R.ttf', '1')&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;附效果：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原图片：&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post29-原图片.png&quot; alt=&quot;原图片&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;中间产生图片：&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post29-中间图片.png&quot; alt=&quot;中间图片&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;最终结果：&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post29-新图片.png&quot; alt=&quot;新图片&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
          <pubDate>2015-09-09T00:00:00+08:00</pubDate>
          <link>/coding/python%E7%BB%83%E4%B9%A0%E5%86%8C%E4%B9%8B0000-%E4%B8%BA%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E6%96%87%E5%AD%97.html</link>
          <guid isPermaLink="true">/coding/python%E7%BB%83%E4%B9%A0%E5%86%8C%E4%B9%8B0000-%E4%B8%BA%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E6%96%87%E5%AD%97.html</guid>
        </item>
      
    
      
        <item>
          <title>sublime基本配置</title>
          <description>&lt;p&gt;这几天一直在捯饬linux系统，免不了重装了几次，每次装好都要配置sublime。查资料的过程真是无限头痛啊，特意开这篇博客以备不时之需。&lt;/p&gt;

&lt;p&gt;首先从管网下载sublime3安装包，基于ubuntu的linux可以直接装，其他的也有办法，这个比较简单，就不多说了。&lt;/p&gt;

&lt;p&gt;安装完成之后首先输入注册码，免得时不时地提醒（博主穷学生一枚，鼓励有能力的同学去买&lt;a href=&quot;https://www.sublimetext.com/buy&quot;&gt;购买地址&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;在网上搜集的一份注册码如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
—– BEGIN LICENSE —–
Michael Barnes
Single User License
EA7E-821385
8A353C41 872A0D5C DF9B2950 AFF6F667
C458EA6D 8EA3C286 98D1D650 131A97AB
AA919AEC EF20E143 B361B1E7 4C8B7F04
B085E65E 2F5F5360 8489D422 FB8FC1AA
93F6323C FD7F7544 3F39C318 D95E6480
FCCC7561 8A4A1741 68FA4223 ADCEDE07
200C25BE DBBC4855 C4CFB774 C5EC138C
0FEC1CEF D9DCECEC D3A5DAD1 01316C36
—— END LICENSE ——
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注册成功之后，我们要解决linux下sublime不能输入中文的问题
这里我主要参考了以下两篇文章：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、&lt;a href=&quot;http://blog.isming.me/2014/03/15/jie-jue-ubuntuxia-sublime-text-3zhong-wen-shu-ru-de-wen-ti/&quot;&gt;解决Ubuntu下Sublime text 3中文输入的问题&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、&lt;a href=&quot;http://jingyan.baidu.com/article/f3ad7d0ff8731609c3345b3b.html&quot;&gt;Ubuntu下Sublime Text 3解决无法输入中文的方法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这两篇文章只有一起看才可以起效果。。。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1、首先我们在sublime安装目录下&lt;code&gt;/opt/sublime_text/&lt;/code&gt;创建sublime_imfix.c如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;CPP&quot;&gt;/*
sublime-imfix.c

Use LD_PRELOAD to interpose some function to fix sublime input method support for linux.

By Cjacker Huang &amp;lt;jianzhong.huang at i-soft.com.cn&amp;gt;

gcc -shared -o libsublime-imfix.so sublime_imfix.c  `pkg-config --libs --cflags gtk+-2.0` -fPIC

LD_PRELOAD=./libsublime-imfix.so sublime_text
*/

#include &amp;lt;gtk/gtk.h&amp;gt;

#include &amp;lt;gdk/gdkx.h&amp;gt;

typedef GdkSegment GdkRegionBox;

struct _GdkRegion
{
      long size;
      long numRects;
      GdkRegionBox *rects;
      GdkRegionBox extents;
};

GtkIMContext *local_context;

void
gdk_region_get_clipbox (const GdkRegion *region,
        GdkRectangle    *rectangle)
{    
      g_return_if_fail (region != NULL);
      g_return_if_fail (rectangle != NULL);

      rectangle-&amp;gt;x = region-&amp;gt;extents.x1;
      rectangle-&amp;gt;y = region-&amp;gt;extents.y1;
      rectangle-&amp;gt;width = region-&amp;gt;extents.x2 - region-&amp;gt;extents.x1;
      rectangle-&amp;gt;height = region-&amp;gt;extents.y2 - region-&amp;gt;extents.y1;
      GdkRectangle rect;
      rect.x = rectangle-&amp;gt;x;
      rect.y = rectangle-&amp;gt;y;
      rect.width = 0;
      rect.height = rectangle-&amp;gt;height; 
      //The caret width is 2; 
      //Maybe sometimes we will make a mistake, but for most of the time, it should be the caret.
      if(rectangle-&amp;gt;width == 2 &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(local_context)) {
        gtk_im_context_set_cursor_location(local_context, rectangle);
      }
}

//this is needed, for example, if you input something in file dialog and return back the edit area
//context will lost, so here we set it again.

static GdkFilterReturn event_filter (GdkXEvent *xevent, GdkEvent *event, gpointer im_context)
{
    XEvent *xev = (XEvent *)xevent;
    if(xev-&amp;gt;type == KeyRelease &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(im_context)) {
           GdkWindow * win = g_object_get_data(G_OBJECT(im_context),&amp;quot;window&amp;quot;);
           if(GDK_IS_WINDOW(win))
             gtk_im_context_set_client_window(im_context, win);
    }
    return GDK_FILTER_CONTINUE;
}

void gtk_im_context_set_client_window (GtkIMContext *context,
      GdkWindow    *window)
{
      GtkIMContextClass *klass;
      g_return_if_fail (GTK_IS_IM_CONTEXT (context));
      klass = GTK_IM_CONTEXT_GET_CLASS (context);
      if (klass-&amp;gt;set_client_window)
    klass-&amp;gt;set_client_window (context, window);

      if(!GDK_IS_WINDOW (window))
    return;
      g_object_set_data(G_OBJECT(context),&amp;quot;window&amp;quot;,window);
      int width = gdk_window_get_width(window);
      int height = gdk_window_get_height(window);
      if(width != 0 &amp;amp;&amp;amp; height !=0) {
        gtk_im_context_focus_in(context);
        local_context = context;
      }
      gdk_window_add_filter (window, event_filter, context); 
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;2、安装C/C++的编译环境和gtk libgtk2.0-dev&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;sudo    apt-get install build-essential

sudo apt-get install libgtk2.0-dev&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;3、编译共享内存&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;gcc -shared -o libsublime-imfix.so sublime_imfix.c  `pkg-config --libs --cflags gtk+-2.0` -fPIC&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;4、启动测试&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;
export LD_PRELOAD=./libsublime-imfix.so sublime_text
&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;5、修改我们的desktop文件，使图标也可以使用，内容如下（&lt;strong&gt;注意路径&lt;/strong&gt;）:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;
sudo vim /usr/share/applications/sublime-text.desktop
&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;[Desktop Entry]
Version=1.0
Type=Application
Name=Sublime Text
GenericName=Text Editor
Comment=Sophisticated text editor for code, markup and prose
Exec=bash -c &amp;quot;LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text %F&amp;quot;
Terminal=false
MimeType=text/plain;
Icon=sublime-text
Categories=TextEditor;Development;
StartupNotify=true
Actions=Window;Document;
[Desktop Action Window]
Name=New Window
Exec=bash -c &amp;quot;LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text -n&amp;quot;
OnlyShowIn=Unity;
[Desktop Action Document]
Name=New File
Exec=bash -c &amp;quot;LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text --command new_file&amp;quot;
OnlyShowIn=Unity;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;6、修改文件/usr/bin/subl的内容，将文件内容替换为（&lt;strong&gt;注意路径&lt;/strong&gt;）：&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;#!/bin/sh

LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text &amp;quot;$@&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面就开始配置我们的神器插件&lt;code&gt;Package Control&lt;/code&gt;了&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;1、&lt;code&gt;ctrl+～&lt;/code&gt;（Esc下面那个键）同时按住，弹出一个输入框，粘贴下面代码，回车。我使用的版本是sublime text3.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;2、&amp;lt;div&amp;gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;3、附带sublime text2的代码：&amp;lt;div&amp;gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;import urllib2,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), 'wb' ).write(by) if dh == h else None; print('Error validating download (got %s instead of %s), please try manual install' % (dh, h) if dh != h else 'Please restart Sublime Text to finish installation')&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;下面就可以通过&lt;code&gt;Package Control&lt;/code&gt;安装各种插件了&lt;/p&gt;
</description>
          <pubDate>2015-09-07T00:00:00+08:00</pubDate>
          <link>/coding/sublime%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE.html</link>
          <guid isPermaLink="true">/coding/sublime%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE.html</guid>
        </item>
      
    
      
        <item>
          <title>python实战之郑州大学GPA计算器</title>
          <description>&lt;p&gt;最近在学习爬虫的过程中，读了不少相关博文，感觉收获良多。&lt;/p&gt;

&lt;p&gt;前两天刚刚动手写了一个爬取郑州大学个人成绩并计算平均绩点的程序，特意拿到这里来与大家分享。&lt;/p&gt;

&lt;p&gt;虽然写的是针对郑州大学教务系统的爬虫，但我相信只要稍作修改就可以应用于多数大学的教务系统了。&lt;/p&gt;

&lt;p&gt;首先说一下程序执行的过程：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、打开教务系统登录界面，获取相应的&lt;code&gt;url&lt;/code&gt;以及表单域需要填写选项的名称。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、填写必要信息、设置&lt;code&gt;cookie&lt;/code&gt;，模拟浏览器登录系统&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、利用正则表达式获取不同学期成绩页面对应的&lt;code&gt;url&lt;/code&gt;，并保存。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4、循环打开刚刚保存的不同学期成绩页面的&lt;code&gt;url&lt;/code&gt;，利用正则表达式匹配课程、成绩信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5、计算平均绩点并输出&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从上面的流程可以看出，整个过程涉及到的比较复杂的地方只有登录以及正则表达式的匹配，下面我们一步一步实现我们的需求。&lt;/p&gt;

&lt;p&gt;为了很好地讲解操作步骤，我们先设计一个类，名字叫做&lt;code&gt;ZZU&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;并设置以下成员：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#部分ZZU类成员
		self.cookies 	#cookie
		self.size = 0   #总课程数目
		self.courses = []   #课程名称
		self.courses_Attribute = []     #课程类型
		self.credits = []    #课程学分
		self.grades = []    #课程成绩
		self.points = []    #课程绩点
		self.urls_Set = []  #各学期成绩URL页面集合&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;url&quot;&gt;第一步：获取登录页面&lt;code&gt;url&lt;/code&gt;及表单信息&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;打开教务系统，进入登录界面，利用&lt;code&gt;F12&lt;/code&gt;查看网页源码信息，提取表单域内容：&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post27-教务1.png&quot; alt=&quot;教务系统&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post27-教务2.png&quot; alt=&quot;教务系统&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;从上面的图片可以看出，我们需要填写的内容有：&lt;code&gt;nianji（年级）&lt;/code&gt;、&lt;code&gt;xuehao（学号）&lt;/code&gt;、&lt;code&gt;mima（密码）&lt;/code&gt;、&lt;code&gt;selec（登录页面）&lt;/code&gt;几个选项，在这里我们选择令&lt;code&gt;selec&lt;/code&gt;为&lt;code&gt;http://jw.zzu.edu.cn/scripts/qscore.dll/search&lt;/code&gt;即进入选课系统。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;因此我们可以为&lt;code&gt;ZZU&lt;/code&gt;添加一个变量叫做&lt;code&gt;postdata&lt;/code&gt;用来存储以上信息，内容为：&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#ZZU类登录表单信息
	self.current_Url = http://jw.zzu.edu.cn/scripts/qscore.dll/search
	self.postdata = urllib.parse.urlencode({
            'nianji': '',
            'xuehao': '',
            'mima': '',
            'selec': 'http://jw.zzu.edu.cn/scripts/qscore.dll/search'
        }).encode()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;cookie&quot;&gt;第二步：设置&lt;code&gt;cookie&lt;/code&gt;并登录&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;这里可能看起来比较难，其实只用调用相关函数即可&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#ZZU类cookie
	self.cookies = http.cookiejar.CookieJar()	#设置cookie
	self.opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(self.cookies))
	request = urllib.request.Request(
        url = self.current_Url,
        data = self.postdata
    )
    res = self.opener.open(request)	#提交表单内容，登录系统
    print(res.read().decode('GBK'))	#可以发现打印的网页源码为登录后的源码，说明登录成功&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;url-1&quot;&gt;第三步：利用正则表达式获取所有学期页面的&lt;code&gt;url&lt;/code&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;这里需要我们能够有效提取出所有学期页面&lt;code&gt;url&lt;/code&gt;的共同特征，之后才能完成匹配&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post27-教务3.png&quot; alt=&quot;教务系统&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;对于我校郑州大学的系统，可以发现不同学期&lt;code&gt;url&lt;/code&gt;只是&lt;code&gt;search?userid=&lt;/code&gt;后面的参数不同而已；因此我们可以利用&lt;code&gt;regx = re.compile('href=&quot;(http://jw.zzu.edu.cn/scripts/qscore.dll/search.*?)&quot;&amp;gt;')&lt;/code&gt;来匹配所有的&lt;code&gt;url&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;regx = re.compile('href=&amp;quot;(http://jw.zzu.edu.cn/scripts/qscore.dll/search.*?)&amp;quot;&amp;gt;')&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;第四步：利用正则表达式获取课程、成绩相关信息&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;同上一步，我们先来提取课程、成绩信息的特征，&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post27-教务4.png&quot; alt=&quot;教务系统成绩特征&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;可以发现课程、成绩信息是分别被五个&lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;标签包住的，因此我们可以这样匹配&lt;code&gt;re.compile('&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;', re.U)&lt;/code&gt;,不了解&lt;code&gt;re.U&lt;/code&gt;含义的可以移步这里&lt;a href=&quot;http://blog.yinwoods.com/coding/python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.html&quot;&gt;python爬虫基础教程&lt;/a&gt;巩固下。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#ZZU类匹配课程、成绩信息
	regx = re.compile('&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;', re.U)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;第五步：计算平均绩点&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;想一下，如果我们能获得一学期的所有成绩，那么我们就一定可以获取所有学期成绩，从而计算&lt;code&gt;GPA&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面说的零零碎碎，可能不是很清楚，下面附上完整代码以及必要注释：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import urllib
import urllib.request
import http.cookiejar
import re

from collections import deque

class ZZU:
    def __init__(self):
        self.cookies = http.cookiejar.CookieJar()
        self.postdata = urllib.parse.urlencode({
            'nianji': '',    #填写你的年级
            'xuehao': '',    #填写你的学号
            'mima': '',      #填写你的密码
            'selec': 'http://jw.zzu.edu.cn/scripts/qscore.dll/search'
            }).encode()
        self.size = 0   #课程数目
        self.opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(self.cookies))
        self.courses = []   #课程名称
        self.courses_Attribute = []     #课程类型
        self.credits = []    #课程学分
        self.grades = []    #课程成绩
        self.points = []    #课程绩点
        self.urls_Set = []  #各学期成绩URL页面集合


    def getPage(self):
        request = urllib.request.Request(
                url = self.current_Url,
                data = self.postdata
                )
        res = self.opener.open(request)
        return res.read().decode('GBK')


    def getGrades(self):
        self.size = 0
        for url in zzu.urls_Set:
            self.current_Url = url
            page = self.getPage()

            #提取成绩表每行信息
            regx = re.compile('&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;&amp;lt;td.*?&amp;gt;(.*?)&amp;lt;/td&amp;gt;', re.U)
            myItems = regx.findall(page)
            for item in myItems:
                self.size += 1      #保存数量
                self.courses.append(item[0])
                self.courses_Attribute.append(item[1])
                self.credits.append(item[2])
                self.grades.append(item[3])
                self.points.append(item[4])

        cnt = 0
        sum_credits = 0
        sum_points = 0.0
        while(cnt &amp;lt; self.size):
            if self.points[cnt] != '---': #没有绩点的课程不计在内
                sum_credits += float(self.credits[cnt])
                sum_points += float(self.credits[cnt])*float(self.points[cnt])
            cnt += 1
        print(&amp;quot;大学期间总学分： &amp;quot; + str(sum_credits))
        print(&amp;quot;大学期间总绩点：&amp;quot; + str(sum_points))
        print(&amp;quot;大学期间平均绩点为：&amp;quot; + str(sum_points/sum_credits))

    def print_info(self):   #打印所有课程信息
        regx = re.compile('姓名：(.*?)&amp;amp;')
        name = regx.findall(self.getPage())
        print(&amp;quot;我叫&amp;quot; + name[0])
        print(&amp;quot;大学期间共学习&amp;quot; + str(self.size) + &amp;quot;门课程&amp;quot;)
        print(&amp;quot;课程&amp;quot;.ljust(14) + &amp;quot;\t&amp;quot; + &amp;quot;类型&amp;quot; + &amp;quot;\t&amp;quot; + &amp;quot;学分&amp;quot; + &amp;quot;\t&amp;quot; + &amp;quot;成绩&amp;quot; + &amp;quot;\t&amp;quot; + &amp;quot;绩点&amp;quot;)
        for num in range(0, self.size):
            print(self.courses[num][0:8].ljust(6) + &amp;quot;\t&amp;quot; + self.courses_Attribute[num] + &amp;quot;\t&amp;quot; + self.credits[num] + &amp;quot;\t&amp;quot; + self.grades[num].rjust(3) + &amp;quot;\t&amp;quot; + self.points[num])


url = 'http://jw.zzu.edu.cn/scripts/qscore.dll/search'
zzu = ZZU()
zzu.current_Url = url
regx = re.compile('href=&amp;quot;(http://jw.zzu.edu.cn/scripts/qscore.dll/search.*?)&amp;quot;&amp;gt;')
List = regx.search(zzu.getPage())
url = List.group()[6:-2] #截取url

zzu.urls_Set.append(url)

zzu.current_Url = url
page = zzu.getPage()
regx = re.compile('href=&amp;quot;(http://jw.zzu.edu.cn/scripts/qscore.dll/search.*?)&amp;quot;&amp;gt;')
zzu.urls_Set += regx.findall(page)

zzu.getGrades()
#zzu.print_info()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面是我的GPA查询结果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post27-教务5.png&quot; alt=&quot;教务系统&quot; /&gt;&lt;/p&gt;
</description>
          <pubDate>2015-09-05T00:00:00+08:00</pubDate>
          <link>/coding/python%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%91%E5%B7%9E%E5%A4%A7%E5%AD%A6GPA%E8%AE%A1%E7%AE%97%E5%99%A8.html</link>
          <guid isPermaLink="true">/coding/python%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%91%E5%B7%9E%E5%A4%A7%E5%AD%A6GPA%E8%AE%A1%E7%AE%97%E5%99%A8.html</guid>
        </item>
      
    
      
        <item>
          <title>python爬虫基础教程</title>
          <description>&lt;h3 id=&quot;section&quot;&gt;爬虫&lt;/h3&gt;

&lt;p&gt;首先上爬虫的定义：&lt;code&gt;网络爬虫是一种自动获取网页内容的程序，是搜索引擎的重要组成部分。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;嗯，按照我的理解就是爬虫程序就是能够提取网页中信息的程序&lt;/p&gt;

&lt;p&gt;我也是这两天才开始学爬虫，这篇教程参考了网上的很多资源，希望能给有需要的人以帮助。&lt;/p&gt;

&lt;p&gt;在各位看官开始学习之前想向大家介绍几篇文章，请大家认真阅读，这样上手&lt;code&gt;python&lt;/code&gt;爬虫就会事半功倍了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、&lt;a href=&quot;http://www.zhihu.com/question/20899988&quot;&gt;如何入门Python爬虫 — from 知乎&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、&lt;a href=&quot;http://www.zhihu.com/question/21358581&quot;&gt;你是如何开始能写python爬虫？ — from 知乎&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、&lt;a href=&quot;http://blog.jobbole.com/77821/&quot;&gt;零基础自学用Python 3开发网络爬虫&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我很大程度上是按照上面介绍的第三篇博客入门&lt;code&gt;python&lt;/code&gt;爬虫的。&lt;/p&gt;

&lt;h3 id=&quot;python&quot;&gt;Python介绍&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Python&lt;/code&gt;（英国发音：&lt;code&gt;/ˈpaɪθən/&lt;/code&gt; 美国发音：&lt;code&gt;/ˈpaɪθɑːn/&lt;/code&gt;），是一种面向对象、直译式的计算机程序语言，具有近二十年的发展历史。它包含了一组功能完备的标准库，能够轻松完成很多常见的任务。它的语法简单，与其它大多数程序设计语言使用大括号不一样，它使用缩进来定义语句块。&lt;a href=&quot;https://zh.wikipedia.org/wiki/Python&quot;&gt;— 来自于维基百科&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;另外该篇博客适用于有高等语法基础（不需要必须是&lt;code&gt;python&lt;/code&gt;）的朋友，没有语法基础的朋友可以去&lt;a href=&quot;http://www.imooc.com/learn/177&quot;&gt;慕课网&lt;/a&gt;或&lt;a href=&quot;https://www.codecademy.com/en/tracks/python&quot;&gt;codecademy&lt;/a&gt;学习下&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;工欲善其事必先利其器&lt;/h3&gt;

&lt;p&gt;在学习&lt;code&gt;python&lt;/code&gt;的过程中，不得不面临&lt;code&gt;python 2.+&lt;/code&gt;或&lt;code&gt;python 3.+&lt;/code&gt;的选择，个人觉得既然是出于学习的目的，当然要学习新知识，因此我选择了&lt;code&gt;python 3.4&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;个人使用体会：&lt;code&gt;python3.+&lt;/code&gt;在&lt;code&gt;python2.+&lt;/code&gt;的基础上对包又进行了一些整合，语法略有些变化，可能因为现在我涉及的层面还比较浅，并未感觉两个版本之间有太大的不同。&lt;/p&gt;

&lt;p&gt;可以通过&lt;a href=&quot;https://www.python.org/&quot;&gt;官网&lt;/a&gt;安装&lt;code&gt;python 3.4&lt;/code&gt;；附&lt;a href=&quot;https://www.python.org/&quot;&gt;&lt;code&gt;python&lt;/code&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我们现在的目标是实现一个可以从一个链接开始爬取所有相关链接的爬虫&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;1、从给定链接开始，维持一个待爬取队列，以及一个已访问链接集合&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;2、每次从队列中弹出一条链接并打开，对于该链接对应页面，用正则表达式匹配页面内所有的链接，&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;3、对这些链接进行判断，如果已经被爬虫爬过，则跳过，否则加入待爬取队列&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;4、重复2,3步，直到队列为空，说明所有链接均已被爬取&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;话不多说，下面通过8个程序来学习&lt;code&gt;python&lt;/code&gt;爬虫吧&lt;/p&gt;

&lt;h4 id=&quot;python-11&quot;&gt;python教程-1.1&lt;/h4&gt;

&lt;p&gt;python中使用&lt;code&gt;#&lt;/code&gt;注释，多行注释使用快捷键&lt;code&gt;Alt+3&lt;/code&gt;，消除多行注释使用快捷键&lt;code&gt;Alt+4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面这个小程序的功能是打开一个网页并读取网页源码&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import urllib
import urllib.request

url = &amp;quot;http://baidu.com&amp;quot;

html = urllib.request.urlopen(url)	#打开url链接

html = html.read().decode('utf-8')	#以utf-8编码格式对所读取页面进行解码

print(html)		#打印网页源码&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;python-12&quot;&gt;python教程-1.2&lt;/h4&gt;

&lt;p&gt;使用下面这个程序实现python中我们需要的队列
deque的相关内容可参见C++或java中deque的定义&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#利用deque模拟Queue
from collections import deque

queue = deque([&amp;quot;Eric&amp;quot;, &amp;quot;John&amp;quot;, &amp;quot;Michael&amp;quot;])
queue.append(&amp;quot;Terry&amp;quot;)
queue.append(&amp;quot;Graham&amp;quot;)
print(queue.popleft())
print(queue.popleft())
print(queue)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;python-13&quot;&gt;python教程-1.3&lt;/h4&gt;

&lt;p&gt;下面这个小程序是为了演示&lt;code&gt;set&lt;/code&gt;功能，类似于数学中集合的定义，每个元素具有唯一性。&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#演示set功能
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket)

print('orange' in basket)

print('crabgrass' in basket)

a = set('abracadabra')
b = set('alacazam')

print(a)
print(a-b)
print(a|b)
print(a&amp;amp;b)
print(a^b)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;python-14&quot;&gt;python教程-1.4&lt;/h4&gt;

&lt;p&gt;程序演示python中正则表达式应用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;re.match(pattern, string, flags=0)&lt;/code&gt;实现按照&lt;code&gt;pattern&lt;/code&gt;的模式匹配&lt;code&gt;string&lt;/code&gt;，&lt;code&gt;flags&lt;/code&gt;是附加标志位；&lt;/p&gt;

&lt;p&gt;同理&lt;code&gt;re.search(pattern, string, flags=0)&lt;/code&gt;实现搜索功能 ；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;re.sub(pattern, string, flags=0)&lt;/code&gt;实现替换功能。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;re.match()&lt;/code&gt;与&lt;code&gt;re.search()&lt;/code&gt;区别在于&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;如果&lt;code&gt;re.match()&lt;/code&gt;在匹配字符串开始的过程中失败就会终止匹配&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;code&gt;re.search()&lt;/code&gt;则会从字符串开始到结尾尝试匹配&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;有不懂或者遗忘正则表达式的朋友请点这里：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;1、&lt;a href=&quot;http://blog.yinwoods.com/coding/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0.html&quot;&gt;正则表达式教程&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;2、&lt;a href=&quot;http://blog.jobbole.com/75188/&quot;&gt;&lt;code&gt;python&lt;/code&gt;正则表达式学习&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;flag含义:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、 &lt;code&gt;re.I&lt;/code&gt; 大小写不敏感&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、 &lt;code&gt;re.L&lt;/code&gt; 本地化识别匹配&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、 &lt;code&gt;re.M&lt;/code&gt; 多行匹配&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4、 &lt;code&gt;re.S&lt;/code&gt; 使.能够匹配换行符&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5、 &lt;code&gt;re.U&lt;/code&gt; 根据Unicode解析字符&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外也可以使用&lt;code&gt;re.compile(pattern).findall(string)&lt;/code&gt;来查找所有匹配，会返回所有匹配结果，并且结果保存在&lt;code&gt;列表&lt;/code&gt;中（后面会有具体的栗子）&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#re.match(pattern, string, flags=0)
import re

line = &amp;quot;Cats are smarter than dogs&amp;quot;

matchObj = re.match(r'(.*) are (.*?) .*', line, re.M|re.I)

if matchObj:
    print(matchObj.group())
    print(matchObj.group(1))
    print(matchObj.group(2))
else:
    print(&amp;quot;No match!!&amp;quot;)

#演示python中正则表达式搜索应用
#re.search(pattern, string, flags=0)
matchObj = re.search(r'(.*) are (.*?) .*', line, re.M|re.I)
if matchObj:
    print(matchObj.group())
    print(matchObj.group(1))
    print(matchObj.group(2))
else:
    print(&amp;quot;No match!!&amp;quot;)

#演示python中正则表达式替换应用
#re.sub(pattern, repl, string, max=0)
phone = &amp;quot;2004-959-559 # This is Phone Number&amp;quot;

num = re.sub(r'#.*$', &amp;quot;&amp;quot;, phone)
print(&amp;quot;Phone Num : &amp;quot;, num)

num = re.sub(r'\D', &amp;quot;&amp;quot;, phone)
print(&amp;quot;Phone Num : &amp;quot;, num)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;python-15&quot;&gt;python教程-1.5&lt;/h4&gt;

&lt;p&gt;目标的实现：下面的程序即实现了我们开始要求的功能，当然想把所有链接都爬取是需要时间的。。。当你觉得不需要再爬的时候可以中断程序&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#简单爬虫
import re
import urllib.request
import urllib

from collections import deque

queue = deque()
visited = set()

url = &amp;quot;http://www.baidu.com&amp;quot;

queue.append(url)
cnt = 0

while queue:	#当队列不为空
    url = queue.popleft()
    visited |= {url}	#加入visited集合中
    print('I\'v got :' + str(cnt))
    print('I\'m getting ' + url)
    cnt += 1;
    urlop = urllib.request.urlopen(url)
    if 'html' not in urlop.getheader('Content-Type'):	#避免爬取非网页url的链接，比如文件地址
        continue
    try:
        data = urlop.read().decode('utf-8')	#过滤掉不能正确读取的页面，避免程序异常中断
    except:
        continue

    linkre = re.compile('href=\&amp;quot;(.+?)\&amp;quot;')
    for x in linkre.findall(data):
        if 'http' in x and x not in visited:	#找出匹配后未访问过的链接
            queue.append(x)
            print('appending ---&amp;gt; ' + x)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上就是该篇博客所有内容了，如有未尽兴的朋友，请移步：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、&lt;a href=&quot;http://blog.yinwoods.com/coding/python%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0.html&quot;&gt;python实战之爬取网站图片到本地&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、&lt;a href=&quot;http://blog.yinwoods.com/coding/python%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%91%E5%B7%9E%E5%A4%A7%E5%AD%A6GPA%E8%AE%A1%E7%AE%97%E5%99%A8.html&quot;&gt;python实战之郑州大学GPA计算器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
          <pubDate>2015-09-03T00:00:00+08:00</pubDate>
          <link>/coding/python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.html</link>
          <guid isPermaLink="true">/coding/python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.html</guid>
        </item>
      
    
      
        <item>
          <title>python实战之爬取网站图片到本地</title>
          <description>&lt;p&gt;下面是一个&lt;code&gt;python&lt;/code&gt;小程序，用来获取对应网址上的图片，并保存到本地&lt;code&gt;D://imgs_from_yinwoods/&lt;/code&gt;目录下（&lt;strong&gt;linux系统会在当前目录下生成对应文件夹&lt;/strong&gt;）&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#coding=utf-8
import re
import os
import urllib
import urllib.request

def getHtml(url):	#用来获取给定url对应页面源码
    page = urllib.request.urlopen(url)
    html = page.read()
    return html

def getImg(htmls):	#获取htmls集合中含有的图片
    print(&amp;quot;I'm trying to get sexy images......&amp;quot;)
    print(&amp;quot;The images I'll get will be placed in dir D://imgs_from_yinwoods&amp;quot;)
    reg = r'src=&amp;quot;(.+?\.jpg)&amp;quot;'	#正则表达式匹配图片url
    imgre = re.compile(reg)
    x = 0
    cnt = 0
    imglist = []
    for cnt in range(0, 4):	#存取4个页面集合的图片url地址
        imglist.append(re.findall(imgre, str(htmls[cnt].decode('utf-8'))))
    path = os.path.join(&amp;quot;D:/&amp;quot;, &amp;quot;imgs_from_yinwoods&amp;quot;)	#设置文件存放文件夹
    os.makedirs(path)	#创建文件夹
    for imgurl in imglist:
        for url in imgurl:
            print(url)
            url = &amp;quot;http://hiowner.com/&amp;quot;+url
            print(url)
            urllib.request.urlretrieve(url, 'D://imgs_from_yinwoods/%s.jpg' % x)
            x += 1
            print(&amp;quot;I've got %d images&amp;quot; % x)
            if x &amp;gt; 99:
                return

html1 = getHtml(&amp;quot;http://hiowner.com/users&amp;quot;)
html2 = getHtml(&amp;quot;http://hiowner.com/users/page/2&amp;quot;)
html3 = getHtml(&amp;quot;http://hiowner.com/users/page/3&amp;quot;)
html4 = getHtml(&amp;quot;http://hiowner.com/users/page/4&amp;quot;)

htmls = []
htmls.append(html1)
htmls.append(html2)
htmls.append(html3)
htmls.append(html4)

getImg(htmls)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最近重新看这份代码，发现写的非常不好，而且试了下运行的话会报403错误。原因是该网站不允许爬虫直接读取页面内容。&lt;/p&gt;

&lt;p&gt;那我们所要做的就是给爬虫穿上伪装的外衣就好了。在尝试读取网页内容的时候为头信息添加User-Agent即可。&lt;/p&gt;

&lt;p&gt;还要注意的是这里不能用&lt;code&gt;urllib.request.urlretrieve()&lt;/code&gt;，原因是无法赋予User-Agent信息，所以我采用了读取文件源码再写到本地的方法。&lt;/p&gt;

&lt;p&gt;另外我又加了多线程机制提高爬取效率。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#coding=utf-8
import re
import os
import time
import threading
import urllib
import urllib.request
from bs4 import BeautifulSoup

class MM_Crawler:

    def getHtmlContents(self, url):   #用来获取给定url对应页面源码

        headers = {
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/48.0.2564.116 Chrome/48.0.2564.116 Safari/537.36',
        }
        headers = dict(headers)
        req = urllib.request.Request(url, headers=headers)
        response = urllib.request.urlopen(req)

        html = response.read()
        return html

    def getImg(self, html, id):  #获取htmls集合中含有的图片
        print(&amp;quot;I'm trying to get sexy images......&amp;quot;)
        print(&amp;quot;The images I'll get will be placed in dir D://imgs_from_yinwoods&amp;quot;)

        html_Doc = BeautifulSoup(html)

        divLists = html_Doc.find_all(&amp;quot;div&amp;quot;, &amp;quot;panel-body&amp;quot;)

        urllib.request.urlretrieve()

        imgNum = 0

        dirName = &amp;quot;page-&amp;quot; + str(id)
        if os.path.exists(dirName):
            print(&amp;quot;文件夹已存在！&amp;quot;)
        else:
            os.mkdir(dirName)

        for divItem in divLists:
            link = divItem.find('a')
            if link != None:
                imgLink = &amp;quot;http://hiowner.com/&amp;quot; + link.find('img')['src']
                imgNum += 1

                img = self.getHtmlContents(imgLink)

                regx = re.compile('(\/page\/\d)')

                fileName = dirName + '/%s.jpg' % imgNum
                with open(fileName, 'wb') as file:
                    if os.path.isfile(fileName):
                        print(fileName + &amp;quot;  已存在！&amp;quot;)
                    else:
                        file.write(img)




mmcrawler = MM_Crawler()

def tsk1(pageNum):
    url = &amp;quot;http://hiowner.com/users/page/&amp;quot; + str(pageNum)
    mmcrawler.getImg(mmcrawler.getHtmlContents(url).decode('utf8'), pageNum)
    time.sleep(1)

def createMultiThread(threadNum):
    threads = []
    for num in range(threadNum):
        threads.append(threading.Thread(target=tsk1, args=str(num+1)))
    for t in threads:
        t.start()

def main():

    createMultiThread(5)


if __name__ == &amp;quot;__main__&amp;quot;:
    main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
          <pubDate>2015-09-03T00:00:00+08:00</pubDate>
          <link>/coding/python%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0.html</link>
          <guid isPermaLink="true">/coding/python%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0.html</guid>
        </item>
      
    
      
        <item>
          <title>PHP中cURL学习</title>
          <description>&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;cURL(Client URL Library Functions)：使用URL语法传输数据的命令行工具；通过cURL你可以实现与各种服务器使用各种类型协议进行连接和通讯。&lt;/p&gt;

&lt;h3 id=&quot;curl&quot;&gt;cURL栗子&lt;/h3&gt;

&lt;p&gt;以下是一个爬取网页代码的简单栗子：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：可以直接在命令行中执行&lt;code&gt;php -f index.php&lt;/code&gt;来执行php程序&lt;/strong&gt;&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;php&quot;&gt;&amp;lt;?php
		//初始化cURL
    $url = curl_init();
    
    //设定cURL要访问网站
    curl_setopt($url, CURLOPT_URL, &amp;quot;www.baidu.com&amp;quot;);

    //把cURL返回值转为string类型
    curl_setopt($url, CURLOPT_RETURNTRANSFER, 1);

    //执行cURL
    $output = curl_exec($url);
    
    //关闭cURL释放资源！不要忘记！！！
    curl_close($url);
    
    print $output;

?&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面是一个利用cURL爬取网站图片的例子,爬取的图片会默认保存到当前目录下。&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;php&quot;&gt;&amp;lt;?php

		function get_imgs_url($html) {
			//匹配图片url
			preg_match_all('/http:.*?(.*?\.jpg)/', $html, $res);
			/*preg_match_all('&amp;lt;img.*?src=[\'|\&amp;quot;](.*?(?:[\.jpg]))[\'|\&amp;quot;].*?[\/]?&amp;gt;', $html, $res);*/
			
			for($i=0; $i&amp;lt;count($res[0]); $i++) {
					$filename = $i.&amp;quot;.jpg&amp;quot;;
					$file = @fopen($filename, &amp;quot;a&amp;quot;);
					$curl = curl_init();
					curl_setopt($curl, CURLOPT_URL, $res[0][$i]);
					curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
					$imgData = curl_exec($curl);
					curl_close($curl);
					fwrite($file, $imgData);
					fclose($file);
			}
		}


		$url = &amp;quot;http://blog.yinwoods.com&amp;quot;;
		$curl = curl_init();
		curl_setopt($curl, CURLOPT_URL, $url);
		curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
		//读取页面内容
		$html = curl_exec($curl);
		curl_close($curl);
		get_imgs_url($html);
?&amp;gt;

?&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用&lt;code&gt;php -f name.php&lt;/code&gt;会爬取我的博客首页的10张图片&lt;/p&gt;
</description>
          <pubDate>2015-09-01T00:00:00+08:00</pubDate>
          <link>/coding/php%E4%B8%ADcurl%E5%AD%A6%E4%B9%A0.html</link>
          <guid isPermaLink="true">/coding/php%E4%B8%ADcurl%E5%AD%A6%E4%B9%A0.html</guid>
        </item>
      
    
      
        <item>
          <title>Jekyll博客标签云（tag_cloud）实现</title>
          <description>&lt;p&gt;大概半个月之前就想要为博客添加标签云&lt;code&gt;tag_cloud&lt;/code&gt;的功能了，直到昨晚才抽出时间来搞，开始查了网上很多教程，但是苦于对&lt;code&gt;ruby&lt;/code&gt;的不了解，基本都会在某一步卡住。最后在这个过程中自己摸索出了怎么实现标签云&lt;code&gt;tag_cloud&lt;/code&gt;的功能。。。。&lt;/p&gt;

&lt;p&gt;先用图展示下实现效果：
&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post23-tag_cloud1.png&quot; alt=&quot;标签云&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post23-tag_cloud2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;实现过程主要分为以下几步：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、在博客根目录&lt;code&gt;_includes&lt;/code&gt;下新建&lt;code&gt;tag_cloud.html&lt;/code&gt;，内容如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post23-tag_cloud3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;这里的&lt;code&gt;site.BASE_PATH&lt;/code&gt;是在&lt;code&gt;config.yml&lt;/code&gt;中定义的博客根目录；因为上面的代码直接写在博客里会自动执行，所以在这里用的是截图。&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、为自己的博客添加&lt;code&gt;tags[]&lt;/code&gt;标记，例如本篇博文被我用&lt;code&gt;tags['jekyll']&lt;/code&gt;标记为&lt;code&gt;jekyll&lt;/code&gt;，如果需要多个标记，用逗号隔开即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、在博客根目录下新建&lt;code&gt;tags&lt;/code&gt;文件夹，并在该文件夹下新建所有对应&lt;code&gt;tag&lt;/code&gt;名字的文件夹，例如这里新建&lt;code&gt;jekyll&lt;/code&gt;文件夹。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4、在每个&lt;code&gt;tag&lt;/code&gt;文件夹下，新建一个&lt;code&gt;index.html&lt;/code&gt;，内容如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;

    &lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post23-tag_cloud4.png&quot; alt=&quot;&quot; /&gt;
把这里的两处&lt;code&gt;jekyll&lt;/code&gt;出现位置换位对应的&lt;code&gt;tag&lt;/code&gt;名称即可&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5、接下来大家编写自己自定义的&lt;code&gt;CSS&lt;/code&gt;即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;6、目前标签页缺少分页功能，比如对所有在&lt;code&gt;jekyll&lt;/code&gt;下的文章分页，问题还有待解决。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;centerhttp7xlnl2com1z0glbclouddncompost2-jpgcenter&quot;&gt;&lt;center&gt;综上就是实现标签云的过程，如果大家有疑问或建议，欢迎讨论^_^![](http://7xlnl2.com1.z0.glb.clouddn.com/post2-卖萌.jpg)&lt;/center&gt;&lt;/h5&gt;
</description>
          <pubDate>2015-08-29T00:00:00+08:00</pubDate>
          <link>/myshare/jekyll%E5%8D%9A%E5%AE%A2%E6%A0%87%E7%AD%BE%E4%BA%91tag-cloud%E5%AE%9E%E7%8E%B0.html</link>
          <guid isPermaLink="true">/myshare/jekyll%E5%8D%9A%E5%AE%A2%E6%A0%87%E7%AD%BE%E4%BA%91tag-cloud%E5%AE%9E%E7%8E%B0.html</guid>
        </item>
      
    
      
        <item>
          <title>重拾C++</title>
          <description>&lt;p&gt;假期回到学校呆着无聊，因为想要在大四找到一份不错的实习，所以打算重读《C++ Primer》，着重啃掉以前遗留下来的难点。&lt;/p&gt;

&lt;p&gt;毫无疑问这将花费我很多时间，希望我能够将这篇博客梳理出来。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;数组和指针&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;在用下标访问元素时，&lt;code&gt;vector&lt;/code&gt;使用&lt;code&gt;vector::size_type&lt;/code&gt;作为下标的类型，而数组下标的正确类型则是&lt;code&gt;size_t&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;C++提供一种特殊的指针类型&lt;code&gt;void*&lt;/code&gt;，它可以保存任何类型对象的地址；因为&lt;code&gt;void*&lt;/code&gt;没有涉及类型，故而不能够使用解引用操作符&lt;code&gt;*&lt;/code&gt;来获取其对应地址的值；
可以执行的操作有：&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;与另一个指针进行比较；向函数传递&lt;code&gt;void*	&lt;/code&gt;指针或从函数返回&lt;code&gt;void*&lt;/code&gt;指针以及&lt;code&gt;void*&lt;/code&gt;赋值&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;指针和引用的比较：引用（&lt;code&gt;reference&lt;/code&gt;）和指针（&lt;code&gt;pointer&lt;/code&gt;）都可间接访问另一个值，但二者之间有以下两个区别&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;1、引用总是指向某一个对象，定义引用时没有初始化是错误的。&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;2、给引用赋值修改的是该引用所关联的对象的值，而不是像指针那样使引用与另一个对象关联。&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;可以对同一数组不同元素的指针做减法操作，其结果是&lt;strong&gt;标准库类型&lt;/strong&gt;&lt;code&gt;ptrdiff_t&lt;/code&gt;，与&lt;code&gt;size_t&lt;/code&gt;一样，&lt;code&gt;ptrdiff_t&lt;/code&gt;也是一种与机器相关的类型，在&lt;code&gt;cstddef&lt;/code&gt;头文件中定义；&lt;code&gt;size_t&lt;/code&gt;是&lt;code&gt;unsigned&lt;/code&gt;类型，而&lt;code&gt;ptrdiff_t&lt;/code&gt;则是&lt;code&gt;signed&lt;/code&gt;类型&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;当指针指向&lt;code&gt;const&lt;/code&gt;对象，不允许用指针来改变其所指的&lt;code&gt;const&lt;/code&gt;值；允许把非&lt;code&gt;const&lt;/code&gt;对象的地址赋给指向&lt;code&gt;const&lt;/code&gt;对象的指针，但之后不允许通过该指针修改对应&lt;code&gt;const&lt;/code&gt;对象的值&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;当指针为&lt;code&gt;const&lt;/code&gt;指针时，该指针值不可修改，但其所指向对象的值不受限制；与任何&lt;code&gt;const&lt;/code&gt;量一样，&lt;code&gt;const&lt;/code&gt;指针必须在定义时初始化&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;数组类型的变量有三个重要限制：&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;1、数组长度固定不变&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;2、编译时必须知道数组长度&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;3、数组只在定义它的块语句内存在&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配对象，此内存空间称为程序的&lt;strong&gt;自由存储区&lt;/strong&gt;或&lt;strong&gt;堆&lt;/strong&gt;。C语言使用标准库函数&lt;code&gt;malloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;分配存储空间，而C++语言使用&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;实现相同功能&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;C++为含点操作符和解引用操作符的表达式提供了一个同义词：箭头操作符（-&amp;gt;）；例如：&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;code&gt;*(person).name&lt;/code&gt; 等价于 &lt;code&gt;person-&amp;gt;name&lt;/code&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;函数&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;利用&lt;code&gt;const&lt;/code&gt;引用避免复制：一般情况下形参需要复制实参的值，这样会导致效率低下，一种比较好的解决方法是使用&lt;code&gt;const&lt;/code&gt;引用；（注：&lt;strong&gt;当然传递后的实参是不可改变的&lt;/strong&gt;）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;调用函数时，可以省略有默认值的实参。调用包含默认实参的函数时，若提供实参，则覆盖默认实参值，否则使用默认实参。默认实参只需在函数声明或函数定义中指定一次即可，不可重复指定。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;section-2&quot;&gt;内联函数：&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;在函数返回类型前加上&lt;code&gt;inline&lt;/code&gt;即将函数指定为内联函数；内联函数适用于优化小的、只有几行的且经常被调用的函数。（注：&lt;strong&gt;优化效果类似于宏定义&lt;/strong&gt;）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;类的所有成员都必须在类定义的花括号里面声明（注：&lt;strong&gt;不是定义&lt;/strong&gt;），此后就不能再为类添加任何成员。类的成员函数既可以在类的定义内也可以在类的定义外定义。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;编译器隐式地将在类内定义的成员函数当做内联函数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;构造函数和类同名，且没有返回类型；一个类可以有多个构造函数。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;现在分析构造函数形如&lt;code&gt;Person(): age(0), name(&quot;yinwoods&quot;) { }&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;1、构造函数不含形参说明为默认构造函数。&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;2、冒号与花括号之间的代码称为&lt;strong&gt;构造函数的初始化列表&lt;/strong&gt;，其中包含一系列成员名，每个成员名后面是括在括号中的初始值。&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;容器&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;h5 id=&quot;section-4&quot;&gt;顺序容器&lt;/h5&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;顺序容器有&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;deque&lt;/code&gt;三种，其中&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;deque&lt;/code&gt;为元素提供随机访问，而&lt;code&gt;list&lt;/code&gt;顾名思义，操作类似于链表。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h5 id=&quot;section-5&quot;&gt;关联容器&lt;/h5&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;关联容器支持通过键(&lt;code&gt;key&lt;/code&gt;)高效地查找和读取元素，两个基本类型是&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;pair&lt;/code&gt;类型包含两个数据值，可通过&lt;code&gt;pair.first&lt;/code&gt;和&lt;code&gt;pair.second&lt;/code&gt;进行访问；一般使用&lt;code&gt;make_pair(first, second)&lt;/code&gt;来创建&lt;code&gt;pair&lt;/code&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;使用关联容器时，它的键不但有一个类型，而且还有一个相关的比较函数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;map&lt;/code&gt;使用下标过程中需要注意，如果该键不在&lt;code&gt;map&lt;/code&gt;容器中，那么下标操作会插入一个具有该键的新元素。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;可以使用&lt;code&gt;count&lt;/code&gt;和&lt;code&gt;find&lt;/code&gt;检查某个键是否存在&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;相比于&lt;code&gt;map&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt;只是简单的键的集合&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;中，一个键只能对应一个实例，而&lt;code&gt;multimap&lt;/code&gt;和&lt;code&gt;multiset&lt;/code&gt;允许一个键对应多个实例。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;在&lt;code&gt;multiset&lt;/code&gt; &lt;code&gt;multimap&lt;/code&gt;查询中，可以使用&lt;code&gt;upper_bound(key)&lt;/code&gt;、&lt;code&gt;lower_bound(key)&lt;/code&gt;以及&lt;code&gt;equal_range(key)&lt;/code&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-6&quot;&gt;类&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;在C++中，如果类是用&lt;code&gt;struct&lt;/code&gt;定义的，默认成员是公有的，而类如果用&lt;code&gt;class&lt;/code&gt;定义，默认成员为私有。
**&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;构造函数可以包含一个构造函数初始化列表，形如&lt;code&gt;Person::Person(string name):age(21), address(&quot;...&quot;) { } &lt;/code&gt;(注：&lt;strong&gt;初始化&lt;code&gt;const&lt;/code&gt;或引用类型数据以及没有默认构造函数成员的唯一机会是在构造函数初始化列表中&lt;/strong&gt;)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;成员初始化次序就是定义成员的次序&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;section-7&quot;&gt;友元（允许一个类将其非公有成员的访问权授予指定的函数或类）&lt;/h5&gt;

&lt;p&gt;声明以关键字friend开始。&lt;/p&gt;

&lt;p&gt;通常，将友元声明成组地放在类定义的开始或结尾&lt;/p&gt;

&lt;h5 id=&quot;this&quot;&gt;隐含的this指针&lt;/h5&gt;

&lt;p&gt;在普通的非const成员函数中，this的类型是一个指向类类型的const指针，可以改变this所指向的值，但不能改变this所保存的地址。&lt;/p&gt;

&lt;p&gt;在const成员函数中，this的类型是一个指向const类类型的const指针，既不能改变this所指向的值，也不能改变this所保存的地址。&lt;/p&gt;

&lt;p&gt;基于上面的限制，当我们使用如下Screen类的时候会出现一个问题：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Screen {
public:
    typedef std::string::size_type index;
    char get() const { return contents[cursor]; }
    char get(index ht, index wd) const { index row = ht*width; return contents[row+wd]; };
    Screen&amp;amp; set(char c) { contents[cursor] = c; return *this; }
    Screen&amp;amp; move(index r, index c) { index row = r*width; cursor = row+c; return *this; }
private:
    std::string contents;
    index cursor;
    index height, width;
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果我们想要将类操作序列连接成一个单独表达式时，比如：&lt;code&gt;myScreen.move(4, 0).set('#');&lt;/code&gt;需要操作序列中间的函数返回对自身对象的一个引用，也即定义使用&lt;code&gt;Screen &amp;amp;&lt;/code&gt;，返回值使用&lt;code&gt;return *this&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;假如说我们又有了一个新的需求，希望能够在序列中使用display()函数，比如：&lt;code&gt;myScreen.move(4, 0).set('#').display(cout)&lt;/code&gt;，display的用法暗示应该返回一个Screen引用，并接受一个ostream的引用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果display被定义为一个const成员，则它的返回类型也必须是const Screen&amp;amp;。这就带来了一个问题，如果我们想在display后接操作序列，比如：&lt;code&gt;myScreen.display(cout).set('#')&lt;/code&gt;就会出现问题，因为display返回一个const引用，而对const引用调用set函数是违法的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个比较好的解决方法是定义两个display，通过函数的const重载来解决这个问题。&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Screen {
public:
    ...
    Screen&amp;amp; display(std::ostream &amp;amp;os) { do_display(os); return *this; }
    const Screen&amp;amp; display(std::ostream &amp;amp;os) const { do_display(os); return *this; }
private:
    void do_display(std::ostream &amp;amp;os) { os &amp;lt;&amp;lt; contents; }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在当我们将display嵌入一个长表达式中时会调用非const版display，当我们display一个const对象时，就会调用const版本。&lt;/p&gt;

&lt;h5 id=&quot;section-8&quot;&gt;构造函数&lt;/h5&gt;

&lt;p&gt;类定义在两个阶段中处理：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、首先，编译成员声明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、只有在所有成员出现之后，才编译它们的定义本身。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当我们想要抑制由构造函数定义的隐式转换时可以使用&lt;code&gt;explicit&lt;/code&gt;关键字声明（&lt;strong&gt;定义时不需要&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;一般我们把单形参构造函数声明为&lt;code&gt;explicit&lt;/code&gt;，这样做是为了避免我们不希望发生的转换，当转换有用时，可以显示地构造对象。&lt;/p&gt;

&lt;p&gt;类成员的显示初始化：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;struct Data {
    int ival;
    char *ptr;
};
Data val2 = { 0, 0 };
//等价于val2.ival = 0; val2.ptr = 0;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示初始化有以下三个缺点：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、要求类的全体数据成员都是public。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、这种初始化易于出错，特别是有很多数据成员的情况。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、不易增加或删除一个成员。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;static&quot;&gt;static成员&lt;/h5&gt;

&lt;p&gt;static成员是类的组成部分，但不是任何对象的组成部分，&lt;strong&gt;因此static成员函数没有this指针&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;因为static成员不是任何对象的组成部分，&lt;strong&gt;所以static成员函数不能被声明为const&lt;/strong&gt;。另一方面，将函数声明为const就意味着不会修改该函数所属对象，这与static的定义是矛盾的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;static成员函数也不能被声明为虚函数&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;static数据成员声明与初始化不能同时进行，一般来说static数据成员要在类定义体的外部定义。
比如：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Test {
public:
    static int num;//声明
}

int num = 0;//定义&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于上面这个规则有一个例外，对于static const int 型可以在类的定义体中进行初始化（注意：&lt;strong&gt;仅限于int型， char属于int，因此也合法&lt;/strong&gt;）。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;复制控制&lt;/h3&gt;

&lt;p&gt;复制构造函数：一种特殊的构造函数，具有单个形参，该形参是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将&lt;strong&gt;显式调用&lt;/strong&gt;复制构造函数。当将该类型的对象传递给函数或从函数返回该类型的对象时，将&lt;strong&gt;隐式调用&lt;/strong&gt;复制构造函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复制构造函数、赋值操作和析构函数总称为复制控制&lt;/strong&gt;。编译器自动实现这些操作，但类也可以定义自己的版本。&lt;/p&gt;

&lt;h5 id=&quot;section-10&quot;&gt;复制构造函数&lt;/h5&gt;

&lt;p&gt;复制构造函数就是接受单个类类型引用形参的构造函数。
举个栗子：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Foo {
public:
    Foo();
    Foo();//默认构造函数
    Foo(const Foo&amp;amp;);//复制构造函数
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复制构造函数可用于：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;根据另一个同类型的对象显式或隐式初始化一个对象。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;复制一个对象，将它作为实参传给一个函数。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;从函数返回时复制一个对象。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;初始化顺序容器中的元素。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;根据元素初始化式列表初始化数组元素。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;C++支持两种初始化：直接初始化和复制初始化。复制初始化使用=符号，直接初始化将初始式放在圆括号中。&lt;/p&gt;

&lt;p&gt;对于类而言，复制初始化的形式是首先使用指定构造函数创建一个临时对象，然后用复制构造函数将临时对象复制到正在创建的对象。&lt;/p&gt;

&lt;p&gt;与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会自动生成合成复制构造函数。合成复制构造函数用于执行逐个成员初始化，将新对象初始化为原对象的副本。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意：如果一个类具有数组成员，合成复制构造函数将赋值数组。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;复制构造函数的形参必须为引用的原因：
我的观点是如果不使用引用，那么我们在传递一个实参的过程中，就已经在使用复制构造函数了，因为要把实参的值复制到形参中！而这就会导致一个无限循环的递归。&lt;/p&gt;

&lt;p&gt;为了防止不必要的复制，类必须显示声明其复制构造函数为private，因为不这样做的话即使我们不声明复制构造函数，编译器也会自动合成一个。&lt;/p&gt;

&lt;p&gt;即使将复制构造函数声明为private，类的友元和成员仍可以进行复制。如果想要连友元和成员中的复制也禁止，可以声明一个private复制构造函数但不对其进行定义。&lt;/p&gt;

&lt;h5 id=&quot;section-11&quot;&gt;赋值操作符&lt;/h5&gt;

&lt;p&gt;与复制构造函数一样，如果类没有定义自己的赋值操作符，编译器会合成一个。赋值操作符的实现依赖于对&lt;code&gt;=&lt;/code&gt;操作符的重载。&lt;/p&gt;

&lt;p&gt;赋值操作符返回类型应该与内置类型赋值运算返回的类型相同，也就是说赋值操作符返回对同一类类型的引用。&lt;/p&gt;

&lt;h5 id=&quot;section-12&quot;&gt;析构函数&lt;/h5&gt;

&lt;p&gt;析构函数的任务就是撤销类对象时，回收资源。动态分配的对象只有在指向该对象的指针被删除时才撤销。&lt;/p&gt;

&lt;p&gt;值得说的是：容器中的元素总是按逆序撤销（运行容器中的类类型元素的析构函数）。&lt;/p&gt;

&lt;p&gt;一般来说编译器自动生成的析构函数能够很好地完成任务，只有一些资源需要程序员通过析构函数来回收或者程序员希望在对象生命周期结束时执行一些操作的时候才需要自己定义析构函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三法则：如果需要析构函数，则需要所有三个复制控制成员，也即：复制构造函数、赋值操作符、析构函数。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与复制构造函数或赋值操作符不同，编译器总是会为我们合成一个析构函数。合成析构函数按对象创建顺序的逆序撤销每个非static成员。&lt;/p&gt;

&lt;h5 id=&quot;section-13&quot;&gt;管理指针成员&lt;/h5&gt;

&lt;p&gt;大多数C++类采用以下三种方式之一管理指针成员：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;指针成员采取常规指针型行为。这样的类具有指针的所有缺陷但无需特殊的复制控制。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;类可以实现所谓的“智能指针”行为。指针所指向的对象是共享的，但类能够防止悬垂指针。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;类采取值型行为，指针所指对象是唯一的，由每个类对象独立管理。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;智能指针：将一个计数器与类所指向的对象相关联。只有当计数为0时，删除对象。每次创建类的新对象时，将计数置为1，当对象作为另一对象的副本时，复制构造函数复制指针并增加与之相应的使用计数的值。调用析构函数时，析构函数减少使用计数的值，如果计数减为0，则删除基础对象。&lt;/p&gt;

&lt;p&gt;智能指针实现代码：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;//智能指针类
class U_Ptr {
    friend class HasPtr;
    int *ip;
    size_t use;
    U_Ptr(int *p) : ip(p), use(1) { }
    ~U_Ptr() { delete ip; }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class HasPtr {
public:
    //构造函数
    HasPtr(int *p, int i) : ptr(new U_Ptr(p)), val(i) { }
    //复制构造函数
    HasPtr(const HasPtr &amp;amp;orig) : ptr(orig.ptr), val(orig.val) { ++ptr-&amp;gt;use; }
    //赋值符号
    HasPtr&amp;amp; operator=(const HasPtr&amp;amp; rhs) {
        //先对rhs.ptr-&amp;gt;use加1，防止自身赋值
        ++rhs.ptr-&amp;gt;use;
        ptr = rhs.ptr;
        val = rhs.val;
        if(--ptr-&amp;gt;use == 0)
            delete ptr;
        return *this;
    }
    //析构函数
    ~HasPtr() { if(--ptr-&amp;gt;use == 0) delete ptr; }

private:
    U_Ptr *ptr;
    int val;
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-14&quot;&gt;重载操作符与转换&lt;/h3&gt;
&lt;p&gt;重载操作符支持大多数操作符，重载形式为operator后接需定义的操作符符号。重载操作符必须有一个类类型操作数。内置类型操作符不可用于重载。重载操作符并不保证操作数的求值顺序。&lt;strong&gt;操作符的优先级、结合性或操作数数目不能改变&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般将算术和关系操作符定义为非成员函数，而将赋值操作符定义为成员。操作符定义为非成员函数时，通常必须将它们设置为所操作类的友元，因为操作符往往要涉及到类的private数据成员操作。&lt;/p&gt;

&lt;p&gt;不要重载赋值、取地址、逗号等对类类型操作数有默认含义的操作符。&lt;strong&gt;赋值【=】、下标【[]】、调用【()】和成员访问箭头【-&amp;gt;】等操作符必须定义为成员&lt;/strong&gt;，将这些操作符定义为非成员函数将在编译时标记为错误。&lt;/p&gt;

&lt;p&gt;调用函数符和函数对象，可以为类类型的对象重载函数调用操作符【()】。例如我们可以实现如下代码：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;struct absInt {
    int operator()(int val) {
        return val &amp;lt; 0 ? -val : val;
    }
}
---
int i = -43;
absInt absObj;
unsigned int ui = absObj(i);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-15&quot;&gt;函数对象的函数适配器&lt;/h5&gt;

&lt;p&gt;函数适配器用来特化和扩展一员和二元函数对象。&lt;/p&gt;

&lt;p&gt;函数适配器分为两类：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、绑定器：通过将一个操作数绑定到给定值而将二元函数对象转换为一元函数对象。含bind1st和bind2nd&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;如：&lt;code&gt;bind2nd(less_equal&amp;lt;int&amp;gt;(), 10)&lt;/code&gt;将二元函数扩展为一元函数。&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、求反器：将谓词函数对象的真值求反。含not1和not2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;section-16&quot;&gt;转换与类类型&lt;/h5&gt;

&lt;p&gt;转换操作符是一种特殊的类成员函数。它定义将类类型值转变为其他类型值的转换。例如：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class SmallInt {
    public:
        operator int() const { return val; }
    private:
        std::size_t val;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在需要时SmallInt对象可以转为int值。&lt;/p&gt;

&lt;p&gt;你可能会好奇int到SmallInt的转换，这其实就需要我们编写相应的构造函数来完成这种转换了。&lt;/p&gt;

&lt;p&gt;转换函数采用通用形式：&lt;code&gt;operator type()&lt;/code&gt;用于将类对象转为type类型；其中type可以是内置类型名、类类型名或由类型别名所定义的名字。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;转换函数必须是成员函数，不能指定返回类型，并且形参表必须为空；转换函数一般不应该改变被转换的对象，因此转换操作符通常定义为const成员&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是转换操作符不具备连接性，也就是说如果我们有一个新类Integral，我们可以定义转换操作符&lt;code&gt;operator SmallInt() const&lt;/code&gt;这样我们可以在使用SmallInt的地方使用Integral，但不能在使用int的地方使用Integral；但我们可以在使用double、float的地方使用SmallInt&lt;/p&gt;

&lt;p&gt;类型转换中的错误：&lt;/p&gt;

&lt;p&gt;这种转换带来了方便，同时也带来了问题，考虑下面这种情况：&lt;/p&gt;

&lt;p&gt;1、在SmallInt类中既定义了到int的转换，又定义了到double的转换，那么在使用明确的类型转换中不会有问题，但是考虑一个函数&lt;code&gt;compute(long double){}&lt;/code&gt;，那么我们在调用compute(SmallInt)的时候将如何转换呢？这会导致调用的二义性，因此编译器报错。&lt;/p&gt;

&lt;p&gt;2、这种情况对于不同形参类型构造函数同样适用，例如定义了两个构造函数分别为：&lt;code&gt;SmallInt(int)&lt;/code&gt;和&lt;code&gt;SmallInt(double)&lt;/code&gt;那么我们将一个long类型的值作为构造函数实参时同样会因为调用二义性而报错。&lt;/p&gt;

&lt;p&gt;3、考虑两个类可以相互转换的情况：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Integral;
class SmallInt {
public:
    SmallInt(Integral);
};

class Integral {
public:
    operator SmallInt() const;
};

void compute(SmallInt);
Integral int_val
compute(int_val);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的computer函数调用会出错，同样是因为二义性，因为既可以使用SmallInt的构造函数将int_val转为SmallInt类型，也可以使用int_val的SmallInt()转换函数转为SmallInt类型。这种情况下可以使用显示类型转换来解决二义性，如&lt;code&gt;compute(int_val.operator SmallInt());&lt;/code&gt;或&lt;code&gt;compute(SmallInt(int_val))&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;一个避免二义性的好的方法是不再二：&lt;strong&gt;保证最多只有一种途径将一个类型转换为另一个类型。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C++ OOP特性还可参考本站其他相关博文：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/c%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81.html&quot;&gt;C++ 【oop】封装篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/c-oop%E7%BB%A7%E6%89%BF%E7%AF%87.html&quot;&gt;C++ 【oop】继承篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/coop%E5%A4%9A%E6%80%81%E7%AF%87.html&quot;&gt;C++ 【oop】多态篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.yinwoods.com/coding/coop%E6%A8%A1%E6%9D%BF%E7%AF%87.html&quot;&gt;C++ 【oop】模板篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
          <pubDate>2015-08-20T00:00:00+08:00</pubDate>
          <link>/coding/%E9%87%8D%E6%8B%BEc.html</link>
          <guid isPermaLink="true">/coding/%E9%87%8D%E6%8B%BEc.html</guid>
        </item>
      
    
      
        <item>
          <title>使用swiftype为博客添加搜索引擎</title>
          <description>&lt;p&gt;一直以来都想给自己的博客添加搜索功能，但是总感觉很高大上的样子，直到我遇到了&lt;a href=&quot;https://swiftype.com/&quot;&gt;swiftype&lt;/a&gt;这个为网站和移动应用提供内部搜索的工具。总的来说&lt;a href=&quot;https://swiftype.com/&quot;&gt;swiftype&lt;/a&gt;可以让你为自己的网站个性化定制搜索；还支持对搜索结果排序进行定制（比如置顶某些内容）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post21-swiftype.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面是配置&lt;a href=&quot;https://swiftype.com/&quot;&gt;swiftype&lt;/a&gt;过程：&lt;/p&gt;

&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1、首先去&lt;a href=&quot;https://swiftype.com/&quot;&gt;swiftype&lt;/a&gt;注册一个账号&lt;/li&gt;
    &lt;li&gt;2、接着添加自己想要配置的网站地址并为新设定的引擎添加一个名字（非会员只能设置一个引擎）。&lt;/li&gt;
    &lt;li&gt;3、收到验证邮件后去自己的邮箱验证，验证成功后&lt;a href=&quot;https://swiftype.com/&quot;&gt;swiftype&lt;/a&gt;即开始抓取网站内容&lt;/li&gt;
    &lt;li&gt;4、接下来选择&lt;code&gt;Setup and integration&lt;/code&gt;点击&lt;code&gt;Install search engine&lt;/code&gt;进入搜索引擎个性化配置界面。可以自定义外观、搜索内容显示方式等等。&lt;/li&gt;
    &lt;li&gt;5、配置完成后将产生代码添加到网站并激活搜索引擎即可使用。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;我的搜索引擎采用默认配置方式，有兴趣的同学可以点击页面右下角使用！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;参考文章：&lt;/p&gt;

&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://miantiao.me/use-swiftype-search.html#stq=&amp;amp;stp=0&quot;&gt;使用 Swiftype 解决 Jekyll 等静态博客搜索功能&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://codeboy.me/2015/07/11/jekyll-search/&quot;&gt;给jekyll添加炫酷简洁的搜索&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://wwsun.me/posts/site-search-post.html&quot;&gt;为Jekyll站点添加Swiftype站内搜索&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;
</description>
          <pubDate>2015-08-11T00:00:00+08:00</pubDate>
          <link>/myshare/%E4%BD%BF%E7%94%A8swiftype%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E.html</link>
          <guid isPermaLink="true">/myshare/%E4%BD%BF%E7%94%A8swiftype%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E.html</guid>
        </item>
      
    
      
        <item>
          <title>暑期保研感想</title>
          <description>&lt;p&gt;这段时间一直在忙着保研的事，通过参加夏令营，也有了很多心得体会，所以想写在这里和大家分享下，也为后来人提供前车之鉴。&lt;/p&gt;

&lt;p&gt;之前一共报名了六个学校的夏令营：浙大、哈工大、中科大、中国人大、北航、中科院（计算所、软件所）&lt;/p&gt;

&lt;p&gt;说是六个学校，其实真心报名的只有哈工大、北航以及中科院（计算所、软件所）&lt;/p&gt;

&lt;p&gt;其他地方没有认真完成报名的根本原因就是我想在北京读研究生，所以其他地方就不是很重视，报名也是抱着试一试、学习经验、看看自己简历大概什么水平的态度。&lt;/p&gt;

&lt;p&gt;中科大和中国人大是因为报名所需要的材料太繁琐；不过很神奇的是我明明没有向中国人大寄材料，最终录取名单上有我。。。（ps:因为当时没有被任何一所学校的夏令营录取，内心也比较着急，所以当我知道被人大录取后连夜赶到北京…但是因为火车晚点三小时，没有赶上面试。。。）&lt;/p&gt;

&lt;p&gt;浙大那边报名很容易，也有一位老师联系我，并和我说明我的简历不是很优秀，如果不直博的话很可能不会要我，直博对我来说还是风险太大，就拒绝了。&lt;/p&gt;

&lt;p&gt;中科院计算所和软件所都没有录取我，我通过咨询计算所的学姐了解到可以和老师说明情况申请补录，就和计算所那边的导师打电话说明自己的情况。不得不说计算所负责招生的卢老师人特别好！说是很理解我的情况，如果有已被录取的人没去的话就优先考虑我。后来果然被补录了。（&lt;code&gt;这里多说一句：去年暑期夏令营报名计算所的才400+人，今年报名的有了1000+人；今年录取名单上基本没了985，甚至还有5名清华的同学参加。所以希望来年准备夏令营的同学一定做好两手准备。&lt;/code&gt;）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 计算所的夏令营一共五天，交200元包吃住。前面三天都是在听讲座，最后两天才开始选择实验室、面试（`ps：一定要在面试开始前多了解实验室，确定自己的意向`）。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 我一开始的意向是网络数据重点实验室，但是因为自己学校不出色，而网数实验室又是每年的热点，因此报了网络技术实验室。。。这就注定了我的悲剧，因为我对计算机网络确实不擅长，而且没有事先准备。。。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 因为在夏令营之前我就联系过计算所网技的老师S（这也是我报网技的一部分原因），面试之前这位S老师还特意找我聊了聊，表明有录取我的意向。但是不得不说自己面试的时候表现得太怂了。。。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 面试一进去，五位老师坐在对面，中间的一位老师让我做一个自我介绍，接着S老师问的简单问题（`网络层有哪些协议？路由层有哪些协议？`），我因为紧张都没答出来，S老师还特意帮我说好话说这位给你写推荐信的老师对你评价比较高，他是否对你授过课...自己就简单说明情况。然后中间的老师就说那面试就到此为止吧。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 当时也意识到自己悲剧了，但是还是接着出来做机试、笔试。这里要说的一句就是机试是实现大数相加或实现`I am a student`到`student a am I`的翻转。我选择的是字符串翻转，并成功写出来了。然后负责检查的学长说我的功能实现了，但是不够优化（复杂度可以从O(n)到O(n/2)）。。。虽然他说的很有道理，但是他的语气真的让人很不舒服。。。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 网技的面试就这么悲剧了。也没有很遗憾，就是感觉很对不起S老师。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 计算所的夏令营做的很好。但是要说的一个弊端就是实验室面试淘汰你的话是不会通知你的，虽然当时觉得自己希望不大，但还是等结果等到了下午五点。后来收到无线通信技术研究中心负责招生的常老师短信，通知我未被网技录取，并因为方向相近愿意给我一个面试的机会。接着我就急急地赶过去了，面试问题都很简单，结束后老师通知我被录取了，并让我领体检单，第二天体检。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 晚上搜集了一些关于这个实验室的信息，了解到这个实验室是计算所里待遇最高的，研一每个月就有2000+；但是平时在所里工作的话是不给联网的。。。网络对我来说还是很重要的，感觉离开了网络很难提升自己的能力。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 第二天一早过去做了体检，体检后收到老师短信让我去聊了聊，因为不确定是否要在这里就和老师聊了一会，说出了我的顾虑，老师说这个实验室有郑大的学长，让他来和我聊聊可能会更好。和学长聊了很多，学长和我聊了很多，和我说明了无论在哪个实验室以后都是要靠自己实力去找工作的，学长人很好，也很热心。但可能是我内心比较迷茫吧，抱着对自己、对老师负责的态度，最终还是决定不签名⊙﹏⊙b汗。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;休息了两天就去参加北航的夏令营了。必须吐槽以下北航夏令营安排地真心不好，没有组织。而且不管食宿，还临时收了100元的面试费。。。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 夏令营一共两天，第一天上午报道，下午机试；机试一共两道题，不同时间段内容不同，我做的第一道是给一个小数转为假分数；第二道是对字符串的简单操作。总体来说题目很简单，感觉很多人都可以拿满分。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 夏令营第二天就面试了，分不同的组，一般来说一个学校的都在一起。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 面试我的时候，先让我用英文做一个自我介绍，接着问了我很多比较偏的问题，基本都没答出来。虽然老师知道我是搞ACM的，但就是不问算法相关的问题。。。比较侧重于问项目经验，觉得这个分老师，不同老师的侧重点不同。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 面试结束后感觉自己就没希望了。因为结果出来得比较晚，下午和同学一起去看了《煎饼侠》，感觉还不错；看过电影后发现有一个未接电话，坐在公交上打过去因为太吵了听不清就和对方说一会聊。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 回到北航打电话过去，听出来就是上午面试我的几个老师之一（几名老师中的BOSS，因为坐在中间）。说是问我在不在北航，想找我聊一聊。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;- 去了老师的办公室后，老师向我说明了当前的招生情况以及自己的研究方向，问我愿不愿意跟着他学习，还和我说他比较注重学生的`素质`与`可塑性`。（回去想了一天后回复老师说愿意O(∩_∩)O哈哈~）
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;这就是整个暑期夏令营的经过了，感觉自己的心态很重要，保研没有那么难，把自己的能力、素质展现出来就好了！&lt;/p&gt;
</description>
          <pubDate>2015-07-29T00:00:00+08:00</pubDate>
          <link>/diary/%E6%9A%91%E6%9C%9F%E4%BF%9D%E7%A0%94%E6%84%9F%E6%83%B3.html</link>
          <guid isPermaLink="true">/diary/%E6%9A%91%E6%9C%9F%E4%BF%9D%E7%A0%94%E6%84%9F%E6%83%B3.html</guid>
        </item>
      
    
      
        <item>
          <title>LeetCode 3 （脑洞题）</title>
          <description>&lt;p&gt;题意是给定一个字符串，返回不含重复字符的最长串长度&lt;/p&gt;

&lt;p&gt;例如对于&lt;code&gt;abcabcbb&lt;/code&gt;，返回&lt;code&gt;3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用&lt;code&gt;ansl&lt;/code&gt;记录当前选定串的最左字符位置，用&lt;code&gt;ansr&lt;/code&gt;记录当前选定串的最右字符位置&lt;/p&gt;

&lt;p&gt;我的做法是用&lt;code&gt;map&lt;/code&gt;记录当前选定串中字符的位置，那么当遇到一个新的字符&lt;code&gt;ch&lt;/code&gt;时，如果&lt;code&gt;map[ch]&lt;/code&gt;的值不为0，说明当前选定串有&lt;code&gt;ch&lt;/code&gt;，那就更新当前选定串&lt;/p&gt;

&lt;p&gt;每次更新&lt;code&gt;ansl&lt;/code&gt;和&lt;code&gt;ansr&lt;/code&gt;时，若两者差值大于当前答案&lt;code&gt;res&lt;/code&gt;，则更新res&lt;/p&gt;

&lt;p&gt;这里所说的&lt;code&gt;ansr&lt;/code&gt;就是当前字符的下标&lt;code&gt;i&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Solution {
    public:
        int lengthOfLongestSubstring(string s) {

            if(s.size() == 0) return 0;

            int ansl, res;
            ansl = res = 0;
            map&amp;lt;char, int&amp;gt; mp;

            s = &amp;quot; &amp;quot; + s;
            for(int i=1; i&amp;lt;s.size(); ++i) {
                if(mp[s[i]] != 0) {
                    ansl = max(ansl, mp[s[i]]+1);//保证左侧位置不会“回头”
                }

                if(ansl == 0) res = max(res, i-ansl);
                else res = max(res, i-ansl+1);

                mp[s[i]] = i;
            }
            return res;
        }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
          <pubDate>2015-07-25T00:00:00+08:00</pubDate>
          <link>/coding/leetcode-3-longest-substring-without-repeating-characters%E8%84%91%E6%B4%9E%E9%A2%98.html</link>
          <guid isPermaLink="true">/coding/leetcode-3-longest-substring-without-repeating-characters%E8%84%91%E6%B4%9E%E9%A2%98.html</guid>
        </item>
      
    
      
        <item>
          <title>LeetCode 234（单链表+快慢指针）</title>
          <description>&lt;p&gt;题目的意思很简单，给定一个单链表，判断是否回文&lt;/p&gt;

&lt;p&gt;我最开始的做法就是每次找到中间的两个位置进行匹配（考虑奇偶）&lt;/p&gt;

&lt;p&gt;匹配后删除这两个元素，再从头指针开始找中间位置，重复这个操作直到链表为空&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ps:需要对空表以及只含一个元素的链表进行特殊处理&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样的思路虽然是正确的，但是太慢了，代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;CPP&quot;&gt;/**

 * Definition for singly-linked list.

 * struct ListNode {

 *     int val;

 *     ListNode *next;

 *     ListNode(int x) : val(x), next(NULL) {}

 * };

 */
class Solution {
    public:
        bool judge(ListNode* head, int cnt) {
            ListNode* tmp = head;
            int t = 0;
            while(tmp) {
                ++t; 
                if(t == cnt&amp;gt;&amp;gt;1) {
                    if(tmp-&amp;gt;val != tmp-&amp;gt;next-&amp;gt;val)
                        return false;
                    else {
                        if(cnt == 2) return true;
                        tmp-&amp;gt;val = tmp-&amp;gt;next-&amp;gt;next-&amp;gt;val;
                        tmp-&amp;gt;next = tmp-&amp;gt;next-&amp;gt;next-&amp;gt;next;
                        return judge(head, cnt-2);
                    }
                }
                tmp = tmp-&amp;gt;next;
            }
        }
        bool isPalindrome(ListNode* head) {
            ListNode* tmp = head;
            int cnt = 0;
            while(tmp) {
                ++cnt;
                tmp = (tmp-&amp;gt;next);
            }
            if(cnt == 1 || cnt == 0) return true;
            if(cnt &amp;amp; 1) {
                int t = 0;
                tmp = head;
                while(tmp) {
                    ++t;
                    if(t == (cnt+1)&amp;gt;&amp;gt;1)
                        break;
                    tmp = (tmp-&amp;gt;next);
                }
                tmp-&amp;gt;val = tmp-&amp;gt;next-&amp;gt;val;
                tmp-&amp;gt;next = tmp-&amp;gt;next-&amp;gt;next;
                return judge(head, cnt-1);
            } else return judge(head, cnt);
        }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;题目中提示存在时间O（n）、空间O（1）的算法&lt;/p&gt;

&lt;p&gt;后来苦苦想了几个小时也没想出来，在网上查找相关资料发现有种神奇的&lt;code&gt;快慢指针&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;就是先利用&lt;code&gt;快慢指针&lt;/code&gt;找到链表中间位置，将后半段倒序处理后与前半段一次比较即可（可以借助栈来实现，此时空间复杂度为O（n））&lt;/p&gt;

&lt;p&gt;&lt;code&gt;快慢指针&lt;/code&gt;的应用还有很多，这里限于篇幅就不一一赘述了&lt;/p&gt;

&lt;p&gt;改进后代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;CPP&quot;&gt;/**

 * Definition for singly-linked list.

 * struct ListNode {

 *     int val;

 *     ListNode *next;

 *     ListNode(int x) : val(x), next(NULL) {}

 * };

 */
class Solution {
    public:
        void reverse(ListNode* head) {
            if(head==NULL || head-&amp;gt;next==NULL) 
                return ;
            ListNode* preNode = NULL;
            ListNode* thisNode = head;
            ListNode* nextNode = head-&amp;gt;next;

            while(thisNode) {
                thisNode-&amp;gt;next = preNode;
                preNode = thisNode;
                thisNode = nextNode;
                if(nextNode)
                    nextNode = nextNode-&amp;gt;next ? nextNode-&amp;gt;next : NULL;
            }
        }
        bool isPalindrome(ListNode* head) {
            if(head==NULL || head-&amp;gt;next==NULL)
                return true;
            ListNode* fast = head;
            ListNode* slow = head;

            while(fast-&amp;gt;next != NULL) {
                fast = fast-&amp;gt;next;
                if(fast-&amp;gt;next != NULL) {
                    fast = fast-&amp;gt;next;
                    slow = slow-&amp;gt;next;
                }
            }

            ListNode* mid = slow-&amp;gt;next;
            reverse(mid);
            ListNode* p1 = head;
            ListNode* p2 = fast;
            while(p1 &amp;amp;&amp;amp; p2) {
                if(p1-&amp;gt;val != p2-&amp;gt;val) {
                    reverse(fast);
                    slow-&amp;gt;next = mid;
                    return false;
                }
                p1 = p1-&amp;gt;next;
                p2 = p2-&amp;gt;next;
            }
            reverse(fast);
            slow-&amp;gt;next = mid;
            return true;
        }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这份代码值得一说的就是在判断完成后又将链表逆置了一遍，从而保证不改变原链表结构&lt;/p&gt;
</description>
          <pubDate>2015-07-25T00:00:00+08:00</pubDate>
          <link>/coding/leetcode-234-palindrome-linked-list%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88.html</link>
          <guid isPermaLink="true">/coding/leetcode-234-palindrome-linked-list%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88.html</guid>
        </item>
      
    
      
        <item>
          <title>LeetCode 2 Add Two Numbers （单链表相加）</title>
          <description>&lt;p&gt;题目是给两个链表，对两个链表进行相加操作&lt;/p&gt;

&lt;p&gt;相加结果仅取个位，若大于10，向下一位进1&lt;/p&gt;

&lt;p&gt;这题要考虑的情况主要有以下几种：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、一个链表为空，返回另一个非空链表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、两个都为空，返回空&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、两个链表长度不同，处理完相同部分，对较长的链表单独处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4、存在连续进位&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实题目比较简单，但自己在指针操作方面确实不熟练，因此花费了很多时间&lt;/p&gt;

&lt;p&gt;一个比较容易处理的方法就是用vector保存相加结果，最后放到一个链表中即可&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;//time:40ms
class Solution {
    public:
        ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

            if(!l1 &amp;amp;&amp;amp; !l2) return l1;
            if(!l1 || !l2) {
                if(!l1) return l2;
                if(!l2) return l1;
            }

            vector&amp;lt;int&amp;gt; vec;

            int tmp = 0;
            while(l1 &amp;amp;&amp;amp; l2) {
                vec.push_back((l1-&amp;gt;val+l2-&amp;gt;val+tmp)%10);
                tmp = (l1-&amp;gt;val+tmp+l2-&amp;gt;val)/10;
                l1 = l1-&amp;gt;next;
                l2 = l2-&amp;gt;next;
            }

            ListNode* ans = new ListNode(0);
            ListNode* res = ans;
            for(int i=0; i&amp;lt;vec.size(); ++i) {
                ans-&amp;gt;val = vec[i];
                if(i == vec.size()-1) break;
                ans-&amp;gt;next = new ListNode(0);
                ans = ans-&amp;gt;next;
            }
            while(l1 || l2) {
                if(l1) {
                    int x = l1-&amp;gt;val;
                    l1-&amp;gt;val = (l1-&amp;gt;val+tmp)%10;
                    tmp = (x+tmp)/10;
                    ans-&amp;gt;next = l1;
                    l1 = l1-&amp;gt;next;
                }
                if(l2) {
                    int x = l2-&amp;gt;val;
                    l2-&amp;gt;val = (l2-&amp;gt;val+tmp)%10;
                    tmp  = (x+tmp)/10;
                    ans-&amp;gt;next = l2;
                    l2 = l2-&amp;gt;next;
                }
                ans = ans-&amp;gt;next;
            }
            if(tmp) {
                ans-&amp;gt;next = new ListNode(tmp);
            }

            return res;
        }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实完全可以不用&lt;code&gt;vector&lt;/code&gt;的，依次遍历并处理即可，遵循一个原则&lt;code&gt;每次需要时对存答案的单链表进行扩展&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;//time:36ms
class Solution {
    public:
        ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

            if(!l1 &amp;amp;&amp;amp; !l2) return l1;
            if(!l1 || !l2) {
                if(!l1) return l2;
                if(!l2) return l1;
            }

            ListNode* ans = new ListNode(0);
            ListNode* end = ans;
            ListNode* ll1 = l1;
            ListNode* ll2 = l2;

            int tmp = 0;
            while(l1 &amp;amp;&amp;amp; l2) {
                ans-&amp;gt;val = (l1-&amp;gt;val+l2-&amp;gt;val+tmp)%10;
                tmp = (l1-&amp;gt;val+tmp+l2-&amp;gt;val)/10;
                l1 = l1-&amp;gt;next;
                l2 = l2-&amp;gt;next;

                if(l1 &amp;amp;&amp;amp; l2) {
                    ans-&amp;gt;next = new ListNode(0);
                    ans = ans-&amp;gt;next;
                }
            }

            if(l1 || l2) {
                ans-&amp;gt;next = new ListNode(0);
                ans = ans-&amp;gt;next;
            }

            while(l1 || l2) {
                if(l1) {
                    int x = l1-&amp;gt;val;
                    ans-&amp;gt;val = (l1-&amp;gt;val+tmp)%10;
                    tmp = (tmp+x)/10;
                    l1 = l1-&amp;gt;next;
                    if(l1) {
                        ans-&amp;gt;next = new ListNode(0);
                        ans = ans-&amp;gt;next;
                    }
                } 
                if(l2) {
                    int x = l2-&amp;gt;val;
                    ans-&amp;gt;val = (l2-&amp;gt;val+tmp)%10;
                    tmp = (tmp+x)/10;
                    l2 = l2-&amp;gt;next;
                    if(l2) {
                        ans-&amp;gt;next = new ListNode(0);
                        ans = ans-&amp;gt;next;
                    }
                }
            }
            if(tmp) {
                ans-&amp;gt;next = new ListNode(tmp);
            }

            return end;
        }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
          <pubDate>2015-07-25T00:00:00+08:00</pubDate>
          <link>/coding/leetcode-2-add-two-numbers-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0.html</link>
          <guid isPermaLink="true">/coding/leetcode-2-add-two-numbers-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0.html</guid>
        </item>
      
    
      
        <item>
          <title>LeetCode 1 Two Sum（哈希）</title>
          <description>&lt;p&gt;题意是给出一串数字以及一个target（保证有一解）&lt;/p&gt;

&lt;p&gt;找出满足两数之和等于target的两个数的下标（下标从1开始）&lt;/p&gt;

&lt;p&gt;一个简单的想法就是直接暴力，时间复杂度&lt;code&gt;O（n*n）&lt;/code&gt;，超时&lt;/p&gt;

&lt;p&gt;然后可以想到对这串数字排序，排序后从两边向中间找&lt;/p&gt;

&lt;p&gt;但是有一个很棘手的问题就是这串数字中一对相同的数是答案，比如&lt;code&gt;[0，3，4，0]&lt;/code&gt;;&lt;code&gt;target=0&lt;/code&gt;此时答案应该是&lt;code&gt;1， 4&lt;/code&gt;；找出这对答案要保证不重复找某个数（如输出&lt;code&gt;1， 1&lt;/code&gt;或&lt;code&gt;4， 4&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;我的方法是先找到一个数后，在排除这个数后的数字串里寻找另一个数。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Solution {
    public:
        vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
            vector&amp;lt;int&amp;gt; ans;
            vector&amp;lt;int&amp;gt; tmp(nums.begin(), nums.end());
            sort(tmp.begin(), tmp.end());
            int i = 0;
            int j = tmp.size()-1;
            while(i &amp;lt; j) {
                if(tmp[i]+tmp[j] &amp;gt; target) {
                    --j;
                } else if(tmp[i]+tmp[j] &amp;lt; target) {
                    ++i;
                } else {
                    int x = find(nums.begin(), nums.end(), tmp[i])-nums.begin();
                    int y = find(nums.begin()+x+1, nums.end(), tmp[j])-nums.begin();//在后半段内找
                    if(y == nums.size()) {//找不到的情况下在前半段内找
                        y = find(nums.begin(), nums.begin()+x, tmp[j])-nums.begin();
                    }
                    ans.push_back(min(x, y)+1);
                    ans.push_back(x+y-min(x, y)+1);
                    return ans;
                }
            }
        }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看答案讨论区有一个很好的想法，就是&lt;code&gt;hash&lt;/code&gt;处理&lt;/p&gt;

&lt;p&gt;对当前的&lt;code&gt;nums[i]&lt;/code&gt;，用&lt;code&gt;map&lt;/code&gt;保存&lt;code&gt;&amp;lt;target-nums[i], i+1&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;那么每遇到一个&lt;code&gt;nums[i]&lt;/code&gt;的时候，就可以考察&lt;code&gt;map[nums[i]]&lt;/code&gt;是否为0，不为0说明在之前已经出现过&lt;code&gt;target-nums[i]&lt;/code&gt;，则输出&lt;code&gt;&amp;lt;map[nums[i]], i+1&amp;gt;&lt;/code&gt;即可&lt;/p&gt;

&lt;p&gt;想发很巧妙，但因为使用了map，导致效率不如第一份代码效率高&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Solution {
    public:
        vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
            vector&amp;lt;int&amp;gt; ans;
            map&amp;lt;int, int&amp;gt; mp;
            int len = nums.size();

            for(int i=0; i&amp;lt;len; ++i) {
                if(mp[nums[i]] != 0) {
                    ans.push_back(mp[nums[i]]);
                    ans.push_back(i+1);
                    return ans;
                } else {
                    mp[target-nums[i]] =  i+1;
                }
            }
        }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
          <pubDate>2015-07-25T00:00:00+08:00</pubDate>
          <link>/coding/leetcode-1-two-sum%E5%93%88%E5%B8%8C.html</link>
          <guid isPermaLink="true">/coding/leetcode-1-two-sum%E5%93%88%E5%B8%8C.html</guid>
        </item>
      
    
      
        <item>
          <title>LeetCode 238（数学）</title>
          <description>&lt;p&gt;题目的意思是给定一个数组，让你输出另一个数组，这个数组中每个元素的值为给定数组中除该位置外剩余所有元素的乘积。&lt;/p&gt;

&lt;p&gt;例如输入&lt;code&gt;[1,2,3,4]&lt;/code&gt;，输出&lt;code&gt;[24,12,8,6]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;要求：不能使用除法，且时间复杂度在O（n）内&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实题目中说明了不能使用除法就比较容易想到把&lt;code&gt;一个数左右两侧的所有数乘起来&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;但是题目处理要两次处理，从左至右求每个数  左侧所有数的积  和从右至左求每个数  右侧所有数的积&lt;/p&gt;

&lt;p&gt;考虑到题目的  	&lt;strong&gt;&lt;code&gt; 提高：使用常数空间来完成题目&lt;/code&gt;&lt;/strong&gt;，所以可以每次扫描使用一个数来记录该数一侧的乘积&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class Solution {
	public:
		vector&amp;lt;int&amp;gt; productExceptSelf(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
			vector&amp;lt;int&amp;gt; ans;
			int l = 1, r = 1;

			ans.push_back(1);//第一个数的左侧乘积
			for(int i=1; i&amp;lt;nums.size(); ++i) {
				ans.push_back(l*nums[i-1]);//每个数左侧乘积等于上个数左侧乘积乘以上个数
				l *= nums[i-1];
			}

			for(int i=nums.size()-2; i&amp;gt;=0; --i) {
				ans[i] = ans[i]*r*nums[i+1];//每个数右侧乘积等于上个数右侧乘积乘以上个数
				r *= nums[i+1];
			}

			retuan ans;
		}
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
          <pubDate>2015-07-24T00:00:00+08:00</pubDate>
          <link>/coding/leetcode-238-product-of-array-except-self%E6%95%B0%E5%AD%A6.html</link>
          <guid isPermaLink="true">/coding/leetcode-238-product-of-array-except-self%E6%95%B0%E5%AD%A6.html</guid>
        </item>
      
    
      
        <item>
          <title>LeetCode 237 Delete Node in a Linked List （数据结构）</title>
          <description>&lt;p&gt;题意是删除单链表的某个节点，确实是基本没做过链表的题，导致一直在想怎么把待删除节点的上一个节点与下一个节点连接起来；很明显这么做很困难，因为单链表从当前节点找上一节点确实很困难。&lt;/p&gt;

&lt;p&gt;正确的做法是令当前节点等于下一节点，然后把下一节点删除即可。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;/**
 
 * Definition for singly-linked list.
 
 * struct ListNode {
 
 *     int val;
 
 *     ListNode *next;
 
 *     ListNode(int x) : val(x), next(NULL) {}

 * };

 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        if(node != NULL &amp;amp;&amp;amp; node-&amp;gt;next!=NULL) {
            node-&amp;gt;val = (node-&amp;gt;next)-&amp;gt;val;
            node-&amp;gt;next = (node-&amp;gt;next)-&amp;gt;next;
        }
    }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
          <pubDate>2015-07-24T00:00:00+08:00</pubDate>
          <link>/coding/leetcode-237-delete-node-in-a-linked-list-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</link>
          <guid isPermaLink="true">/coding/leetcode-237-delete-node-in-a-linked-list-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</guid>
        </item>
      
    
      
        <item>
          <title>LeetCode 236 （数据结构+DFS）</title>
          <description>&lt;p&gt;是二叉搜索树求LCA的加强版，这里是对普通的二叉树给定两点p, q求LCA&lt;/p&gt;

&lt;p&gt;最初的想法是对于树中每个节点判断两个点p, q是否在它的同一侧，结果超时了&lt;/p&gt;

&lt;p&gt;然后就想到在判断两点p, q是否在某个节点同一侧时存在大量的重复性工作&lt;/p&gt;

&lt;p&gt;因此想到用深搜找到从根节点到p, q的路径，再找到路径从下到上的第一个公共点&lt;/p&gt;

&lt;p&gt;这样就容易做了，但是被卡了很久，因为我理解的两个节点相等是两个节点值相等。。。&lt;/p&gt;

&lt;p&gt;所以悲剧了一下午⊙﹏⊙b&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、这里是我最开始的想法，大量重复查找因此超时&lt;/p&gt;

&lt;/blockquote&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;/**

 * Definition for a binary tree node.

 * struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}

 * };

 */
class Solution {
public:
    bool exist(TreeNode* root, TreeNode* tmp) {//判断tmp节点是否是root节点的子节点
        if(root == NULL) return false;
        if(root-&amp;gt;val == tmp-&amp;gt;val) {
            return true;
        }
        return exist(root-&amp;gt;left, tmp)||exist(root-&amp;gt;right, tmp);
    }
    int find(TreeNode* root, TreeNode* p, TreeNode* q) {//分别判断左右两侧
        if(exist(root-&amp;gt;left, p) &amp;amp;&amp;amp; exist(root-&amp;gt;left, q)) return -1;
        if(exist(root-&amp;gt;right, p) &amp;amp;&amp;amp; exist(root-&amp;gt;right, q)) return 1;
        return 0;
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(find(root, p, q) == -1) return lowestCommonAncestor(root-&amp;gt;left, p, q);
        if(find(root, p, q) == 1) return lowestCommonAncestor(root-&amp;gt;right, p, q);
        return root;
    }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、深搜找到路径从而求LCA&lt;/p&gt;

&lt;/blockquote&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;/**

 * Definition for a binary tree node.

 * struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}

 * };

 */
class Solution {
    public:
        stack&amp;lt;TreeNode*&amp;gt; st;
        bool find(TreeNode* root, TreeNode *tmp, vector&amp;lt;TreeNode*&amp;gt;&amp;amp; ans) {
            st.push(root);
            if(root == tmp) {
                while(!st.empty()) {
                    ans.push_back(st.top());
                    st.pop();
                }
                return true;
            }
            if(root-&amp;gt;left != NULL) {
                if(find(root-&amp;gt;left, tmp, ans))
                    return true;
            }
            if(root-&amp;gt;right != NULL) {
                if(find(root-&amp;gt;right, tmp, ans))
                    return true;
            }
            st.pop();      
            return false;
        }
        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
            vector&amp;lt;TreeNode*&amp;gt; x, y;
            while(!st.empty()) st.pop();
            find(root, p, x);
            while(!st.empty()) st.pop();
            find(root, q, y);
            for(int i=0; i&amp;lt;x.size(); ++i) {
                for(int j=0; j&amp;lt;y.size(); ++j) {
                    if(x[i] == y[j])
                        return x[i];
                }
            }
            return root;
        }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、对于上面的代码，答案虽然是对的，但是写的不好，使用的栈明显多余；看下面这份网友 mako 的 &lt;a href=&quot;https://leetcode.com/discuss/46563/c-solution-with-simple-dfs&quot;&gt;代码&lt;/a&gt;：&lt;/p&gt;

&lt;/blockquote&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;/**
 * Definition for a binary tree node.
 
 * struct TreeNode {
 
 *     int val;
 
 *     TreeNode *left;
 
 *     TreeNode *right;
 
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 
 * };
 
 */
class Solution {
    public:
        bool dfs(TreeNode* root, TreeNode *tmp, vector&amp;lt;TreeNode*&amp;gt;&amp;amp; ans) {
            if(root == NULL) return false;
            ans.push_back(root);
            if(root == tmp) return true;
            if(dfs(root-&amp;gt;left, tmp, ans))
                return true;
            if(dfs(root-&amp;gt;right, tmp, ans))
                return true;
            ans.pop_back();
            return false;
        }
        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
            vector&amp;lt;TreeNode*&amp;gt; x, y;
            dfs(root, p, x);
            dfs(root, q, y);
            int cnt = min(x.size(), y.size());
            TreeNode* ans;
            for(int i=0; i&amp;lt;cnt; ++i) {
                if(x[i] == y[i])
                    ans = x[i];
                else break;
            }
            return ans;
        }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;虽然后面两份代码跑的样例都是28ms，但理论上来说第三份代码优化地更好，而且具有更好的易读性&lt;/p&gt;
</description>
          <pubDate>2015-07-24T00:00:00+08:00</pubDate>
          <link>/coding/leetcode-236-lowest-common-ancestor-of-a-binary-tree-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</link>
          <guid isPermaLink="true">/coding/leetcode-236-lowest-common-ancestor-of-a-binary-tree-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</guid>
        </item>
      
    
      
        <item>
          <title>LeetCode 235（数据结构）</title>
          <description>&lt;p&gt;题意是对一颗给定的二叉搜索树，寻找两个节点的最短公共祖先，&lt;code&gt;ps:一个节点的最短公共祖先可以是它自己&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里要考虑到二叉搜索树的性质：每个根节点左侧所有节点的值要比根节点值小，右侧所有节点的值要比根节点值大&lt;/p&gt;

&lt;p&gt;所以我们应用这个性质递归操作即可：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、若两个节点的值都比当前根节点值小，向左侧递归&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、若两个节点的值都比当前根节点值小，向右侧递归&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、若两个节点的值与根节点差值相乘小于等于0，说明当前节点为LCA&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;/**

 * Definition for a binary tree node.

 * struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}

 * };

 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(p-&amp;gt;val&amp;lt;root-&amp;gt;val &amp;amp;&amp;amp; q-&amp;gt;val&amp;lt;root-&amp;gt;val) {
            return lowestCommonAncestor(root-&amp;gt;left, p, q);
        }
        if(p-&amp;gt;val&amp;gt;root-&amp;gt;val &amp;amp;&amp;amp; q-&amp;gt;val&amp;gt;root-&amp;gt;val) {
            return lowestCommonAncestor(root-&amp;gt;right, p, q);
        }
        if((p-&amp;gt;val-root-&amp;gt;val)*(q-&amp;gt;val-root-&amp;gt;val) &amp;lt;= 0)
            return root;
    }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
          <pubDate>2015-07-24T00:00:00+08:00</pubDate>
          <link>/coding/leetcode-235-lowest-common-ancestor-of-a-binary-search-tree%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</link>
          <guid isPermaLink="true">/coding/leetcode-235-lowest-common-ancestor-of-a-binary-search-tree%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</guid>
        </item>
      
    
      
        <item>
          <title>正则表达式学习</title>
          <description>&lt;p&gt;学习php的过程中接触了正则表达式，想到自己封存了一个月之久的正则表达式教程也该重见天日了！&lt;/p&gt;

&lt;p&gt;教程地址：&lt;a href=&quot;http://deerchao.net/tutorials/regex/regex.htm&quot;&gt;正则表达式30分钟入门教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;版权声明：本文是在学习上述教程过程中编写；如有雷同，纯属学习！&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;section&quot;&gt;元字符&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;1、&lt;code&gt;\b&lt;/code&gt;是正则表达式规定的一个元字符，代表着单词的开头或结尾;所以我们可以通过&lt;code&gt;\bhello\b&lt;/code&gt;来匹配一个hello&lt;strong&gt;单词&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;2、&lt;code&gt;.&lt;/code&gt;同样是一个元字符，匹配除换行符之外的任意字符&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;3、&lt;code&gt;*&lt;/code&gt;是一个元字符，它代表数量，表明&lt;code&gt;*&lt;/code&gt;前字符可以出现任意次数
&amp;gt; 综上  &lt;code&gt;\bhi\b.*\bLucy\b &lt;/code&gt; 就是匹配先出现&lt;strong&gt;单词&lt;/strong&gt; hi hi之后跟任意数量个非换行符外的其他字符，再接着是&lt;strong&gt;单词&lt;/strong&gt; Lucy 的情况&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;4、&lt;code&gt;\d&lt;/code&gt;是一个元字符，匹配任意一个数字；&lt;code&gt;\d{5}&lt;/code&gt; 这种形式则表示匹配5个数字&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;5、&lt;code&gt;\s&lt;/code&gt;是一个元字符，匹配任意空白字符，包括空格、制表符、换行符等&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;6、&lt;code&gt;\w&lt;/code&gt;匹配&lt;strong&gt;字母、数字、下划线或汉字等&lt;/strong&gt;
&amp;gt; 举几个栗子便于理解：
  &amp;gt; 1、&lt;code&gt;\ba\w*\b&lt;/code&gt;匹配以a开头的&lt;strong&gt;单词&lt;/strong&gt;（这里的单词可以含下划线或汉字，取决于\w的定义）
  &amp;gt; 2、&lt;code&gt;\d+&lt;/code&gt;匹配1个或多个连续的数字； &lt;strong&gt;+与&lt;code&gt;*&lt;/code&gt;的不同之处在于：&lt;code&gt;*&lt;/code&gt;可以匹配0次或多次，而+匹配1次或多次&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;7、 &lt;code&gt;^&lt;/code&gt;匹配字符串的开始；&lt;code&gt;$&lt;/code&gt;匹配字符串的结束； &lt;code&gt;^\d{5,12}$&lt;/code&gt;就可以用来匹配5-12位的数字&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;section-1&quot;&gt;字符转义&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;8、字符转义：如果想在字符串中匹配&lt;code&gt;.&lt;/code&gt;或&lt;code&gt;*&lt;/code&gt;时需要对字符进行转义，可以用’'加元字符来进行转义；举个栗子：windows系统中&lt;code&gt;C:\\Windows&lt;/code&gt;即为&lt;code&gt;C:\Windows&lt;/code&gt;。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;section-2&quot;&gt;重复限定符&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;9、限定符，对于&lt;code&gt;'*'、'+'、'?'、{n}&lt;/code&gt;均为限定符；下面给出限定符以及对应的含义
&amp;gt;  	&lt;code&gt;*：&lt;/code&gt;		重复零次或更多次 &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;pre&gt;&lt;code&gt;`+：`		重复一次或更多次
&lt;/code&gt;&lt;/pre&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;pre&gt;&lt;code&gt;`?：`		重复零次或一次
&lt;/code&gt;&lt;/pre&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;pre&gt;&lt;code&gt;`{n}：`	重复n次
&lt;/code&gt;&lt;/pre&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;pre&gt;&lt;code&gt;`{n,}：`	重复n次或更多次
&lt;/code&gt;&lt;/pre&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;pre&gt;&lt;code&gt;`{n,m}：`	重复n到m次
&lt;/code&gt;&lt;/pre&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;section-3&quot;&gt;字符类&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;10、如果想匹配没有预定义元字符的字符集合，比如&lt;code&gt;元音字母（a、e、i、o、u）&lt;/code&gt;时，只需在方括号中列出来就可以了，即&lt;code&gt;[aeiou]&lt;/code&gt;；
&amp;gt; 举个栗子：对于&lt;code&gt;\(?0\d{2}[) -]?\d{8}&lt;/code&gt;，是指以&lt;code&gt;(&lt;/code&gt;开头后跟零个或一个数字0，接着是两个数字，然后跟0零个或一个&lt;code&gt;)&lt;/code&gt;、&lt;code&gt; &lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;中的任一个，再跟8个数字；比如&lt;code&gt;(010)88886666&lt;/code&gt;、&lt;code&gt;022-22334455&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;section-4&quot;&gt;分支条件&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;11、分支条件：满足几种规则中的任意一种即为匹配；判断是否满足时按照从左到右的顺序，一旦发现满足的条件即退出判断说明判断成功。
&amp;gt; 举个栗子：&lt;code&gt;\d{5}-\d{4}|\d{5}&lt;/code&gt;即表示用连字符分隔的9位数字或5位数字；如果写成&lt;code&gt;\d{5}|\d{5}-\d{4}&lt;/code&gt;则遇到形如&lt;code&gt;12345-6789&lt;/code&gt;的数字串会匹配成前5个数字&lt;code&gt;12345&lt;/code&gt;；说明分支条件顺序的重要性。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;section-5&quot;&gt;分组&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;12、当我们想重复单个字符时可以在这个字符后加限定符；而当我们想重复多个字符时可以使用小括号来指定&lt;strong&gt;分组&lt;/strong&gt;
&amp;gt; 举个栗子：&lt;code&gt;(\d{1,3}\.){3}\d{1,3}&lt;/code&gt;表示一个简单的IP地址（不考虑某一位大于255情况），很容易看出来&lt;code&gt;(\d{1,3}\.){3}&lt;/code&gt;表示三个以1-3位数字后跟 . 组成的串，后面再跟一个1-3位数字；给出一个正确的IP地址匹配正则表达式&lt;code&gt;((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)&lt;/code&gt;相信看官认真看时可以看懂的…&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;section-6&quot;&gt;反义&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;13、反义：查找除某些字符外的其他字符；只需把之前讲的几个元字符改为大写即可；比如：
&amp;gt; &lt;code&gt;\W&lt;/code&gt;匹配&lt;code&gt;任意不是字母、数字、下划线或汉字的字符&lt;/code&gt;；
&amp;gt; &lt;code&gt;\S&lt;/code&gt; 匹配 &lt;code&gt;任意不是空白符的字符&lt;/code&gt;
&amp;gt; &lt;code&gt;\D&lt;/code&gt; 匹配 &lt;code&gt;任意非数字的字符&lt;/code&gt;
&amp;gt; &lt;code&gt;\B&lt;/code&gt; 匹配 &lt;code&gt;不是单词开始或结束的位置&lt;/code&gt;
&amp;gt; &lt;code&gt;[^x]&lt;/code&gt;匹配 &lt;code&gt;除x以外的任意字符&lt;/code&gt;
&amp;gt; &lt;code&gt;[^aeiou]&lt;/code&gt; 匹配 &lt;code&gt;除a e i o u以外的任意字符&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;section-7&quot;&gt;后向引用&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;14、后向引用；前面讲过用小括号进行分组，其实正则表达式会默认对分组从左向右进行编号；分组0对应整个正则表达式；后向引用用于重复搜索前面某个分组匹配的文本；
&amp;gt; 举个栗子：&lt;code&gt;\b(\w+)\b\s+\1\b&lt;/code&gt;用于匹配重复的单词，形如&lt;code&gt;ha ha&lt;/code&gt;、&lt;code&gt;he he&lt;/code&gt;等；其中&lt;code&gt;\b(\w+)\b&lt;/code&gt;用于匹配一个单词（并非严格意义的单词，用&lt;code&gt;word&lt;/code&gt;形容更贴切）；这个单词作为一个分组会被编号为1；因此&lt;code&gt;\s+\1\b&lt;/code&gt;是指多个空白符后跟上一步匹配的单词&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
 	也可以自己指定分组名，使用&lt;code&gt;(?&amp;lt;word&amp;gt;\w+)&lt;/code&gt;或&lt;code&gt;(?'word'\w+)&lt;/code&gt;就可以把&lt;code&gt;\w+&lt;/code&gt;组名指定为word了；当需要后向引用这个分组时可以使用&lt;code&gt;\k&amp;lt;word&amp;gt;&lt;/code&gt;引用
  &lt;pre&gt;&lt;code&gt;后向引用还有更复杂的操作，这里就不再枚举了，有兴趣的朋友可以访问教程源地址进行深入了解
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;section-8&quot;&gt;零宽断言&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;15、零宽断言：用于查找某些特定位置的内容；&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;(?=exp)&lt;/code&gt;也叫&lt;strong&gt;零宽度正预测先行断言&lt;/strong&gt;；它匹配自身出现位置后的表达式exp；比如&lt;code&gt;\b\w+(?=ing\b)&lt;/code&gt;匹配以ing结尾单词的前面部分。对于&lt;code&gt;I'm singing while you're dancing&lt;/code&gt;会匹配&lt;code&gt;sing&lt;/code&gt;和&lt;code&gt;danc&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;(?&amp;lt;=exp)&lt;/code&gt;也叫&lt;strong&gt;零宽度正回顾后发断言&lt;/strong&gt;；它匹配自身出现位置前的表达式exp；比如&lt;code&gt;(?&amp;lt;=\bre)\w+\b&lt;/code&gt;匹配以re开头单词的后面部分。对于&lt;code&gt;I'm reading a novel&lt;/code&gt;会匹配&lt;code&gt;ading&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;p&gt;举个栗子：&lt;code&gt;(?&amp;lt;=\s)\d+(?=\s)&lt;/code&gt;匹配以空白符间隔的数字&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;section-9&quot;&gt;零宽度负预测先行断言&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;16、先看一个栗子：我们现在相匹配一个含有字母q，且q后面不跟u的单词；使用：&lt;code&gt;\b\w*q[^u]\w*\b&lt;/code&gt;很容易理解是匹配一个q后面不是u的单词；但这里有个问题就是[^u]是指匹配不是u的任意字符（也就是说一定要匹配一个字符），那么这个正则表达式就与我们的出发点不一致了（因为p如果在单词的最后一位，可能会导致匹配两个单词；比如会匹配&lt;code&gt;Iraq fighting&lt;/code&gt;）；&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;这个时候我们就需要使用&lt;strong&gt;零宽度负预测先行断言(?!exp)&lt;/strong&gt;了，意思是&lt;code&gt;匹配后面不是exp的结果&lt;/code&gt;；对于&lt;code&gt;\d{3}(?!\d)&lt;/code&gt;即匹配一个三位数字，且这三位数字后不跟数字&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;同上还有一个&lt;strong&gt;零宽度负回顾后发断言(?&amp;lt;!exp)&lt;/strong&gt;来&lt;code&gt;匹配前面不是exp的结果&lt;/code&gt;；比如&lt;code&gt;(?&amp;lt;[a-z])\d{7}&lt;/code&gt;匹配前面不是小写字母的七个数字&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;举一个重要的栗子：&lt;code&gt;(?&amp;lt;=&amp;lt;(\w+)&amp;gt;).*(?=&amp;lt;\/\1&amp;gt;)&lt;/code&gt;用于匹配不含属性的简单HTML标签内的内容&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;section-10&quot;&gt;注释&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;17、可以通过语法&lt;code&gt;(?#comment)&lt;/code&gt;来包含注释&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;section-11&quot;&gt;贪婪与懒惰&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;18、当正则表达式中包含能接受重复的限定符时，默认时匹配尽可能多的字符，如&lt;code&gt;a.*b&lt;/code&gt;对于&lt;code&gt;aabab&lt;/code&gt;会匹配&lt;code&gt;aabab&lt;/code&gt;而不是&lt;code&gt;ab&lt;/code&gt;或&lt;code&gt;abab&lt;/code&gt;； 我们称这种匹配方式为&lt;strong&gt;贪婪匹配&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;与之对应的就是&lt;strong&gt;懒惰匹配&lt;/strong&gt;会匹配尽可能少的字符；把贪婪匹配转为懒惰匹配的方法就是在对应限定符后加&lt;code&gt;？&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;h4 id=&quot;section-12&quot;&gt;懒惰限定符&lt;/h4&gt;
    &lt;p&gt;&lt;code&gt;*?&lt;/code&gt;	： &lt;code&gt;重复任意次，但尽可能少重复&lt;/code&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;code&gt;+?&lt;/code&gt;	： &lt;code&gt;重复1次或更多次，但尽可能少重复&lt;/code&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;code&gt;??&lt;/code&gt;	：&lt;code&gt;重复0次或1次，但尽可能少重复&lt;/code&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;code&gt;{n,m}?&lt;/code&gt;	： &lt;code&gt;重复n到m次，但尽可能少重复&lt;/code&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;code&gt;{n,}?&lt;/code&gt;	： &lt;code&gt;重复n次以上，但尽可能少重复&lt;/code&gt;
* &lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section-13&quot;&gt;写在最后&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;还有一部分内容没有涉及，原因是太复杂了且不常用，现在学习了不用也会很快忘记，所以我选择在需要的时候再去学习吧！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;正则表达式的学习到这里就告一段落了！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
          <pubDate>2015-07-12T00:00:00+08:00</pubDate>
          <link>/coding/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0.html</link>
          <guid isPermaLink="true">/coding/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0.html</guid>
        </item>
      
    
      
        <item>
          <title>php学习笔记</title>
          <description>&lt;p&gt;php是一种弱的面向对象语言，所以很多东西与c++、java都有类似之处，写这篇博客的目的是记录学习中的重点、难点；而不是入门教程。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;1、 php中单、双引号都可以用来定义字符串，这在一定程度上解决了字符串嵌套问题；但二者并不完全等价，区别在双引号中可以包含字符串变量，例如以下代码&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;&amp;lt;?php
    		$str = 'hello world';
    		echo 'str is $str&amp;lt;br/&amp;gt;';
    		echo &amp;quot;str is $str&amp;quot;;
	?&amp;gt;
	输出结果为：
		str is $str
		str is hello world&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;2、&lt;code&gt;strlen($str)&lt;/code&gt;用于获取$str长度，对于非ascii编码，可以使用 &lt;strong&gt;&lt;code&gt;mb_strlen($str, &quot;UTF8&quot;)&lt;/code&gt;获取以UTF8编码时$str的长度&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;3、&lt;code&gt;substr($str, $start, $len)&lt;/code&gt;用于截取$str字符串从$start位置开始的$len个字符，同理对于非ascii编码，可以使用 &lt;strong&gt;&lt;code&gt;mb_strlen($str, $start, $len, &quot;UTF8&quot;)&lt;/code&gt;获取以UTF8编码时$str的长度&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;4、&lt;code&gt;preg_match($pre, $str)&lt;/code&gt;用于对$str执行一个$pre正则表达式；例如&lt;code&gt;preg_match(&quot;/apple&quot;, &quot;apple banana&quot;)&lt;/code&gt;会返回true表示”apple banana”中含有”apple”字符串&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;php&quot;&gt;PHP中超全局变量&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;PHP超全局变量，常见的有以下：&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;code&gt;$GLOBALS&lt;/code&gt;用于访问PHP中的全局变量，形如&lt;code&gt;GLOBALS['x']&lt;/code&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;code&gt;$_SERVER[]&lt;/code&gt;用于访问保存关于报头、路径和脚本位置的信息&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;code&gt;$_REQUEST&lt;/code&gt;用于收集HTML表单提交的数据&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;code&gt;$_POST&lt;/code&gt;用于收集提交 &lt;code&gt;method=&quot;post&quot;&lt;/code&gt;的HTML表单后的表单数据&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;同上&lt;code&gt;$_GET&lt;/code&gt;用于收集提交&lt;code&gt;method=&quot;get&quot;&lt;/code&gt;的HTML表单后的表单数据&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;php-1&quot;&gt;PHP中的输出&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;较常见的PHP输出有&lt;code&gt;echo&lt;/code&gt;、&lt;code&gt;print&lt;/code&gt;、&lt;code&gt;print_r()&lt;/code&gt;、&lt;code&gt;var_dump()&lt;/code&gt;几种形式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;echo&lt;/code&gt;是一个语言结构，无返回值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;print&lt;/code&gt;也是一个语言结构，速度稍慢于&lt;code&gt;echo&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;print_r()&lt;/code&gt;用于打印变量的易于理解的信息&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;getpost&quot;&gt;&lt;code&gt;GET&lt;/code&gt;与&lt;code&gt;POST&lt;/code&gt;的区别&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;GET&lt;/code&gt;方法从表单发送的信息对任何人都是可见的（显示在URL中）；且对发送信息数量有限制；且便于添加到书签中下次访问&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;POST&lt;/code&gt;方法从表单发送的信息对任何人都是不可见的；保存书签后下次访问表单信息会丢失。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;php-2&quot;&gt;PHP日期&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;PHP中使用&lt;code&gt;date(format, timestamp)&lt;/code&gt;返回固定格式时间；其中&lt;code&gt;format（格式）&lt;/code&gt;必需，&lt;code&gt;timestamp（时间，默认为当前时间）&lt;/code&gt;可选；&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;这里有一个很有趣的小细节就是网站的版本年份，我之前一直以为是没到过年的时候由维护人员手动更新。。。学到了这里当然知道用&lt;code&gt;start_year - &amp;lt;?php echo date('Y'); ?&amp;gt;&lt;/code&gt;实现&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;另外说一下几个常用的时间格式：&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;Y：表示年（四位数）&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;m：表示月（01-12）&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;d：表示月里的某天（01-31）&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;h：表示带有首位零的12小时小时格式&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;i：带有首位零的分钟（00-59）&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;s：带有首位零的秒（00-59）&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;a ：小写的午前和午后（am、pm）&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;strong&gt;注意：对于服务器在境外的情况需要设置时区&lt;/strong&gt;；例如：&lt;code&gt;date_default_timezone_set(&quot;Asia/Shanghai&quot;);&lt;/code&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;PHP中也可以通过&lt;code&gt;mktime(hour, minute, second, month, day, year)&lt;/code&gt;来创建日期时间；例如&lt;code&gt;mktime(13, 38, 20, 7, 14, 2015)&lt;/code&gt;对应的时间为2015年7月14日13:38:20;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;还可以通过&lt;code&gt;shrtotime($str)&lt;/code&gt;创建时间，这里的$str为一个由时间组成的可读的字符串；这里相比之下建议在对&lt;code&gt;shrtotime()&lt;/code&gt;不熟练时使用&lt;code&gt;mktime&lt;/code&gt;好一些，以免出现不能正确设置时间的情况。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;includerequire&quot;&gt;include与require语句&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;ul&gt;
        &lt;li&gt;通过&lt;code&gt;require&lt;/code&gt;或&lt;code&gt;include&lt;/code&gt;语句都可以将PHP文件内容插入另一个PHP文件中，但是在错误处理方面，&lt;code&gt;require&lt;/code&gt;会停止脚本，而&lt;code&gt;include&lt;/code&gt;则声称警告并继续执行脚本。&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;php-3&quot;&gt;PHP文件操作&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;使用&lt;code&gt;readfile('文件位置')&lt;/code&gt;对文件进行读取并写入输出缓冲&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;其他函数如：&lt;code&gt;fopen()&lt;/code&gt;、&lt;code&gt;fread()&lt;/code&gt;、&lt;code&gt;fwrite()&lt;/code&gt;、&lt;code&gt;fclose()&lt;/code&gt;、&lt;code&gt;fgets()&lt;/code&gt;、&lt;code&gt;feof()&lt;/code&gt;、&lt;code&gt;fgetc()&lt;/code&gt;同C语言使用方法类似&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;使用form表单实现文件上传，指定一个php程序处理上传的文件，需要说明的是要在form表单中添加&lt;code&gt;enctype = &quot;&quot;&lt;/code&gt;属性以指定上传文件类型；文件上传后访问文件可以使用&lt;code&gt;$_FILES&lt;/code&gt;访问文件属性&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;cookie--session&quot;&gt;cookie 和 session&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;cookie是服务器留在用户计算机中的小文件（&lt;strong&gt;存在于客户端&lt;/strong&gt;）;每当计算机通过浏览器请求页面时，会同时发送cookie&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;cookie只支持字符串类型，对于安全性要求较高的数据，cookie需要进行格式化和加密存储。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;使用&lt;code&gt;setcookie(name, value, [expire], [path], [domain])&lt;/code&gt;函数来设置cookie&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;使用&lt;code&gt;$_COOKIE&lt;/code&gt;取回cookie的值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;session用于存储有关用户会话的信息，或更改会话设置。session保存的信息是单一用户的且可供应用程序中所有页面使用&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;session可以用来存储多种类型的数据，因此具有很多用途，常用来存储用户登录信息、购物车数据、或者一些临时使用的暂存数据等。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;session的工作机制是：为每个访问者创建一个唯一的id,并基于这个id来存储变量。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;在把用户信息存储到PHP session中之前必须启动会话，注意：&lt;strong&gt;启动会话函数session_start()必须位于&amp;lt;html&amp;gt;标签之前&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;使用&lt;code&gt;$_SESSION&lt;/code&gt;来对session变量存储和取回&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;当希望删除某些session数据时，可以使用&lt;code&gt;unset()&lt;/code&gt;释放制定的session变量或&lt;code&gt;session_destory&lt;/code&gt;彻底终结session&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;php-&quot;&gt;PHP 发送邮件&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;mail(to, subject, message, [headers], [parameters])&lt;/code&gt;函数用来从脚本中发送电子邮件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;为了防止E-mail注入，可以对文本框中输入内容使用&lt;code&gt;filter_var($field, FILTER_VALIDATE_EMAIL)&lt;/code&gt;进行过滤&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;php-4&quot;&gt;PHP文件操作&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用&lt;code&gt;file_get_contents(path)&lt;/code&gt;读取文件所有内容；同时支持C语言文件操作方法，如&lt;code&gt;fopen&lt;/code&gt;、&lt;code&gt;fgets&lt;/code&gt;、&lt;code&gt;fread&lt;/code&gt;等。若使用&lt;code&gt;fopen&lt;/code&gt;，之后最好使用&lt;code&gt;fclose&lt;/code&gt;关闭文件指针。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;PHP中判断文件是否存在使用&lt;code&gt;file_exists&lt;/code&gt;；使用&lt;code&gt;is_file&lt;/code&gt;判断是否是一个文件；使用&lt;code&gt;is_readable&lt;/code&gt;、&lt;code&gt;is_writeable&lt;/code&gt;判断文件在是否存在基础上，判断是否可读可写。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用&lt;code&gt;file_put_contents(filename, content)&lt;/code&gt;对文件进行写操作；同样也支持C语言文件操作方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;文件有很多多元属性，包括&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;fileowner&lt;/code&gt;获得文件所有者&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;filectime&lt;/code&gt;获得文件创建时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;filemtime&lt;/code&gt;获得文件修改时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;fileatime&lt;/code&gt;获得文件访问时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;其中文件修改时间常用来判断文件时效性，经常用在静态文件或者缓存数据的更新。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用&lt;code&gt;filesize&lt;/code&gt;获取文件大小（以&lt;code&gt;字节&lt;/code&gt;为单位）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;PHP使用&lt;code&gt;unlink&lt;/code&gt;函数进行文件删除；删除文件夹使用&lt;code&gt;rmdir&lt;/code&gt;函数（文件夹为空时）；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果文件夹中存在文件，可以递归删除，循环删除可使用&lt;code&gt;glob函数&lt;/code&gt;遍历所有文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;code&gt;foreach (glob(&quot;*&quot;) as $filename) {	unlink($filename);	}&lt;/code&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;日期和时间&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;PHP中使用&lt;code&gt;time()&lt;/code&gt;获取当前时间（时间为1970年1月1日00:00:00到当前时间秒数之和）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;date(time_stamp, [time])&lt;/code&gt;获取规定格式的时间，默认为当前时间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用&lt;code&gt;strtotime(time_stamp)&lt;/code&gt;函数获取&lt;code&gt;time_stamp&lt;/code&gt;对应的秒数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;phpgdgraphic-device&quot;&gt;PHP中的&lt;code&gt;GD(Graphic Device)&lt;/code&gt;库&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;GD库常用在图片加水印、验证码生成等方面。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在绘制之前要先使用&lt;code&gt;imagecreatetruecolor(width, height)&lt;/code&gt;新建一个画布。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用&lt;code&gt;image+(type of image)&lt;/code&gt;函数输出图像到浏览器或保存到文件。如&lt;code&gt;imagepng&lt;/code&gt;、&lt;code&gt;imagejpeg&lt;/code&gt;、&lt;code&gt;imagegif&lt;/code&gt;等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;数字验证码的原理就是使用&lt;code&gt;imagestring()&lt;/code&gt;函数输出随机验证码，并用&lt;code&gt;imagesetpixel()函数&lt;/code&gt;做一定的噪点干扰处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;php-5&quot;&gt;PHP数据库操作&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般使用官方的&lt;code&gt;mysql_connect('mysql_host', 'mysql_user', 'mysql_password')&lt;/code&gt;或增强版的&lt;code&gt;mysqli_connect('mysql_host', 'mysql_user', 'mysql_password')&lt;/code&gt;进行数据库的连接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用&lt;code&gt;mysql_query(string)&lt;/code&gt;进行数据库查询、插入、更新、删除操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在mysql中，插入语句后，可以通过&lt;code&gt;mysql_insert_id()&lt;/code&gt;函数获取自增主键&lt;code&gt;id&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;常用&lt;code&gt;mysql_fetch_array(result, [MYSQL_NUM])&lt;/code&gt;获取一行结果，等同于&lt;code&gt;mysql_fetch_row(result)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;mysql_affected_rows()&lt;/code&gt;返回改变行数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;尽管PHP会在执行完毕后自动关闭数据库连接，但直接关闭&lt;code&gt;mysql_close()&lt;/code&gt;可以节省资源，提高性能&lt;/p&gt;
&lt;/blockquote&gt;
</description>
          <pubDate>2015-07-12T00:00:00+08:00</pubDate>
          <link>/coding/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</link>
          <guid isPermaLink="true">/coding/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</guid>
        </item>
      
    
      
        <item>
          <title>php + mysql 实现分页</title>
          <description>&lt;h5 id=&quot;java-eephpmysql&quot;&gt;早在做java EE项目的时候就意识到分页并不容易做，甚至项目有了分页功能就有了一个很大的卖点，通过今天下午的学习，理解并掌握了运用php+mysql实现分页的方法&lt;/h5&gt;

&lt;p&gt;先附上分页效果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post7-分页.png&quot; alt=&quot;分页效果&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先要明确的一点是分页功能的实现主要借助于mysql的select limit语句；&lt;/p&gt;

&lt;p&gt;这里的limit的功能就在于限定显示的记录数&lt;/p&gt;

&lt;p&gt;如果limit后跟一个数x即限定显示的记录数，若跟两个数x,y 则x表示开始的记录数,y表示记录的个数&lt;/p&gt;

&lt;p&gt;因此我们可以限定每页显示的记录数，然后设定一个参数p代表页数&lt;/p&gt;

&lt;p&gt;我们用p来传递当前页面数值，从而实现分页功能&lt;/p&gt;

&lt;p&gt;接下来就很简单了，制作按钮，当然这里有些细节要注意，例如&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、跳转到首页后，不能再选择跳转到上一页&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、页面过多时显示的页码数要随之而改变&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面直接附上代码及注释希望对有需要的朋友有所帮助&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;Content-type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
    &amp;lt;style&amp;gt;
        body {
            font-size: 16px; font-family:verdana; width:100%;
        }
        div.page {
            text-align:center;
        }
        div.content {
            height: 300px;
        }
        div.page a{
            border:#aaaadd 1px solid; text-decoration:none; padding: 2px 5px 2px 5px; margin:2px;
        }
        div.page span.current {
            border:#0000099 1px solid; background-color:#000099; padding:4px 6px 4px 6px; margin:2px; color:#fff; font-weight:bold;
        }
        div.page span.disable {
            border:#eee 1px solid; padding:2px 5px 2px 5px; margin:2px; color:#ddd;
        }
        div.page form {
            display:inline;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;php&quot;&gt;&amp;lt;body&amp;gt;
&amp;lt;?php
    //echo &amp;quot;&amp;lt;pre&amp;gt;&amp;quot;;
    //print_r($_SERVER);

    $page = $_GET['p']; //page代表当前页面数
    $host = &amp;quot;localhost&amp;quot;;
    $username = &amp;quot;root&amp;quot;;
    $password = &amp;quot;root&amp;quot;;
    $db = &amp;quot;test&amp;quot;;
    $pageSize = 10; //每页显示的记录数
    $showPage = 5; //要显示的页码数
    
    echo &amp;quot;&amp;lt;h1 align='center'&amp;gt;分页显示结果&amp;lt;/h1&amp;gt;&amp;lt;br/&amp;gt;&amp;quot;;

    //建立mysql连接
    $conn = mysql_connect($host, $username, $password);
    if(!$conn) {
        echo &amp;quot;failed connect&amp;quot;;
        exit;
    }

    //选择数据库以及设置编码
    mysql_select_db($db);
    mysql_query(&amp;quot;SET NAME UTF8&amp;quot;);

    //向数据库中添加数据
    /*
    for($i=2; $i&amp;lt;1000; ++$i) {
        $name = &amp;quot;'name&amp;quot;.$i.&amp;quot;'&amp;quot;;
        $sql = &amp;quot;insert into page values (&amp;quot; .$i.&amp;quot;, &amp;quot;.$name.&amp;quot;)&amp;quot;;
        $result = mysql_query($sql);
    }
     */

    //限定从10的整数倍记录开始（如第0、10、20...条），并每页显示10条记录
    $sql = &amp;quot;select * from page limit &amp;quot;.($pageSize*($page-1)).&amp;quot;, &amp;quot;.$pageSize;
    $result = mysql_query($sql);

    //输出从数据库读取的结果
    echo &amp;quot;&amp;lt;div class='content'&amp;gt;&amp;quot;;
    echo '&amp;lt;table align=&amp;quot;center&amp;quot; border=1 cellspacing=0 width=40%&amp;gt;';
    echo &amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td align='center'&amp;gt;ID&amp;lt;/td&amp;gt;&amp;lt;td align='center'&amp;gt;NAME&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;;
    while($row = mysql_fetch_assoc($result)) {
        echo '&amp;lt;tr&amp;gt;';
        echo &amp;quot;&amp;lt;td align='center'&amp;gt;{$row['id']}&amp;lt;/td&amp;gt;&amp;quot;;
        echo &amp;quot;&amp;lt;td align='center'&amp;gt;{$row['name']}&amp;lt;/td&amp;gt;&amp;quot;;
        echo &amp;quot;&amp;lt;/tr&amp;gt;&amp;quot;;
    }
    echo '&amp;lt;/table&amp;gt;';
    echo '&amp;lt;/div&amp;gt;'; 
    
    //num_sql : 总记录
    //num_result : 总记录
    //num : 按每页pageSize条记录显示可分num页
    $num_sql = 'select count(*) from page';
    $num_result = mysql_fetch_array(mysql_query($num_sql));
    $num = $num_result[0];
    $num = ceil($num/$pageSize); //页数需要向上取整，保证最后一页可以显示少于10条的记录

    //释放并关闭连接
    mysql_free_result($result);
    mysql_close($conn);

    $page_banner = &amp;quot;&amp;lt;div class='page'&amp;gt;&amp;quot;;

    //计算左右两侧偏移量
    $pageOffset = ($showPage - 1) / 2; 

    //当前停留在第一页时隐藏首页以及上一页按钮
    if($page &amp;gt; 1) {
        $page_banner .= &amp;quot;&amp;lt;a href='&amp;quot;.$_SERVER['PHP_SELF'].&amp;quot;?p=1'&amp;gt;首页&amp;lt;/a&amp;gt;&amp;quot;;
        $page_banner .= &amp;quot;&amp;lt;a href='&amp;quot;.$_SERVER['PHP_SELF'].&amp;quot;?p=&amp;quot;.($page-1).&amp;quot;'&amp;gt;&amp;lt;上一页&amp;lt;/a&amp;gt;&amp;quot;;
    } else {
        $page_banner .= &amp;quot;&amp;lt;span class='disable'&amp;gt;首页&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;&amp;quot;;
        $page_banner .= &amp;quot;&amp;lt;span class='disable'&amp;gt;上一页&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;&amp;quot;;
    }

    //设置页面显示的左侧以及右侧
    $start = 1;
    $end = $num;
    if($num &amp;gt; $showPage) {
        if($page &amp;gt; $pageOffset+1) { //从pageOffset+2开始左侧要显示...
            $page_banner .= '...';
        }
        if($page &amp;gt; $pageOffset) {//设定要显示的页码范围
            $start = $page-$pageOffset;
            $end = $num &amp;gt; $page+$pageOffset ? $page+$pageOffset : $num;
        } else {
            $start = 1;
            $end = $num &amp;gt; $showPage ? $showPage : $num;
        }
        //确保显示合理页数
        if($page + $pageOffset &amp;gt; $num) {
            $start = $start - ($page + $pageOffset - $end);
        }
    }


    //对当前页面页码做高亮处理
    for($i=$start; $i&amp;lt;=$end; ++$i) {
        if($page == $i) {
            $page_banner .= &amp;quot;&amp;lt;span class='current' &amp;gt;{$i}&amp;lt;/span&amp;gt;&amp;quot;;
        } else {
            //为各个页码设置对应的超链接
            $page_banner .= &amp;quot;&amp;lt;a href='&amp;quot;.$_SERVER['PHP_SELF'].&amp;quot;?p=&amp;quot;.($i).&amp;quot;'&amp;gt;&amp;quot;.$i.&amp;quot;&amp;lt;/a&amp;gt;&amp;quot;;
        }
    }

    if($num &amp;gt; $showPage &amp;amp;&amp;amp; $num &amp;gt; $page+$pageOffset) {
        $page_banner .= &amp;quot;...&amp;quot;;
    }

    if($page &amp;lt; $num) {
        $page_banner .= &amp;quot;&amp;lt;a href='&amp;quot;.$_SERVER['PHP_SELF'].&amp;quot;?p=&amp;quot;.($page+1).&amp;quot;'&amp;gt;下一页&amp;gt;&amp;lt;/a&amp;gt;&amp;quot;;
        $page_banner .= &amp;quot;&amp;lt;a href='&amp;quot;.$_SERVER['PHP_SELF'].&amp;quot;?p=&amp;quot;.($num).&amp;quot;'&amp;gt;尾页&amp;lt;/a&amp;gt;&amp;quot;;
    } else {
        $page_banner .= &amp;quot;&amp;lt;span class='disable'&amp;gt;下一页&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;&amp;quot;;
        $page_banner .= &amp;quot;&amp;lt;span class='disable'&amp;gt;尾页&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;&amp;quot;;
    }

    echo $page_banner;
    echo &amp;quot;共{$num}页&amp;quot;;

    //设置页面跳转,把输入的变量值传递给p即可
    $page_banner = &amp;quot;&amp;lt;form action='mypage.php' method='get'&amp;gt;&amp;quot;;
    $page_banner .= &amp;quot;到第&amp;lt;input type='text' size='2' name='p'&amp;gt;&amp;quot;;
    $page_banner .= &amp;quot;&amp;lt;input type='submit' value='确定'&amp;gt;&amp;quot;;
    $page_banner .= &amp;quot;&amp;lt;/form&amp;gt;&amp;lt;/div&amp;gt;&amp;quot;;
    echo $page_banner;

?&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
          <pubDate>2015-07-11T00:00:00+08:00</pubDate>
          <link>/coding/php--mysql-%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD.html</link>
          <guid isPermaLink="true">/coding/php--mysql-%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD.html</guid>
        </item>
      
    
      
        <item>
          <title>解决ubuntu不能访问windows磁盘问题</title>
          <description>&lt;p&gt;在ubuntu、windows双系统下，不能从ubuntu访问windows系统下的磁盘，导致这个问题的原因一般都是上次系统没有正常关闭导致&lt;/p&gt;

&lt;p&gt;要想修复这个问题其实很简单，这里提供两种解决方法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、以正常方式重启。。。当然我并不推荐这种方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、使用&lt;code&gt;ntfsfix&lt;/code&gt;命令修复windows系统下磁盘，使用方法为&lt;code&gt;sudo ntfsfix &lt;/code&gt; + 对应磁盘号即可；要想知道对应的磁盘号使用&lt;code&gt;fdisk -l&lt;/code&gt;命令；例如修复命令为： &lt;code&gt;sudo ntfsfix /dev/sda3&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;修复完成即可正常访问磁盘^_^&lt;/p&gt;
</description>
          <pubDate>2015-06-03T00:00:00+08:00</pubDate>
          <link>/myshare/%E8%A7%A3%E5%86%B3ubuntu%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AEwindows%E7%A3%81%E7%9B%98%E9%97%AE%E9%A2%98.html</link>
          <guid isPermaLink="true">/myshare/%E8%A7%A3%E5%86%B3ubuntu%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AEwindows%E7%A3%81%E7%9B%98%E9%97%AE%E9%A2%98.html</guid>
        </item>
      
    
      
        <item>
          <title>深夜杂思</title>
          <description>&lt;p&gt;夜晚睡不着，索性起来发篇博客，把心里的想说的话说个干净
最近一直在为保研的事忧心，特别是前天晚上又听了软件三班的学长学姐交流会，感觉像盈神这样的大牛都在保研这条路上差点出意外，我又怎么保证我能顺利保研呢？&lt;/p&gt;

&lt;p&gt;目前就报了中科院计算所和软件所，接下来想报北航、北邮，但是这两所学校都没出夏令营，不知道今年会不会就不出了，因为目标是北京，所以也不考虑其他地方了，这么一算北京也就那几所学校了，其实还有中国人大，但是要求的资料太繁琐了，再加上它本身也不是计算机类院校，因此我也就不是很上心。&lt;/p&gt;

&lt;p&gt;今天班级聚餐，应该是这学期唯一一次聚餐，再过一个月三班的同学们就要出去实习了，下次大家再聚在一起应该就是明年这个时候了。&lt;/p&gt;

&lt;p&gt;虽然要离别了，但并没有特殊的感觉，可能生性如此，对待这些事我总是显得过于理性。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;今天聚餐班里成就了两对情侣（GT-WY、HXY-CH）,期间还以为GT是喝醉了呢。。。他的室友和我还担心周一上课了大家见面尴尬，没想到他是图谋已久⊙﹏⊙b&lt;/p&gt;

&lt;p&gt;今天大家喝酒喝的很嗨，甚至326、327寝室拼酒，说到酒，我实在是提不起兴趣&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;#&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;是因为不能喝，又有胃病&lt;/li&gt;
  &lt;li&gt;我觉得以喝酒来交友或者凸显自己很牛是件很没意义的事&lt;/li&gt;
  &lt;li&gt;相对于永久来麻痹自己，我更愿意保持清醒，即使很痛苦，因为不想失去对身体的控制&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;嗯，想说的就这么多吧，转眼五月又结束了，接下来的一个月要认真起来，准备复习了！&lt;/p&gt;
</description>
          <pubDate>2015-05-31T00:00:00+08:00</pubDate>
          <link>/diary/%E6%B7%B1%E5%A4%9C%E6%9D%82%E6%80%9D.html</link>
          <guid isPermaLink="true">/diary/%E6%B7%B1%E5%A4%9C%E6%9D%82%E6%80%9D.html</guid>
        </item>
      
    
      
        <item>
          <title>制作专属关注微博按钮</title>
          <description>&lt;p&gt;今天学会了一个小技能，制作自己的微博关注按钮，效果如下：&lt;/p&gt;

&lt;p&gt;![关注我的微博] (http://7xlnl2.com1.z0.glb.clouddn.com/post6-weibo.jpg)&lt;/p&gt;

&lt;p&gt;其实很简单，只用把下面这段代码放到你想放的位置即可&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;iframe allowtransparency=&amp;quot;&amp;quot; border=&amp;quot;0&amp;quot; frameborder=&amp;quot;0&amp;quot; height=&amp;quot;22&amp;quot; marginheight=&amp;quot;0&amp;quot; marginwidth=&amp;quot;0&amp;quot; scrolling=&amp;quot;no&amp;quot; 
src=&amp;quot;http://widget.weibo.com/relationship/followbutton.php?width=200&amp;amp;height=22&amp;amp;uid=3090938041&amp;amp;style=5&amp;amp;btn=red&amp;amp;dpc=1&amp;quot; 
style=&amp;quot;width: 64px; height: 22px;&amp;quot; width=&amp;quot;200&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把这里的 src = “” 与剧中的uid对应值该为自己的即可&lt;/p&gt;

&lt;p&gt;要想知道自己微博对应的uid，用浏览器打开自己的微博主页在地址栏就可以看到了&lt;/p&gt;

&lt;p&gt;例如我打开自己的微博主页 [ http://weibo.com/3090938041 ] (http://weibo.com/3090938041)  weibo.com后面的数字即为对应的uid&lt;/p&gt;
</description>
          <pubDate>2015-05-24T00:00:00+08:00</pubDate>
          <link>/coding/%E5%88%B6%E4%BD%9C%E4%B8%93%E5%B1%9E%E5%85%B3%E6%B3%A8%E5%BE%AE%E5%8D%9A%E6%8C%89%E9%92%AE.html</link>
          <guid isPermaLink="true">/coding/%E5%88%B6%E4%BD%9C%E4%B8%93%E5%B1%9E%E5%85%B3%E6%B3%A8%E5%BE%AE%E5%8D%9A%E6%8C%89%E9%92%AE.html</guid>
        </item>
      
    
      
        <item>
          <title>sublime配置浏览器打开页面</title>
          <description>&lt;p&gt;其实以前对sublime也有所耳闻，但一说总是前端开发利器，因此一直没有接触。&lt;/p&gt;

&lt;p&gt;这几天在学习bootstrap框架，因此装了sublime 3试用了下，确实用起来体验很好，而且各种快捷键、插件用起来都很便捷舒服。&lt;/p&gt;

&lt;p&gt;由于学习bootstrap的过程中难免要编写网页，这个时候一个可以打开对应浏览器调试页面的插件则显得相当重要。&lt;/p&gt;

&lt;p&gt;了解到有一个插件view in browser，试用了下，发现只能打开默认浏览器（也可能是自己没有发现打开多个浏览器的方法），所以果断卸载不用【另外说一下安装sublime插件的方法是先安装Package Control插件，网上教程很多，还请自行google；安装完成后，使用ctrl+shift+P调出命令窗口，输入install即可看到install package选项，点击后进入安装插件模式，输入对应插件名称回车安装即可】&lt;/p&gt;

&lt;p&gt;言归正传，经过不懈的google发现了一份python代码可以实现自己的需求，代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import sublime
import sublime_plugin
import subprocess
import tempfile
 
class OpenInBrowserAltCommand(sublime_plugin.ApplicationCommand):
	def run(self, **kwargs):
		browser = kwargs['browser']
 
		browser_cmd_map = {
			'chrome': [r'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe'],
			'iexplore': [r'C:\Program Files (x86)\Internet Explorer\iexplore.exe'] 
		}
		
		if browser in browser_cmd_map:
			cmd = browser_cmd_map[browser]
			view = sublime.Window.active_view(sublime.active_window())
			if view.file_name():
				cmd.append(view.file_name())
				subprocess.Popen(cmd)
			else:
				temp = tempfile.NamedTemporaryFile(delete=False)
				content = view.substr(sublime.Region(0, view.size()))
				temp.write(content.encode('utf-8'))
				temp.flush()
				cmd.append(temp.name)
				subprocess.Popen(cmd)
				temp.close()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以发现在这里我设置了chrome和ie两款浏览器，如果想设置更多浏览器，设置对应名称路径即可（注意格式！名字可以随便起）&lt;/p&gt;

&lt;p&gt;将上述代码保存为open_browser.py（名字不重要）；这时点击sublime的 Preferences -&amp;gt; browser packages 发现插件安装路径，将上述python文件保存到当前的user目录下&lt;/p&gt;

&lt;p&gt;接着我们设置一下对应的调用快捷键即可，打开 Preferences -&amp;gt; key binding - user
编辑内容为：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;python&quot;&gt;[
	{ &amp;quot;keys&amp;quot;: [&amp;quot;f4&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;open_in_browser_alt&amp;quot;, &amp;quot;args&amp;quot;: {&amp;quot;browser&amp;quot;: &amp;quot;chrome&amp;quot;} },
	{ &amp;quot;keys&amp;quot;: [&amp;quot;f3&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;open_in_browser_alt&amp;quot;, &amp;quot;args&amp;quot;: {&amp;quot;browser&amp;quot;: &amp;quot;iexplore&amp;quot;} }
]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然这里的浏览器名字要与你在上述文件中起的名字一致，在这里我设置的快捷键为 F3 F4，当然你可以根据自己的习惯设置，当添加更多浏览器按照上述格式添加即可&lt;/p&gt;

&lt;p&gt;一切就绪，现在打开一个html文件，按下快捷键发现完美调用浏览器！&lt;/p&gt;
</description>
          <pubDate>2015-05-24T00:00:00+08:00</pubDate>
          <link>/myshare/sublime%E9%85%8D%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2.html</link>
          <guid isPermaLink="true">/myshare/sublime%E9%85%8D%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2.html</guid>
        </item>
      
    
      
        <item>
          <title>简单的等式（数学题）</title>
          <description>&lt;p&gt;题意是有一个等式：x^2+s(x, m)*x-n = 0&lt;/p&gt;

&lt;p&gt;s(x, m)表示把x写成m进制时，每个位数相加的和&lt;/p&gt;

&lt;p&gt;找到满足条件的最小正整数x，如果不存在，输出-1&lt;/p&gt;

&lt;p&gt;很容易想到把等式转换为x+s(x, m) = n/x&lt;/p&gt;

&lt;p&gt;所以可以知道n是x的整数倍，且n&amp;gt;x*x&lt;/p&gt;

&lt;p&gt;但仅仅是这样时间复杂度是降不下来的&lt;/p&gt;

&lt;p&gt;做比赛的时候一直没有想出来，快结束的时候小伙伴王烯想出了一个办法：枚举s(x, m)的值，可以发现这个值的范围是很小的&lt;/p&gt;

&lt;p&gt;我们令k = s(x, m), 则可以将上式转为一个二元一次方程:x^2+kx-n = 0&lt;/p&gt;

&lt;p&gt;枚举k后，解出x，判断是否满足原方程即可&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;#include &amp;lt;cstdio&amp;gt;

#include &amp;lt;cmath&amp;gt;

#include &amp;lt;vector&amp;gt;

#include &amp;lt;iostream&amp;gt;

#include &amp;lt;algorithm&amp;gt;

#define LL long long

using namespace std;

LL n, m;

LL ss(LL x, LL m) {
	LL ans = 0;
	while(x) {
		ans += x%m;
		x /= m;
	}
	return ans;
}

int main(void) {
	int T;
	scanf(&amp;quot;%d&amp;quot;, &amp;amp;T);
	while(T--) {
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;

		bool ok = true;
		for(LL s=1; s&amp;lt;=2000; ++s) {
			LL x = (-s+sqrt(s*s+4*n))/2;

			if(x*x + ss(x, m)*x == n) {
				cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl;
				ok = false;
				break;
			} 
		}
		if(ok) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
	}
	return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
          <pubDate>2015-04-29T00:00:00+08:00</pubDate>
          <link>/coding/%E7%AE%80%E5%8D%95%E7%9A%84%E7%AD%89%E5%BC%8F.html</link>
          <guid isPermaLink="true">/coding/%E7%AE%80%E5%8D%95%E7%9A%84%E7%AD%89%E5%BC%8F.html</guid>
        </item>
      
    
      
        <item>
          <title>Ilya and Escalator</title>
          <description>&lt;p&gt;题意是电梯前有n个人，每个人进电梯的概率位p，问在p秒时电梯内人数的期望&lt;/p&gt;

&lt;p&gt;题目有一个地方要注意的是电梯外的人是在排队的，当最前面的人这个时刻不进电梯时后面的人等在排队等着。&lt;/p&gt;

&lt;p&gt;可以定义DP状态：dp[i][j] //表示前i秒进j个人的概率&lt;/p&gt;

&lt;p&gt;初始状态很容易定义：dp[i][0] = dp[i-1][0]*(1-p);&lt;/p&gt;

&lt;p&gt;可以知道dp[i][j] = dp[i-1][j-1]&lt;em&gt;p + dp[i-1][j]&lt;/em&gt;(1-p)&lt;/p&gt;

&lt;p&gt;而这个状态对于j==n并不适应，当j==n时，已经没有人在排队，状态转移方程变为：&lt;/p&gt;

&lt;p&gt;dp[i][n] = dp[i-1][j-1]*p + dp[i-1][n];&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#include &amp;lt;cstdio&amp;gt;

#include &amp;lt;cstring&amp;gt;

#include &amp;lt;iostream&amp;gt;

#define MAXN 2100

using namespace std;

double dp[MAXN][MAXN];

int main(void) {
    int t, n;
    double p;
    double ans;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; p &amp;gt;&amp;gt; t;
    dp[0][0] = 1;
    for(int i=1; i&amp;lt;=t; ++i) {
        dp[i][0] = (1-p)*dp[i-1][0];
        for(int j=1; j&amp;lt;n; ++j) {
            dp[i][j] = dp[i-1][j-1]*p + dp[i-1][j]*(1-p);
        }
        dp[i][n] = p*dp[i-1][n-1]+dp[i-1][n];
    }
    ans = 0.0;
    for(int i=1; i&amp;lt;=n; ++i) {
        ans += dp[t][i]*i;
    }
    printf(&amp;quot;%.6lf\n&amp;quot;, ans);

    return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
          <pubDate>2015-04-28T00:00:00+08:00</pubDate>
          <link>/coding/IIya-and-Escalator-%E6%A6%82%E7%8E%87DP.html</link>
          <guid isPermaLink="true">/coding/IIya-and-Escalator-%E6%A6%82%E7%8E%87DP.html</guid>
        </item>
      
    
      
        <item>
          <title>又是一个失眠的夜晚</title>
          <description>&lt;p&gt;可能是昨晚熬夜的缘故吧，今晚又失眠了。&lt;/p&gt;

&lt;p&gt;说起我的失眠还真是很奇怪，开始于大二下的时候，那个时候总觉得寝室不够安静，刚好了解到ACM实验室可以住人且环境比较好，所以经过深思熟虑后决定搬过去住。&lt;/p&gt;

&lt;p&gt;实验室不是安静，而是异常地安静！奇怪就奇怪在搬过去之后反而失眠更严重了。。。尤其是上学期，好多次都是坐在电脑旁做到天亮&lt;/p&gt;

&lt;p&gt;其实我习惯于在不好的事情中看到其有价值的地方，因此在我看来，失眠也并不是一无是处&lt;/p&gt;

&lt;p&gt;失眠的人都知道：很多事情只有在夜晚才能够静下心来思考，才能够反思自己的问题&lt;/p&gt;

&lt;p&gt;失眠的时候把这一天所遇到的人和事在脑海里过一遍，总是会很有收获。&lt;/p&gt;

&lt;p&gt;从上学期寒假开始就很少失眠了，因为每天比较累，可能经过这段时间的休整，整个人又缓过来了，所以又开始失眠了&lt;/p&gt;

&lt;p&gt;不过这以后的失眠我不会再想以前那样浪费时间，而是学着高效地利用这段时间学习一些新知识&lt;/p&gt;

&lt;p&gt;其实话说回来，这几天并不轻松，总有一种与时间赛跑的感觉&lt;/p&gt;

&lt;p&gt;原因在于：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;课程多，任务重，时间少；这就不得不吐槽一下我们的课程安排了，大一、大二课程轻松，时间少；等到大三下学期了，大家都在为自己的选择而奔波忙碌的时候，反倒是各种专业课，又赶上这学期只有18周（含两周实习、两周考试周）。。。&lt;/li&gt;
    &lt;li&gt;这学期由我和郭伟强来负责ACM实验室的管理，又赶上老师发放新设备，赞助商赞助等各种事情，刚忙完ACM新生杯，又迎来了河南省省赛。。。&lt;/li&gt;
    &lt;li&gt;要为保研做准备，准备材料、关注学校、联系导师等等&lt;/li&gt;
    &lt;li&gt;最坑的是赶上专业认证。。。所以各种实验报告一个不能少（我还被学长蛊惑选了所有选修课，一周21节课你敢信O_o）&lt;/li&gt;
    &lt;li&gt;以前只有中澳才有的工程设计今年也为我们设置了。。。&lt;/li&gt;
    &lt;li&gt;要把BNU OJ的源码移到我们的平台上，这几天还想再改改博客的页面。&lt;/li&gt;
    &lt;li&gt;还要考驾照（科目二已跪一次T_T）&lt;/li&gt;
    &lt;li&gt;…&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;列出来的这一部分就可以知道我根本闲不下来啊。。。失眠也可能是因为这几天压力比较大吧&lt;/p&gt;

&lt;p&gt;话不多说了，趁着夜深人静的时候发发牢骚，该干什么还干什么去吧。。。&lt;/p&gt;

&lt;p&gt;最后卖个萌，测一下Markdown 图片显示效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xlnl2.com1.z0.glb.clouddn.com/post2-卖萌.jpg&quot; alt=&quot;卖个萌&quot; /&gt;&lt;/p&gt;
</description>
          <pubDate>2015-04-27T00:00:00+08:00</pubDate>
          <link>/diary/%E5%8F%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A4%B1%E7%9C%A0%E7%9A%84%E5%A4%9C%E6%99%9A.html</link>
          <guid isPermaLink="true">/diary/%E5%8F%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A4%B1%E7%9C%A0%E7%9A%84%E5%A4%9C%E6%99%9A.html</guid>
        </item>
      
    
      
        <item>
          <title>yinwoods个人博客搭建成功</title>
          <description>&lt;p&gt;这两天在和小强忙着使用BNU OJ在GitHub上的源代码构建我们的ZZU OJ有兴趣的朋友请移步&lt;a href=&quot;https://github.com/ZZUACM/ZZUOJ-BASEON-BNUOJ&quot;&gt;ZZUOJ-BASEON-BNUOJ From GitHub&lt;/a&gt;,今晚算是差不多完成了，所以破格熬个夜吧:)&lt;/p&gt;

&lt;p&gt;其实博客都搭建好多天了，一直没有时间写教程，不过搭建过程确实很简单，所以我写这篇文章也是出于学习jekyll编写博客的目的吧。&lt;/p&gt;

&lt;p&gt;客观的说CSDN的博客现在是越做越好了，可是感觉自己的博客放在别人的站点上总是怪怪的。。。&lt;/p&gt;

&lt;p&gt;在搭建这个博客的过程中，用了整整一天的时间，主要是因为安装jekyll时老是出错。&lt;/p&gt;

&lt;p&gt;下面是详细步骤：&lt;/p&gt;

&lt;p&gt;搭建博客前，可以视个人需求考虑要不要购买域名，本人是在&lt;a href=&quot;http://www.godaddy.com/&quot;&gt;GOdday&lt;/a&gt;上购买的域名（yinwoods.com）
160￥使用两年&lt;/p&gt;

&lt;p&gt;后来听朋友说在&lt;a href=&quot;http://www.net.cn/?spm=5334.642894.2.3.8W3O0N&quot;&gt;万网&lt;/a&gt;上买第一年29￥，第二年49￥，而且还可以使用阿里云两年的免费虚拟主机。&lt;/p&gt;

&lt;p&gt;有兴趣的同学可以考虑下。&lt;/p&gt;

&lt;p&gt;解析域名我是在&lt;a href=&quot;https://www.dnspod.cn/&quot;&gt;DNSPod&lt;/a&gt;上做的，免费的，只需要注册一个账号而已。&lt;/p&gt;

&lt;p&gt;接下来就是利用GitHub Pages配置个人博客页面了，这个很简单&lt;/p&gt;

&lt;p&gt;可以参考以下几篇文章：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://beiyuu.com/github-pages/&quot;&gt;使用Github Pages建独立博客&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/&quot;&gt;Setting up a custom domain with GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的文章已经足够详细了，相信大家在这些步骤上不会遇到问题。&lt;/p&gt;

&lt;p&gt;我之所以花费一天的时间搭建博客，很大一部分功夫都是花费在安装jekyll&lt;/p&gt;

&lt;p&gt;安装过程中千万记住不要使用&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;sudo apt-get install jekyll&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;语句安装，用这种方法安装会导致各种问题。。。&lt;/p&gt;

&lt;p&gt;在安装jekyll之前要先装Ruby，如果你在安装Ruby过程中遇到问题，可以参考下面这篇文章：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://ruby.taobao.org/&quot;&gt;RubyGems 镜像 - 淘宝网&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你使用Ubuntu安装jekyll，那么你有福了：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://sharadchhetri.com/2014/06/30/install-jekyll-on-ubuntu-14-04-lts/&quot;&gt;Install Jekyll on Ubuntu 14.04 LTS&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://askubuntu.com/questions/305884/how-to-install-jekyll&quot;&gt;How to install jekyll?&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装jekyll中遇到问题的话，请参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jekyll/jekyll-help/issues/209&quot;&gt;Installing Jekyll: ERROR: Failed to build gem native extension.&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/10725767/error-installing-jekyll-native-extension-build&quot;&gt;Error Installing Jekyll - Native Extension Build&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装jekyll成功后，jekyll的使用方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://jekyllbootstrap.com/usage/jekyll-quick-start.html&quot;&gt;Jekyll QuickStart&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://jekyllcn.com/&quot;&gt;jekyll 简单的静态博客&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为博客添加评论功能：
参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.masr.in/geek/add_comment_to_jekyll.html&quot;&gt;jekyll+github构建简约博客&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.disqus.com/customer/portal/articles/472138-jekyll-installation-instructions&quot;&gt;Jekyll Installation Instructions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然对于初学者，你完全可以去 &lt;a href=&quot;https://github.com&quot;&gt;GitHub&lt;/a&gt; 上 fork 别人的代码，删除_post下所有文章后当做自己的主题使用。&lt;/p&gt;
</description>
          <pubDate>2015-04-26T00:00:00+08:00</pubDate>
          <link>/coding/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F.html</link>
          <guid isPermaLink="true">/coding/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F.html</guid>
        </item>
      
    
  </channel>
</rss>