---
layout: post
title: 正则表达式学习
categories: ['coding']
tags: ['yinwoods', 'blog']
published: True
img: 11

---

学习php的过程中接触了正则表达式，想到自己封存了一个月之久的正则表达式教程也该重见天日了！

教程地址：[正则表达式30分钟入门教程](http://deerchao.net/tutorials/regex/regex.htm)

**版权声明：本文是在学习上述教程过程中编写；如有雷同，纯属学习！**

>###元字符
> * 1、\b是正则表达式规定的一个元字符，代表着单词的开头或结尾;所以我们可以通过`\bhello\b`来匹配一个hello**单词**

> * 2、`.`同样是一个元字符，匹配除换行符之外的任意字符

> * 3、`*`是一个元字符，它代表数量，表明*前字符可以出现任意次数
>> 综上  `\bhi\b.*\bLucy\b ` 就是匹配先出现**单词** hi hi之后跟任意数量个非换行符外的其他字符，再接着是**单词** Lucy 的情况

> * 4、`\d`是一个元字符，匹配任意一个数字；`\d{5}` 这种形式则表示匹配5个数字

> * 5、`\s`是一个元字符，匹配任意空白字符，包括空格、制表符、换行符等

> * 6、`\w`匹配**字母、数字、下划线或汉字等**
>> 举几个栗子便于理解：
	> 1、`\ba\w*\b`匹配以a开头的**单词**（这里的单词可以含下划线或汉字，取决于\w的定义）
	> 2、`\d+`匹配1个或多个连续的数字； **+与\*的不同之处在于：*可以匹配0次或多次，而+匹配1次或多次**

> * 7、 `^`匹配字符串的开始；`$`匹配字符串的结束； `^\d{5,12}$`就可以用来匹配5-12位的数字

>###字符转义
> * 8、字符转义：如果想在字符串中匹配'.'或'*'时需要对字符进行转义，可以用'\'加元字符来进行转义；举个栗子：windows系统中`C:\\Windows`即为`C:\Windows`。

>###重复限定符
> * 9、限定符，对于`'*'、'+'、'?'、{n}`均为限定符；下面给出限定符以及对应的含义
>>  	`*：`		重复零次或更多次 

>>	`+：`		重复一次或更多次
	
>>	`?：`		重复零次或一次
	
>>	`{n}：`	重复n次
	
>>	`{n,}：`	重复n次或更多次
	
>>	`{n,m}：`	重复n到m次

>###字符类
> * 10、如果想匹配没有预定义元字符的字符集合，比如`元音字母（a、e、i、o、u）`时，只需在方括号中列出来就可以了，即`[aeiou]`；
>> 举个栗子：对于`\(?0\d{2}[) -]?\d{8}`，是指以`(`开头后跟零个或一个数字0，接着是两个数字，然后跟0零个或一个`)`、` `、`-`中的任一个，再跟8个数字；比如`(010)88886666`、`022-22334455`

>###分支条件
> * 11、分支条件：满足几种规则中的任意一种即为匹配；判断是否满足时按照从左到右的顺序，一旦发现满足的条件即退出判断说明判断成功。
>> 举个栗子：`\d{5}-\d{4}|\d{5}`即表示用连字符分隔的9位数字或5位数字；如果写成`\d{5}|\d{5}-\d{4}`则遇到形如`12345-6789`的数字串会匹配成前5个数字`12345`；说明分支条件顺序的重要性。

>###分组
> * 12、当我们想重复单个字符时可以在这个字符后加限定符；而当我们想重复多个字符时可以使用小括号来指定**分组**
>> 举个栗子：`(\d{1,3}\.){3}\d{1,3}`表示一个简单的IP地址（不考虑某一位大于255情况），很容易看出来`(\d{1,3}\.){3}`表示三个以1-3位数字后跟 . 组成的串，后面再跟一个1-3位数字；给出一个正确的IP地址匹配正则表达式`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`相信看官认真看时可以看懂的...

>###反义
> * 13、反义：查找除某些字符外的其他字符；只需把之前讲的几个元字符改为大写即可；比如：
>> `\W`匹配`任意不是字母、数字、下划线或汉字的字符`；
>> `\S` 匹配 `任意不是空白符的字符`
>> `\D` 匹配 `任意非数字的字符`
>> `\B` 匹配 `不是单词开始或结束的位置`
>> `[^x]`匹配 `除x以外的任意字符`
>> `[^aeiou]` 匹配 `除a e i o u以外的任意字符`

>###后向引用
> * 14、后向引用；前面讲过用小括号进行分组，其实正则表达式会默认对分组从左向右进行编号；分组0对应整个正则表达式；后向引用用于重复搜索前面某个分组匹配的文本；
>> 举个栗子：`\b(\w+)\b\s+\1\b`用于匹配重复的单词，形如`ha ha`、`he he`等；其中`\b(\w+)\b`用于匹配一个单词（并非严格意义的单词，用`word`形容更贴切）；这个单词作为一个分组会被编号为1；因此`\s+\1\b`是指多个空白符后跟上一步匹配的单词

>  	也可以自己指定分组名，使用`(?<word>\w+)`或`(?'word'\w+)`就可以把`\w+`组名指定为word了；当需要后向引用这个分组时可以使用`\k<word>`引用
> 	后向引用还有更复杂的操作，这里就不再枚举了，有兴趣的朋友可以访问教程源地址进行深入了解

>###零宽断言

> * 15、零宽断言：用于查找某些特定位置的内容；

>> - `(?=exp)`也叫**零宽度正预测先行断言**；它匹配自身出现位置后的表达式exp；比如`\b\w+(?=ing\b)`匹配以ing结尾单词的前面部分。对于`I'm singing while you're dancing`会匹配`sing`和`danc`

>> - `(?<=exp)`也叫**零宽度正回顾后发断言**；它匹配自身出现位置前的表达式exp；比如`(?<=\bre)\w+\b`匹配以re开头单词的后面部分。对于`I'm reading a novel`会匹配`ading`

>>> 举个栗子：`(?<=\s)\d+(?=\s)`匹配以空白符间隔的数字

>###零宽度负预测先行断言

> * 16、先看一个栗子：我们现在相匹配一个含有字母q，且q后面不跟u的单词；使用：`\b\w*q[^u]\w*\b`很容易理解是匹配一个q后面不是u的单词；但这里有个问题就是[^u]是指匹配不是u的任意字符（也就是说一定要匹配一个字符），那么这个正则表达式就与我们的出发点不一致了（因为p如果在单词的最后一位，可能会导致匹配两个单词；比如会匹配`Iraq fighting`）；

>>这个时候我们就需要使用**零宽度负预测先行断言(?!exp)**了，意思是`匹配后面不是exp的结果`；对于`\d{3}(?!\d)`即匹配一个三位数字，且这三位数字后不跟数字

>>同上还有一个**零宽度负回顾后发断言(?<!exp)**来`匹配前面不是exp的结果`；比如`(?<[a-z])\d{7}`匹配前面不是小写字母的七个数字

>>举一个重要的栗子：`(?<=<(\w+)>).*(?=<\/\1>)`用于匹配不含属性的简单HTML标签内的内容

>###注释

> * 17、可以通过语法`(?#comment)`来包含注释

>###贪婪与懒惰

> * 18、当正则表达式中包含能接受重复的限定符时，默认时匹配尽可能多的字符，如`a.*b`对于`aabab`会匹配`aabab`而不是`ab`或`abab`； 我们称这种匹配方式为**贪婪匹配**

> 与之对应的就是**懒惰匹配**会匹配尽可能少的字符；把贪婪匹配转为懒惰匹配的方法就是在对应限定符后加`？`

>>####懒惰限定符
>>`*?`	： `重复任意次，但尽可能少重复`

>>`+?`	： `重复1次或更多次，但尽可能少重复`

>>`??`	：`重复0次或1次，但尽可能少重复`

>>`{n,m}?`	： `重复n到m次，但尽可能少重复`

>>`{n,}?`	： `重复n次以上，但尽可能少重复`
> * 

#写在最后

> 还有一部分内容没有涉及，原因是太复杂了且不常用，现在学习了不用也会很快忘记，所以我选择在需要的时候再去学习吧！

> 正则表达式的学习到这里就告一段落了！
