---
layout: post
title: 重拾C++
categories: ['coding']
tags: ['yinwoods', 'blog']
published: True
img: 22

---

假期回到学校呆着无聊，因为想要在大四找到一份不错的实习，所以打算重读《C++ Primer》，着重啃掉以前遗留下来的难点。

毫无疑问这将花费我很多时间，希望我能够将这篇博客梳理出来。

###数组和指针

> - 在用下标访问元素时，`vector`使用`vector::size_type`作为下标的类型，而数组下标的正确类型则是`size_t`

> - C++提供一种特殊的指针类型`void*`，它可以保存任何类型对象的地址；因为`void*`没有涉及类型，故而不能够使用解引用操作符`*`来获取其对应地址的值；
可以执行的操作有：

>> 与另一个指针进行比较；向函数传递`void*	`指针或从函数返回`void*`指针以及`void*`赋值

> - 指针和引用的比较：引用（`reference`）和指针（`pointer`）都可间接访问另一个值，但二者之间有以下两个区别

>> 1、引用总是指向某一个对象，定义引用时没有初始化是错误的。

>> 2、给引用赋值修改的是该引用所关联的对象的值，而不是像指针那样使引用与另一个对象关联。

> - 可以对同一数组不同元素的指针做减法操作，其结果是**标准库类型**`ptrdiff_t`，与`size_t`一样，`ptrdiff_t`也是一种与机器相关的类型，在`cstddef`头文件中定义；`size_t`是`unsigned`类型，而`ptrdiff_t`则是`signed`类型

> - 当指针指向`const`对象，不允许用指针来改变其所指的`const`值；允许把非`const`对象的地址赋给指向`const`对象的指针，但之后不允许通过该指针修改对应`const`对象的值

> - 当指针为`const`指针时，该指针值不可修改，但其所指向对象的值不受限制；与任何`const`量一样，`const`指针必须在定义时初始化

> - 数组类型的变量有三个重要限制：

>> 1、数组长度固定不变

>> 2、编译时必须知道数组长度

>> 3、数组只在定义它的块语句内存在

> - 每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配对象，此内存空间称为程序的**自由存储区**或**堆**。C语言使用标准库函数`malloc`和`free`分配存储空间，而C++语言使用`new`和`delete`实现相同功能

> - C++为含点操作符和解引用操作符的表达式提供了一个同义词：箭头操作符（->）；例如：

>> `*(person).name` 等价于 `person->name`