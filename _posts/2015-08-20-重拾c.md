---
layout: post
title: 重拾C++
categories: ['coding']
tags: ['cpp']
published: True
img: 22

---

假期回到学校呆着无聊，因为想要在大四找到一份不错的实习，所以打算重读《C++ Primer》，着重啃掉以前遗留下来的难点。

毫无疑问这将花费我很多时间，希望我能够将这篇博客梳理出来。

###数组和指针

> - 在用下标访问元素时，`vector`使用`vector::size_type`作为下标的类型，而数组下标的正确类型则是`size_t`

> - C++提供一种特殊的指针类型`void*`，它可以保存任何类型对象的地址；因为`void*`没有涉及类型，故而不能够使用解引用操作符`*`来获取其对应地址的值；
可以执行的操作有：

>> 与另一个指针进行比较；向函数传递`void*	`指针或从函数返回`void*`指针以及`void*`赋值

> - 指针和引用的比较：引用（`reference`）和指针（`pointer`）都可间接访问另一个值，但二者之间有以下两个区别

>> 1、引用总是指向某一个对象，定义引用时没有初始化是错误的。

>> 2、给引用赋值修改的是该引用所关联的对象的值，而不是像指针那样使引用与另一个对象关联。

> - 可以对同一数组不同元素的指针做减法操作，其结果是**标准库类型**`ptrdiff_t`，与`size_t`一样，`ptrdiff_t`也是一种与机器相关的类型，在`cstddef`头文件中定义；`size_t`是`unsigned`类型，而`ptrdiff_t`则是`signed`类型

> - 当指针指向`const`对象，不允许用指针来改变其所指的`const`值；允许把非`const`对象的地址赋给指向`const`对象的指针，但之后不允许通过该指针修改对应`const`对象的值

> - 当指针为`const`指针时，该指针值不可修改，但其所指向对象的值不受限制；与任何`const`量一样，`const`指针必须在定义时初始化

> - 数组类型的变量有三个重要限制：

>> 1、数组长度固定不变

>> 2、编译时必须知道数组长度

>> 3、数组只在定义它的块语句内存在

> - 每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配对象，此内存空间称为程序的**自由存储区**或**堆**。C语言使用标准库函数`malloc`和`free`分配存储空间，而C++语言使用`new`和`delete`实现相同功能

> - C++为含点操作符和解引用操作符的表达式提供了一个同义词：箭头操作符（->）；例如：

>> `*(person).name` 等价于 `person->name`

###函数

> - 利用`const`引用避免复制：一般情况下形参需要复制实参的值，这样会导致效率低下，一种比较好的解决方法是使用`const`引用；（注：**当然传递后的实参是不可改变的**）

> - 调用函数时，可以省略有默认值的实参。调用包含默认实参的函数时，若提供实参，则覆盖默认实参值，否则使用默认实参。默认实参只需在函数声明或函数定义中指定一次即可，不可重复指定。

> ####内联函数：

>> -  在函数返回类型前加上`inline`即将函数指定为内联函数；内联函数适用于优化小的、只有几行的且经常被调用的函数。（注：**优化效果类似于宏定义**）

>> - 类的所有成员都必须在类定义的花括号里面声明（注：**不是定义**），此后就不能再为类添加任何成员。类的成员函数既可以在类的定义内也可以在类的定义外定义。

>> - 编译器隐式地将在类内定义的成员函数当做内联函数。

> - 构造函数和类同名，且没有返回类型；一个类可以有多个构造函数。

> 现在分析构造函数形如`Person(): age(0), name("yinwoods") { }`

>> 1、构造函数不含形参说明为默认构造函数。

>> 2、冒号与花括号之间的代码称为**构造函数的初始化列表**，其中包含一系列成员名，每个成员名后面是括在括号中的初始值。

###容器

>#####顺序容器

>> - 顺序容器有`vector`、`list`、`deque`三种，其中`vector`和`deque`为元素提供随机访问，而`list`顾名思义，操作类似于链表。

>#####关联容器

>> - 关联容器支持通过键(`key`)高效地查找和读取元素，两个基本类型是`map`和`set`。

>> - `pair`类型包含两个数据值，可通过`pair.first`和`pair.second`进行访问；一般使用`make_pair(first, second)`来创建`pair`。

>> - 使用关联容器时，它的键不但有一个类型，而且还有一个相关的比较函数。

>> - `map`使用下标过程中需要注意，如果该键不在`map`容器中，那么下标操作会插入一个具有该键的新元素。

>> - 可以使用`count`和`find`检查某个键是否存在

>> - 相比于`map`，`set`只是简单的键的集合

>> - `map`、`set`中，一个键只能对应一个实例，而`multimap`和`multiset`允许一个键对应多个实例。

>> - 在`multiset` `multimap`查询中，可以使用`upper_bound(key)`、`lower_bound(key)`以及`equal_range(key)`。

###类

> - 在C++中，如果类是用`struct`定义的，默认成员是公有的，而类如果用`class`定义，默认成员为私有。
**

> - 构造函数可以包含一个构造函数初始化列表，形如`Person::Person(string name):age(21), address("...") { } `(注：**初始化`const`或引用类型数据以及没有默认构造函数成员的唯一机会是在构造函数初始化列表中**)

> - 成员初始化次序就是定义成员的次序

#####友元（允许一个类将其非公有成员的访问权授予指定的函数或类）

> - 通常，将友元声明成组地放在类定义的开始或结尾

###